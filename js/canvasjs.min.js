! function () {
    function a(a, c) {
        a.prototype = b(c.prototype), a.prototype.constructor = a, a.base = c.prototype
    }

    function b(a) {
        function b() {}
        return b.prototype = a, new b
    }

    function c(a, b, c) {
        return "millisecond" === c ? a.setMilliseconds(a.getMilliseconds() + 1 * b) : "second" === c ? a.setSeconds(a.getSeconds() + 1 * b) : "minute" === c ? a.setMinutes(a.getMinutes() + 1 * b) : "hour" === c ? a.setHours(a.getHours() + 1 * b) : "day" === c ? a.setDate(a.getDate() + 1 * b) : "week" === c ? a.setDate(a.getDate() + 7 * b) : "month" === c ? a.setMonth(a.getMonth() + 1 * b) : "year" === c && a.setFullYear(a.getFullYear() + 1 * b), a
    }

    function d(a, b) {
        var c = !1;
        for (0 > a && (c = !0, a *= -1), a = "" + a, b = b ? b : 1; a.length < b;) a = "0" + a;
        return c ? "-" + a : a
    }

    function e(a) {
        if (!a) return a;
        a = a.replace(/^\s\s*/, "");
        for (var b = /\s/, c = a.length; b.test(a.charAt(--c)););
        return a.slice(0, c + 1)
    }

    function f(a) {
        a.roundRect = function (a, b, c, d, e, f, g, h) {
            g && (this.fillStyle = g), h && (this.strokeStyle = h), "undefined" == typeof e && (e = 5), this.lineWidth = f, this.beginPath(), this.moveTo(a + e, b), this.lineTo(a + c - e, b), this.quadraticCurveTo(a + c, b, a + c, b + e), this.lineTo(a + c, b + d - e), this.quadraticCurveTo(a + c, b + d, a + c - e, b + d), this.lineTo(a + e, b + d), this.quadraticCurveTo(a, b + d, a, b + d - e), this.lineTo(a, b + e), this.quadraticCurveTo(a, b, a + e, b), this.closePath(), g && this.fill(), h && 0 < f && this.stroke()
        }
    }

    function g(a, b) {
        return a - b
    }

    function h(a, b) {
        return a.x - b.x
    }

    function k(a) {
        var b = ((16711680 & a) >> 16).toString(16)
            , c = ((65280 & a) >> 8).toString(16);
        return a = ((255 & a) >> 0).toString(16), b = 2 > b.length ? "0" + b : b, c = 2 > c.length ? "0" + c : c, a = 2 > a.length ? "0" + a : a, "#" + b + c + a
    }

    function l(a, b) {
        var c = this.length >>> 0
            , d = Number(b) || 0
            , d = 0 > d ? Math.ceil(d) : Math.floor(d);
        for (0 > d && (d += c); d < c; d++)
            if (d in this && this[d] === a) return d;
        return -1
    }

    function m(a) {
        return null === a || "undefined" == typeof a
    }

    function n(a, b, c) {
        c = c || "normal";
        var d = a + "_" + b + "_" + c
            , e = X[d];
        if (isNaN(e)) {
            try {
                if (a = "position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:" + a + "; font-size:" + b + "px; font-weight:" + c + ";", !Y) {
                    var f = document.body;
                    Y = document.createElement("span"), Y.innerHTML = "";
                    var g = document.createTextNode("Mpgyi");
                    Y.appendChild(g), f.appendChild(Y)
                }
                Y.style.display = "", Y.setAttribute("style", a), e = Math.round(Y.offsetHeight), Y.style.display = "none"
            }
            catch (a) {
                e = Math.ceil(1.1 * b)
            }
            e = Math.max(e, b), X[d] = e
        }
        return e
    }

    function o(a, b) {
        var c = [];
        if (c = {
                solid: []
                , shortDash: [3, 1]
                , shortDot: [1, 1]
                , shortDashDot: [3, 1, 1, 1]
                , shortDashDotDot: [3, 1, 1, 1, 1, 1]
                , dot: [1, 2]
                , dash: [4, 2]
                , dashDot: [4, 2, 1, 2]
                , longDash: [8, 2]
                , longDashDot: [8, 2, 1, 2]
                , longDashDotDot: [8, 2, 1, 2, 1, 2]
            }[a || "solid"])
            for (var d = 0; d < c.length; d++) c[d] *= b;
        else c = [];
        return c
    }

    function p(a, b, c, d) {
        if (a.addEventListener) a.addEventListener(b, c, d || !1);
        else {
            if (!a.attachEvent) return !1;
            a.attachEvent("on" + b, function (b) {
                b = b || window.event, b.preventDefault = b.preventDefault || function () {
                    b.returnValue = !1
                }, b.stopPropagation = b.stopPropagation || function () {
                    b.cancelBubble = !0
                }, c.call(a, b)
            })
        }
    }

    function q(a, b, c) {
        for (a *= da, b *= da, a = c.getImageData(a, b, 2, 2).data, b = !0, c = 0; 4 > c; c++)
            if (a[c] !== a[c + 4] | a[c] !== a[c + 8] | a[c] !== a[c + 12]) {
                b = !1;
                break
            }
        return b ? a[0] << 16 | a[1] << 8 | a[2] : 0
    }

    function r(a, b, c) {
        return a in b ? b[a] : c[a]
    }

    function s(a, b, c) {
        if (R && aa) {
            var d = a.getContext("2d");
            ca = d.webkitBackingStorePixelRatio || d.mozBackingStorePixelRatio || d.msBackingStorePixelRatio || d.oBackingStorePixelRatio || d.backingStorePixelRatio || 1, da = ba / ca, a.width = b * da, a.height = c * da, ba !== ca && (a.style.width = b + "px", a.style.height = c + "px", d.scale(da, da))
        }
        else a.width = b, a.height = c
    }

    function t(a) {
        if (!ea) {
            var b = !1
                , c = !1;
            "undefined" == typeof S.Chart.creditHref ? (a.creditHref = "#", a.creditText = " ") : (b = a.updateOption("creditText"), c = a.updateOption("creditHref")), a.creditHref && a.creditText && (a._creditLink || (a._creditLink = document.createElement("a"), a._creditLink.setAttribute("class", "canvasjs-chart-credit"), a._creditLink.setAttribute("style", "outline:none;margin:0px;position:absolute;right:2px;top:" + (a.height - 14) + "px;color:dimgrey;text-decoration:none;font-size:11px;font-family: Calibri, Lucida Grande, Lucida Sans Unicode, Arial, sans-serif"), a._creditLink.setAttribute("tabIndex", -1), a._creditLink.setAttribute("target", "_blank")), (0 === a.renderCount || b || c) && (a._creditLink.setAttribute("href", a.creditHref), a._creditLink.innerHTML = a.creditText), a._creditLink && a.creditHref && a.creditText ? (a._creditLink.parentElement || a._canvasJSContainer.appendChild(a._creditLink), a._creditLink.style.top = a.height - 14 + "px") : a._creditLink.parentElement && a._canvasJSContainer.removeChild(a._creditLink))
        }
    }

    function u(a, b) {
        var c = document.createElement("canvas");
        return c.setAttribute("class", "canvasjs-chart-canvas"), s(c, a, b), R || "undefined" == typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(c), c
    }

    function v(a, b, c) {
        if (a && b && c) {
            c = c + "." + b;
            var d = "image/" + b;
            a = a.toDataURL(d);
            var e = !1
                , f = document.createElement("a");
            if (f.download = c, f.href = a, f.target = "_blank", "undefined" != typeof Blob && new Blob) {
                for (var g = a.replace(/^data:[a-z\/]*;base64,/, ""), g = atob(g), h = new ArrayBuffer(g.length), h = new Uint8Array(h), i = 0; i < g.length; i++) h[i] = g.charCodeAt(i);
                b = new Blob([h.buffer], {
                    type: "image/" + b
                });
                try {
                    window.navigator.msSaveBlob(b, c), e = !0
                }
                catch (a) {
                    f.dataset.downloadurl = [d, f.download, f.href].join(":"), f.href = window.URL.createObjectURL(b)
                }
            }
            if (!e) try {
                event = document.createEvent("MouseEvents"), event.initMouseEvent("click", !0, !1, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), f.dispatchEvent ? f.dispatchEvent(event) : f.fireEvent && f.fireEvent("onclick")
            }
            catch (c) {
                b = window.open(), b.document.write("<img src='" + a + "'></img><div>Please right click on the image and save it to your device</div>"), b.document.close()
            }
        }
    }

    function w(a, b, c) {
        b.getAttribute("state") !== c && (b.setAttribute("state", c), b.setAttribute("type", "button"), b.style.position = "relative", b.style.margin = "0px 0px 0px 0px", b.style.padding = "3px 4px 0px 4px", b.style.cssFloat = "left", b.setAttribute("title", a._cultureInfo[c + "Text"]), b.innerHTML = "<img style='height:16px;' src='" + fa[c].image + "' alt='" + a._cultureInfo[c + "Text"] + "' />")
    }

    function x() {
        for (var a = null, b = 0; b < arguments.length; b++) a = arguments[b], a.style && (a.style.display = "inline")
    }

    function y() {
        for (var a = null, b = 0; b < arguments.length; b++)(a = arguments[b]) && a.style && (a.style.display = "none")
    }

    function z(a, b, c, d) {
        this._defaultsKey = a, this.parent = d, this._eventListeners = [], d = {}, c && V[c] && V[c][a] && (d = V[c][a]), this._options = b ? b : {}, this.setOptions(this._options, d)
    }

    function A(a, b, c) {
        this._publicChartReference = c, b = b || {}, A.base.constructor.call(this, "Chart", b, b.theme ? b.theme : "theme1");
        var d = this;
        this._containerId = a, this._objectsInitialized = !1, this.overlaidCanvasCtx = this.ctx = null, this._indexLabels = [], this._panTimerId = 0, this._lastTouchEventType = "", this._lastTouchData = null, this.isAnimating = !1, this.renderCount = 0, this.panEnabled = this.disableToolTip = this.animatedRender = !1, this._defaultCursor = "default", this.plotArea = {
            canvas: null
            , ctx: null
            , x1: 0
            , y1: 0
            , x2: 0
            , y2: 0
            , width: 0
            , height: 0
        }, this._dataInRenderedOrder = [], (this._container = "string" == typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) ? (this._container.innerHTML = "", b = a = 0, a = this._options.width ? this.width : 0 < this._container.clientWidth ? this._container.clientWidth : this.width, b = this._options.height ? this.height : 0 < this._container.clientHeight ? this._container.clientHeight : this.height, this.width = a, this.height = b, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, this._selectedColorSet = "undefined" != typeof U[this.colorSet] ? U[this.colorSet] : U.colorSet1, this._canvasJSContainer = document.createElement("div"), this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container"), this._canvasJSContainer.style.position = "relative", this._canvasJSContainer.style.textAlign = "left", this._canvasJSContainer.style.cursor = "auto", R || (this._canvasJSContainer.style.height = "0px"), this._container.appendChild(this._canvasJSContainer), this.canvas = u(a, b), this.canvas.style.position = "absolute", this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", f(this.ctx), R ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = u(a, b), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this.overlaidCanvas = u(a, b), this.overlaidCanvas.style.position = "absolute", this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", this._eventManager = new N(this), p(window, "resize", function () {
            d._updateSize() && d.render()
        }), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), this._toolBar.style.cssText = "position: absolute; right: 1px; top: 1px;", this._canvasJSContainer.appendChild(this._toolBar), this.bounds = {
            x1: 0
            , y1: 0
            , x2: this.width
            , y2: this.height
        }, p(this.overlaidCanvas, "click", function (a) {
            d._mouseEventHandler(a)
        }), p(this.overlaidCanvas, "mousemove", function (a) {
            d._mouseEventHandler(a)
        }), p(this.overlaidCanvas, "mouseup", function (a) {
            d._mouseEventHandler(a)
        }), p(this.overlaidCanvas, "mousedown", function (a) {
            d._mouseEventHandler(a), y(d._dropdownMenu)
        }), p(this.overlaidCanvas, "mouseout", function (a) {
            d._mouseEventHandler(a)
        }), p(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function (a) {
            d._touchEventHandler(a)
        }), p(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function (a) {
            d._touchEventHandler(a)
        }), p(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function (a) {
            d._touchEventHandler(a)
        }), p(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function (a) {
            d._touchEventHandler(a)
        }), this._toolTip = new M(this, this._options.toolTip, this.theme), this.axisY2 = this.axisY = this.axisX = this.data = null, this.sessionVariables = {
            axisX: {}
            , axisY: {}
            , axisY2: {}
        })) : window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found')
    }

    function B(a, b) {
        for (var d, c = [], e = 0; e < a.length; e++)
            if (0 == e) c.push(a[0]);
            else {
                var f, g, h;
                h = e - 1, f = 0 === h ? 0 : h - 1, g = h === a.length - 1 ? h : h + 1, d = Math.abs((a[g].x - a[f].x) / (0 === a[g].x - a[h].x ? .01 : a[g].x - a[h].x)) * (b - 1) / 2 + 1;
                var i = (a[g].x - a[f].x) / d;
                d = (a[g].y - a[f].y) / d, c[c.length] = a[h].x > a[f].x && 0 < i || a[h].x < a[f].x && 0 > i ? {
                    x: a[h].x + i / 3
                    , y: a[h].y + d / 3
                } : {
                    x: a[h].x
                    , y: a[h].y + d / 9
                }, h = e, f = 0 === h ? 0 : h - 1, g = h === a.length - 1 ? h : h + 1, d = Math.abs((a[g].x - a[f].x) / (0 === a[h].x - a[f].x ? .01 : a[h].x - a[f].x)) * (b - 1) / 2 + 1, i = (a[g].x - a[f].x) / d, d = (a[g].y - a[f].y) / d, c[c.length] = a[h].x > a[f].x && 0 < i || a[h].x < a[f].x && 0 > i ? {
                    x: a[h].x - i / 3
                    , y: a[h].y - d / 3
                } : {
                    x: a[h].x
                    , y: a[h].y - d / 9
                }, c[c.length] = a[e]
            }
        return c
    }

    function C(a, b) {
        if (null === a || "undefined" == typeof a) return b;
        var c = parseFloat(a.toString()) * (0 <= a.toString().indexOf("%") ? b / 100 : 1);
        return !isNaN(c) && c <= b && 0 <= c ? c : b
    }

    function D(a, b, c, d, e) {
        "undefined" == typeof e && (e = 0), this._padding = e, this._x1 = a, this._y1 = b, this._x2 = c, this._y2 = d, this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding
    }

    function E(a, b) {
        E.base.constructor.call(this, "TextBlock", b), this.ctx = a, this._isDirty = !0, this._wrappedText = null
    }

    function F(a, b) {
        if (F.base.constructor.call(this, "Title", b, a.theme), this.chart = a, this.canvas = a.canvas, this.ctx = this.chart.ctx, m(this._options.margin) && a._options.subtitles)
            for (var c = a._options.subtitles, d = 0; d < c.length; d++)
                if ((m(c[d].horizontalAlign) && "center" === this.horizontalAlign || c[d].horizontalAlign === this.horizontalAlign) && (m(c[d].verticalAlign) && "top" === this.verticalAlign || c[d].verticalAlign === this.verticalAlign) && !c[d].dockInsidePlotArea == !this.dockInsidePlotArea) {
                    this.margin = 0;
                    break
                }
                "undefined" == typeof this._options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.height = this.width = null, this.bounds = {
            x1: null
            , y1: null
            , x2: null
            , y2: null
        }
    }

    function G(a, b) {
        G.base.constructor.call(this, "Subtitle", b, a.theme), this.chart = a, this.canvas = a.canvas, this.ctx = this.chart.ctx, "undefined" == typeof this._options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.height = this.width = null, this.bounds = {
            x1: null
            , y1: null
            , x2: null
            , y2: null
        }
    }

    function H(a, b, c) {
        H.base.constructor.call(this, "Legend", b, c), this.chart = a, this.canvas = a.canvas, this.ctx = this.chart.ctx, this.ghostCtx = this.chart._eventManager.ghostCtx, this.items = [], this.height = this.width = 0, this.orientation = null, this.dataSeries = [], this.bounds = {
            x1: null
            , y1: null
            , x2: null
            , y2: null
        }, "undefined" == typeof this._options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.lineHeight = n(this.fontFamily, this.fontSize, this.fontWeight), this.horizontalSpacing = this.fontSize
    }

    function I(a, b) {
        I.base.constructor.call(this, b), this.chart = a, this.canvas = a.canvas, this.ctx = this.chart.ctx
    }

    function J(a, b, c, d, e) {
        J.base.constructor.call(this, "DataSeries", b, c), this.chart = a, this.canvas = a.canvas, this._ctx = a.canvas.ctx, this.index = d, this.noDataPointsInPlotArea = 0, this.id = e, this.chart._eventManager.objectMap[e] = {
            id: e
            , objectType: "dataSeries"
            , dataSeriesIndex: d
        }, this.dataPointIds = [], this.plotUnit = [], this.axisY = this.axisX = null, null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = .7 : this.fillOpacity = 1), this.axisPlacement = this.getDefaultAxisPlacement(), "undefined" == typeof this._options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize))
    }

    function K(a, b, c, d) {
        if (K.base.constructor.call(this, "Axis", b, a.theme), this.chart = a, this.canvas = a.canvas, this.ctx = a.ctx, this.intervalStartPosition = this.maxHeight = this.maxWidth = 0, this.labels = [], this._stripLineLabels = this._ticks = this._labels = null, this.dataInfo = {
                min: 1 / 0
                , max: -(1 / 0)
                , viewPortMin: 1 / 0
                , viewPortMax: -(1 / 0)
                , minDiff: 1 / 0
            }, "axisX" === c ? (this.sessionVariables = this.chart.sessionVariables[c], this._options.interval || (this.intervalType = null), "theme2" === this.chart.theme && m(this._options.lineThickness) && (this.lineThickness = 2)) : this.sessionVariables = "left" === d || "top" === d ? this.chart.sessionVariables.axisY : this.chart.sessionVariables.axisY2, "undefined" == typeof this._options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize)), "undefined" == typeof this._options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize)), this.type = c, "axisX" !== c || b && "undefined" != typeof b.gridThickness || (this.gridThickness = 0), this._position = d, this.lineCoordinates = {
                x1: null
                , y1: null
                , x2: null
                , y2: null
                , width: null
            }, this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360), this._options.stripLines && 0 < this._options.stripLines.length)
            for (this.stripLines = [], b = 0; b < this._options.stripLines.length; b++) this.stripLines.push(new L(this.chart, this._options.stripLines[b], a.theme, ++this.chart._eventManager.lastObjectId, this));
        this._titleTextBlock = null, this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this._options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null), this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum, this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this._options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null), this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum, null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum)), null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum)), this.trackChanges("viewportMinimum"), this.trackChanges("viewportMaximum")
    }

    function L(a, b, c, d, e) {
        L.base.constructor.call(this, "StripLine", b, c, e), this.id = d, this.chart = a, this.ctx = this.chart.ctx, this.label = this.label, this._thicknessType = "pixel", null !== this.startValue && null !== this.endValue && (this.value = e.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this.thickness = e.logarithmic ? Math.log(this.endValue / this.startValue) / Math.log(e.logarithmBase) : Math.max(this.endValue - this.startValue), this._thicknessType = "value")
    }

    function M(a, b, c) {
        M.base.constructor.call(this, "ToolTip", b, c), this.chart = a, this.canvas = a.canvas, this.ctx = this.chart.ctx, this.currentDataPointIndex = this.currentSeriesIndex = -1, this._timerId = 0, this._prevY = this._prevX = NaN, this._initialize()
    }

    function N(a) {
        this.chart = a, this.lastObjectId = 0, this.objectMap = [], this.rectangularRegionEventSubscriptions = [], this.previousDataPointEventObject = null, this.ghostCanvas = u(this.chart.width, this.chart.height), this.ghostCtx = this.ghostCanvas.getContext("2d"), this.mouseoveredObjectMaps = []
    }

    function O(a) {
        var b;
        a && T[a] && (b = T[a]), O.base.constructor.call(this, "CultureInfo", b)
    }

    function P(a) {
        this.chart = a, this.ctx = this.chart.plotArea.ctx, this.animations = [], this.animationRequestId = null
    }
    var Q = {}
        , R = !!document.createElement("canvas").getContext
        , S = {
            Chart: {
                width: 500
                , height: 400
                , zoomEnabled: !1
                , zoomType: "x"
                , theme: "theme1"
                , animationEnabled: !1
                , animationDuration: 1200
                , dataPointWidth: null
                , dataPointMinWidth: null
                , dataPointMaxWidth: null
                , colorSet: "colorSet1"
                , culture: "en"
                , creditHref: ""
                , creditText: "CanvasJS"
                , interactivityEnabled: !0
                , exportEnabled: !1
                , exportFileName: "Chart"
                , rangeChanging: null
                , rangeChanged: null
            }
            , Title: {
                padding: 0
                , text: null
                , verticalAlign: "top"
                , horizontalAlign: "center"
                , fontSize: 20
                , fontFamily: "Calibri"
                , fontWeight: "normal"
                , fontColor: "black"
                , fontStyle: "normal"
                , borderThickness: 0
                , borderColor: "black"
                , cornerRadius: 0
                , backgroundColor: null
                , margin: 5
                , wrap: !0
                , maxWidth: null
                , dockInsidePlotArea: !1
            }
            , Subtitle: {
                padding: 0
                , text: null
                , verticalAlign: "top"
                , horizontalAlign: "center"
                , fontSize: 14
                , fontFamily: "Calibri"
                , fontWeight: "normal"
                , fontColor: "black"
                , fontStyle: "normal"
                , borderThickness: 0
                , borderColor: "black"
                , cornerRadius: 0
                , backgroundColor: null
                , margin: 2
                , wrap: !0
                , maxWidth: null
                , dockInsidePlotArea: !1
            }
            , Legend: {
                name: null
                , verticalAlign: "center"
                , horizontalAlign: "right"
                , fontSize: 14
                , fontFamily: "calibri"
                , fontWeight: "normal"
                , fontColor: "black"
                , fontStyle: "normal"
                , cursor: null
                , itemmouseover: null
                , itemmouseout: null
                , itemmousemove: null
                , itemclick: null
                , dockInsidePlotArea: !1
                , reversed: !1
                , maxWidth: null
                , maxHeight: null
                , itemMaxWidth: null
                , itemWidth: null
                , itemWrap: !0
                , itemTextFormatter: null
            }
            , ToolTip: {
                enabled: !0
                , shared: !1
                , animationEnabled: !0
                , content: null
                , contentFormatter: null
                , reversed: !1
                , backgroundColor: null
                , borderColor: null
                , borderThickness: 2
                , cornerRadius: 5
                , fontSize: 14
                , fontColor: null
                , fontFamily: "Calibri, Arial, Georgia, serif;"
                , fontWeight: "normal"
                , fontStyle: "italic"
            }
            , Axis: {
                minimum: null
                , maximum: null
                , viewportMinimum: null
                , viewportMaximum: null
                , interval: null
                , intervalType: null
                , reversed: !1
                , logarithmic: !1
                , logarithmBase: 10
                , title: null
                , titleFontColor: "black"
                , titleFontSize: 20
                , titleFontFamily: "arial"
                , titleFontWeight: "normal"
                , titleFontStyle: "normal"
                , titleWrap: !0
                , titleMaxWidth: null
                , labelAngle: 0
                , labelFontFamily: "arial"
                , labelFontColor: "black"
                , labelFontSize: 12
                , labelFontWeight: "normal"
                , labelFontStyle: "normal"
                , labelAutoFit: !0
                , labelWrap: !0
                , labelMaxWidth: null
                , labelFormatter: null
                , prefix: ""
                , suffix: ""
                , includeZero: !0
                , tickLength: 5
                , tickColor: "black"
                , tickThickness: 1
                , lineColor: "black"
                , lineThickness: 1
                , lineDashType: "solid"
                , gridColor: "A0A0A0"
                , gridThickness: 0
                , gridDashType: "solid"
                , interlacedColor: null
                , valueFormatString: null
                , margin: 2
                , stripLines: []
            }
            , StripLine: {
                value: null
                , startValue: null
                , endValue: null
                , color: "orange"
                , opacity: null
                , thickness: 2
                , lineDashType: "solid"
                , label: ""
                , labelPlacement: "inside"
                , labelAlign: "far"
                , labelWrap: !0
                , labelMaxWidth: null
                , labelBackgroundColor: "transparent"
                , labelFontFamily: "arial"
                , labelFontColor: "orange"
                , labelFontSize: 12
                , labelFontWeight: "normal"
                , labelFontStyle: "normal"
                , labelFormatter: null
                , showOnTop: !1
            }
            , DataSeries: {
                name: null
                , dataPoints: null
                , label: ""
                , bevelEnabled: !1
                , highlightEnabled: !0
                , cursor: null
                , indexLabel: ""
                , indexLabelPlacement: "auto"
                , indexLabelOrientation: "horizontal"
                , indexLabelFontColor: "black"
                , indexLabelFontSize: 12
                , indexLabelFontStyle: "normal"
                , indexLabelFontFamily: "Arial"
                , indexLabelFontWeight: "normal"
                , indexLabelBackgroundColor: null
                , indexLabelLineColor: null
                , indexLabelLineThickness: 1
                , indexLabelLineDashType: "solid"
                , indexLabelMaxWidth: null
                , indexLabelWrap: !0
                , indexLabelFormatter: null
                , lineThickness: 2
                , lineDashType: "solid"
                , connectNullData: !1
                , nullDataLineDashType: "dash"
                , color: null
                , lineColor: null
                , risingColor: "white"
                , fillOpacity: null
                , startAngle: 0
                , radius: null
                , innerRadius: null
                , type: "column"
                , xValueType: "number"
                , axisYType: "primary"
                , xValueFormatString: null
                , yValueFormatString: null
                , zValueFormatString: null
                , percentFormatString: null
                , showInLegend: null
                , legendMarkerType: null
                , legendMarkerColor: null
                , legendText: null
                , legendMarkerBorderColor: null
                , legendMarkerBorderThickness: null
                , markerType: "circle"
                , markerColor: null
                , markerSize: null
                , markerBorderColor: null
                , markerBorderThickness: null
                , mouseover: null
                , mouseout: null
                , mousemove: null
                , click: null
                , toolTipContent: null
                , visible: !0
            }
            , TextBlock: {
                x: 0
                , y: 0
                , width: null
                , height: null
                , maxWidth: null
                , maxHeight: null
                , padding: 0
                , angle: 0
                , text: ""
                , horizontalAlign: "center"
                , fontSize: 12
                , fontFamily: "calibri"
                , fontWeight: "normal"
                , fontColor: "black"
                , fontStyle: "normal"
                , borderThickness: 0
                , borderColor: "black"
                , cornerRadius: 0
                , backgroundColor: null
                , textBaseline: "top"
            }
            , CultureInfo: {
                decimalSeparator: "."
                , digitGroupSeparator: ","
                , zoomText: "Zoom"
                , panText: "Pan"
                , resetText: "Reset"
                , menuText: "More Options"
                , saveJPGText: "Save as JPEG"
                , savePNGText: "Save as PNG"
                , days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")
                , shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" ")
                , months: "January February March April May June July August September October November December".split(" ")
                , shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
            }
        }
        , T = {
            en: {}
        }
        , U = {
            colorSet1: "#369EAD #C24642 #7F6084 #86B402 #A2D1CF #C8B631 #6DBCEB #52514E #4F81BC #A064A1 #F79647".split(" ")
            , colorSet2: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #33558B".split(" ")
            , colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ")
        }
        , V = {
            theme1: {
                Chart: {
                    colorSet: "colorSet1"
                }
                , Title: {
                    fontFamily: R ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri"
                    , fontSize: 33
                    , fontColor: "#3A3A3A"
                    , fontWeight: "bold"
                    , verticalAlign: "top"
                    , margin: 5
                }
                , Subtitle: {
                    fontFamily: R ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri"
                    , fontSize: 16
                    , fontColor: "#3A3A3A"
                    , fontWeight: "bold"
                    , verticalAlign: "top"
                    , margin: 5
                }
                , Axis: {
                    titleFontSize: 26
                    , titleFontColor: "#666666"
                    , titleFontFamily: R ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri"
                    , labelFontFamily: R ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri"
                    , labelFontSize: 18
                    , labelFontColor: "grey"
                    , tickColor: "#BBBBBB"
                    , tickThickness: 2
                    , gridThickness: 2
                    , gridColor: "#BBBBBB"
                    , lineThickness: 2
                    , lineColor: "#BBBBBB"
                }
                , Legend: {
                    verticalAlign: "bottom"
                    , horizontalAlign: "center"
                    , fontFamily: R ? "monospace, sans-serif,arial black" : "calibri"
                }
                , DataSeries: {
                    indexLabelFontColor: "grey"
                    , indexLabelFontFamily: R ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri"
                    , indexLabelFontSize: 18
                    , indexLabelLineThickness: 1
                }
            }
            , theme2: {
                Chart: {
                    colorSet: "colorSet2"
                }
                , Title: {
                    fontFamily: "impact, charcoal, arial black, sans-serif"
                    , fontSize: 32
                    , fontColor: "#333333"
                    , verticalAlign: "top"
                    , margin: 5
                }
                , Subtitle: {
                    fontFamily: "impact, charcoal, arial black, sans-serif"
                    , fontSize: 14
                    , fontColor: "#333333"
                    , verticalAlign: "top"
                    , margin: 5
                }
                , Axis: {
                    titleFontSize: 22
                    , titleFontColor: "rgb(98,98,98)"
                    , titleFontFamily: R ? "monospace, sans-serif,arial black" : "arial"
                    , titleFontWeight: "bold"
                    , labelFontFamily: R ? "monospace, Courier New, Courier" : "arial"
                    , labelFontSize: 16
                    , labelFontColor: "grey"
                    , labelFontWeight: "bold"
                    , tickColor: "grey"
                    , tickThickness: 2
                    , gridThickness: 2
                    , gridColor: "grey"
                    , lineColor: "grey"
                    , lineThickness: 0
                }
                , Legend: {
                    verticalAlign: "bottom"
                    , horizontalAlign: "center"
                    , fontFamily: R ? "monospace, sans-serif,arial black" : "arial"
                }
                , DataSeries: {
                    indexLabelFontColor: "grey"
                    , indexLabelFontFamily: R ? "Courier New, Courier, monospace" : "arial"
                    , indexLabelFontWeight: "bold"
                    , indexLabelFontSize: 18
                    , indexLabelLineThickness: 1
                }
            }
            , theme3: {
                Chart: {
                    colorSet: "colorSet1"
                }
                , Title: {
                    fontFamily: R ? "Candara, Optima, Trebuchet MS, Helvetica Neue, Helvetica, Trebuchet MS, serif" : "calibri"
                    , fontSize: 32
                    , fontColor: "#3A3A3A"
                    , fontWeight: "bold"
                    , verticalAlign: "top"
                    , margin: 5
                }
                , Subtitle: {
                    fontFamily: R ? "Candara, Optima, Trebuchet MS, Helvetica Neue, Helvetica, Trebuchet MS, serif" : "calibri"
                    , fontSize: 16
                    , fontColor: "#3A3A3A"
                    , fontWeight: "bold"
                    , verticalAlign: "top"
                    , margin: 5
                }
                , Axis: {
                    titleFontSize: 22
                    , titleFontColor: "rgb(98,98,98)"
                    , titleFontFamily: R ? "Verdana, Geneva, Calibri, sans-serif" : "calibri"
                    , labelFontFamily: R ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri"
                    , labelFontSize: 18
                    , labelFontColor: "grey"
                    , tickColor: "grey"
                    , tickThickness: 2
                    , gridThickness: 2
                    , gridColor: "grey"
                    , lineThickness: 2
                    , lineColor: "grey"
                }
                , Legend: {
                    verticalAlign: "bottom"
                    , horizontalAlign: "center"
                    , fontFamily: R ? "monospace, sans-serif,arial black" : "calibri"
                }
                , DataSeries: {
                    bevelEnabled: !0
                    , indexLabelFontColor: "grey"
                    , indexLabelFontFamily: R ? "Candara, Optima, Calibri, Verdana, Geneva, sans-serif" : "calibri"
                    , indexLabelFontSize: 18
                    , indexLabelLineColor: "lightgrey"
                    , indexLabelLineThickness: 2
                }
            }
        }
        , W = {
            numberDuration: 1
            , yearDuration: 314496e5
            , monthDuration: 2592e6
            , weekDuration: 6048e5
            , dayDuration: 864e5
            , hourDuration: 36e5
            , minuteDuration: 6e4
            , secondDuration: 1e3
            , millisecondDuration: 1
            , dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")
        }
        , X = {}
        , Y = null
        , Z = function () {
            var a = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g
                , b = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")
                , c = "Sun Mon Tue Wed Thu Fri Sat".split(" ")
                , e = "January February March April May June July August September October November December".split(" ")
                , f = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
                , g = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g
                , h = /[^-+\dA-Z]/g;
            return function (i, j, k) {
                var l = k ? k.days : b
                    , m = k ? k.months : e
                    , n = k ? k.shortDays : c
                    , o = k ? k.shortMonths : f;
                k = "";
                var p = !1;
                if (i = i && i.getTime ? i : i ? new Date(i) : new Date, isNaN(i)) throw SyntaxError("invalid date");
                "UTC:" === j.slice(0, 4) && (j = j.slice(4), p = !0), k = p ? "getUTC" : "get";
                var q = i[k + "Date"]()
                    , r = i[k + "Day"]()
                    , s = i[k + "Month"]()
                    , t = i[k + "FullYear"]()
                    , u = i[k + "Hours"]()
                    , v = i[k + "Minutes"]()
                    , w = i[k + "Seconds"]()
                    , x = i[k + "Milliseconds"]()
                    , y = p ? 0 : i.getTimezoneOffset();
                return k = j.replace(a, function (a) {
                    switch (a) {
                    case "D":
                        return q;
                    case "DD":
                        return d(q, 2);
                    case "DDD":
                        return n[r];
                    case "DDDD":
                        return l[r];
                    case "M":
                        return s + 1;
                    case "MM":
                        return d(s + 1, 2);
                    case "MMM":
                        return o[s];
                    case "MMMM":
                        return m[s];
                    case "Y":
                        return parseInt(String(t).slice(-2));
                    case "YY":
                        return d(String(t).slice(-2), 2);
                    case "YYY":
                        return d(String(t).slice(-3), 3);
                    case "YYYY":
                        return d(t, 4);
                    case "h":
                        return u % 12 || 12;
                    case "hh":
                        return d(u % 12 || 12, 2);
                    case "H":
                        return u;
                    case "HH":
                        return d(u, 2);
                    case "m":
                        return v;
                    case "mm":
                        return d(v, 2);
                    case "s":
                        return w;
                    case "ss":
                        return d(w, 2);
                    case "f":
                        return String(x).slice(0, 1);
                    case "ff":
                        return d(String(x).slice(0, 2), 2);
                    case "fff":
                        return d(String(x).slice(0, 3), 3);
                    case "t":
                        return 12 > u ? "a" : "p";
                    case "tt":
                        return 12 > u ? "am" : "pm";
                    case "T":
                        return 12 > u ? "A" : "P";
                    case "TT":
                        return 12 > u ? "AM" : "PM";
                    case "K":
                        return p ? "UTC" : (String(i).match(g) || [""]).pop().replace(h, "");
                    case "z":
                        return (0 < y ? "-" : "+") + Math.floor(Math.abs(y) / 60);
                    case "zz":
                        return (0 < y ? "-" : "+") + d(Math.floor(Math.abs(y) / 60), 2);
                    case "zzz":
                        return (0 < y ? "-" : "+") + d(Math.floor(Math.abs(y) / 60), 2) + d(Math.abs(y) % 60, 2);
                    default:
                        return a.slice(1, a.length - 1)
                    }
                })
            }
        }()
        , $ = function (a, b, c) {
            if (null === a) return "";
            a = Number(a);
            var e = 0 > a;
            e && (a *= -1);
            var f = c ? c.decimalSeparator : "."
                , g = c ? c.digitGroupSeparator : ","
                , h = "";
            b = String(b);
            var h = 1
                , i = c = ""
                , j = -1
                , k = []
                , l = []
                , m = 0
                , n = 0
                , o = 0
                , p = !1
                , q = 0
                , i = b.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g);
            b = null;
            for (var r = 0; i && r < i.length; r++)
                if (b = i[r], "." === b && 0 > j) j = r;
                else {
                    if ("%" === b) h *= 100;
                    else {
                        if ("â€°" === b) {
                            h *= 1e3;
                            continue
                        }
                        if ("," === b[0] && "." === b[b.length - 1]) {
                            h /= Math.pow(1e3, b.length - 1), j = r + b.length - 1;
                            continue
                        }
                        "E" !== b[0] && "e" !== b[0] || "0" !== b[b.length - 1] || (p = !0)
                    }
                    0 > j ? (k.push(b), "#" === b || "0" === b ? m++ : "," === b && o++) : (l.push(b), "#" !== b && "0" !== b || n++)
                }
            for (p && (b = Math.floor(a), q = (0 === b ? "" : String(b)).length - m, h /= Math.pow(10, q)), 0 > j && (j = r), h = (a * h).toFixed(n), b = h.split("."), h = (b[0] + "").split(""), a = (b[1] + "").split(""), h && "0" === h[0] && h.shift(), r = p = i = n = j = 0; 0 < k.length;)
                if (b = k.pop(), "#" === b || "0" === b)
                    if (j++, j === m) {
                        var s = h
                            , h = [];
                        if ("0" === b)
                            for (b = m - n - (s ? s.length : 0); 0 < b;) s.unshift("0"), b--;
                        for (; 0 < s.length;) c = s.pop() + c, r++, 0 === r % p && i === o && 0 < s.length && (c = g + c);
                        e && (c = "-" + c)
                    }
                    else 0 < h.length ? (c = h.pop() + c, n++, r++) : "0" === b && (c = "0" + c, n++, r++), 0 === r % p && i === o && 0 < h.length && (c = g + c);
            else "E" !== b[0] && "e" !== b[0] || "0" !== b[b.length - 1] || !/[eE][+-]*[0]+/.test(b) ? "," === b ? (i++, p = r, r = 0, 0 < h.length && (c = g + c)) : c = 1 < b.length && ('"' === b[0] && '"' === b[b.length - 1] || "'" === b[0] && "'" === b[b.length - 1]) ? b.slice(1, b.length - 1) + c : b + c : (b = 0 > q ? b.replace("+", "").replace("-", "") : b.replace("-", ""), c += b.replace(/[0]+/, function (a) {
                return d(q, a.length)
            }));
            for (e = "", g = !1; 0 < l.length;) b = l.shift(), "#" === b || "0" === b ? 0 < a.length && 0 !== Number(a.join("")) ? (e += a.shift(), g = !0) : "0" === b && (e += "0", g = !0) : 1 < b.length && ('"' === b[0] && '"' === b[b.length - 1] || "'" === b[0] && "'" === b[b.length - 1]) ? e += b.slice(1, b.length - 1) : "E" !== b[0] && "e" !== b[0] || "0" !== b[b.length - 1] || !/[eE][+-]*[0]+/.test(b) ? e += b : (b = 0 > q ? b.replace("+", "").replace("-", "") : b.replace("-", ""), e += b.replace(/[0]+/, function (a) {
                return d(q, a.length)
            }));
            return c + ((g ? f : "") + e)
        }
        , _ = function (a) {
            var b = 0
                , c = 0;
            return a = a || window.event, a.offsetX || 0 === a.offsetX ? (b = a.offsetX, c = a.offsetY) : a.layerX || 0 == a.layerX ? (b = a.layerX, c = a.layerY) : (b = a.pageX - a.target.offsetLeft, c = a.pageY - a.target.offsetTop), {
                x: b
                , y: c
            }
        }
        , aa = !0
        , ba = window.devicePixelRatio || 1
        , ca = 1
        , da = aa ? ba / ca : 1
        , ea = window && window.location && window.location.href && window.location.href.indexOf && -1 !== window.location.href.indexOf("canvasjs.com")
        , fa = {
            reset: {
                image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAcCAYAAAAAwr0iAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAKRSURBVEiJrdY/iF1FFMfxzwnZrGISUSR/JLGIhoh/QiRNBLWxMLIWEkwbgiAoFgoW2mhlY6dgpY2IlRBRxBSKhSAKIklWJRYuMZKAhiyopAiaTY7FvRtmZ+/ed9/zHRjezLw5v/O9d86cuZGZpmURAfdn5o9DfdZNLXpjz+LziPgyIl6MiG0jPTJzZBuyDrP4BVm0P/AKbljTb4ToY/gGewYA7KyCl+1b3DUYANvwbiHw0gCAGRzBOzjTAXEOu0cC4Ch+r5x/HrpdrcZmvIDFSucMtnYCYC++6HmNDw8FKDT34ETrf639/azOr5vwRk/g5fbeuABtgC04XWk9VQLciMP4EH/3AFzErRNC7MXlQmsesSoHsGPE23hmEoBW+61K66HMXFmIMvN8myilXS36R01ub+KfYvw43ZXwYDX+AHP4BAci4pFJomfmr/ihmNofESsBImJGk7mlncrM45n5JPbhz0kAWpsv+juxaX21YIPmVJS2uNzJMS6ZNexC0d+I7fUWXLFyz2kSZlpWPvASlmqAf/FXNXf3FAF2F/1LuFifAlionB6dRuSI2IwHi6lzmXmp6xR8XY0fiIh7psAwh+3FuDkRHQVjl+a8lkXjo0kLUKH7XaV5oO86PmZ1FTzyP4K/XGl9v/zwfbW7BriiuETGCP5ch9bc9f97HF/vcFzCa5gdEPgWq+t/4v0V63oE1uF4h0DiFJ7HnSWMppDdh1dxtsPvJ2wcBNAKbsJXa0Ck5opdaBPsRNu/usba09i1KsaAVzmLt3sghrRjuK1Tf4xkegInxwy8gKf7dKMVH2QRsV5zXR/Cftyu+aKaKbbkQrsdH+PTzLzcqzkOQAVzM+7FHdiqqe2/YT4zF/t8S/sPmawyvC974vcAAAAASUVORK5CYII="
            }
            , pan: {
                image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAJVSURBVFiFvZe7a1RBGMV/x2hWI4JpfKCIiSBKOoOCkID/wP4BFqIIFkE02ChIiC8QDKlSiI3YqRBsBVGwUNAUdiIEUgjiAzQIIsuKJsfizsXr5t7d+8jmwLDfzHz3nLOzc7+ZxTZlGyDgZiWOCuJ9wH2gCUyuqQFgF/AGcKJNrYkBYBj40CIet+muGQi/96kM4WS7C/Tm5VUg7whJg8BkEGkCR4BDYfodsADUgP6wErO5iCtswsuJb32hdbXy8qzL5TIdmzJinHdZoZIBZcSFkGlAKs1Z3YCketZcBtouuaQNkrblMiBpBrhme7mAgU4wMCvpcFsDkq4C54DFVRTH9h+i6vlE0r5UA5ImgCuh28jB28iIs7BIVCOeStoZD64P4uPAjUTygKSx2FsK2TIwkugfk9Qkfd/E+yMWHQCeSRqx/R3gOp3LazfaS2C4B5gHDgD7U9x3E3uAH7KNpC3AHHAwTL4FHgM9GQ8vAaPA0dB/Abxqk2/gBLA9MXba9r1k/d4LfA3JtwueBeM58ucS+edXnAW23wP10N3advEi9CXizTnyN4bPS7Zn4sH/dq3t18AY4e1YLYSy3g/csj2VnFshZPuOpOeSKHCodUINuGj7YetE6je1PV9QoNPJ9StNHKodx7nRbiWrGHBGXAi5DUiqtQwtpcWK0Jubt8CltA5MEV1IfwO7+VffPwGfia5m34CT4bXujIIX0Qna1/cGMNqV/wUJE2czxD8CQ4X5Sl7Jz7SILwCDpbjKPBRMHAd+EtX4HWV5Spdc2w8kDQGPbH8py/MXMygM69/FKz4AAAAASUVORK5CYII="
            }
            , zoom: {
                image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK6wAACusBgosNWgAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAMqSURBVFiFvdfbj91TFMDxz57U6GUEMS1aYzyMtCSSDhWjCZMInpAI3khE/QHtgzdRkXgSCS8SES9epKLi0oRKNETjRahREq2KS1stdRujtDPtbA97n5zdn9+5zJxTK9k5v3POXmt991p7r71+IcaoGwkhTOIebMRqzOBTvIG3Y4zTXRmqSoyx5cAKbMJOHMFJnMZ8/jyFaXyMR7G6nb1aH22cP4BvcBxziG3GKfyTIR9D6BYg1KUghPBCDveFlb/24Av8iuUYw41YVsz5G7uxKcZ4aMEpwGt5NY3V/YbHsQ6rcAHOw/kYxigewr5CZw4fYGxBKcCLOFEYehXrMdRhr5yLETxVScsOLOkKAPfn1TYMPIvLFrShUlS2FDZm8XRHACzFAWl3R2xbqPMCYhmeLCAOYEMngAczbcTvuHYxzguIy/FesR9e6gSwU/OoPYHBHgHgviIKX2Flq7k34KhmcVnbi/PC8JX4MgMcxb118wZwdz5aISscqx7VRcox7MrPQ7i+btIAJrAkf9+bI9EPmZY2IAxiTSuAldLq4Y9+AcSUh78KP0tbAcwU35cXMD1JCIFUoGiehlqAz6TNB1f1C0DK+0h+nsNPrQC2a4bqGmlD9kOGcWt+Po6pVgDvSxfJaSkFd4UQBvoAsBYbCoB3a2flM7slA0R8iyt6rAFDeDPbm8eOTpVwGD9qVq7nLbIaZnmksPU1JtsCZMXNmpdRxFasWITzh6Xj3LCzra1OxcD2QjHiGVzdpfORnMqZio2PcF23ABdJF1Np4BPptlyPi6WzPYBzpJZtHe7A6xW9cnyP8TqA//SEIYRL8Bxul7rihvwgtVn78WcGGZXa9HGd5TDujDHuOePXNiHdKjWgZX/YbsxLx/ktqbjVzTlcjUSnvI5JrdlUVp6WesZZ6R1hRrpq9+EVTGS9jTjYAuKIouGpbcurEkIYxC051KNSamazsc+xK8b4S0VnEi/j0hqTP+M27O258egQwZuzs7pI7Mf4WQXIEDc5s9sux+5+1Py2EmP8UOq6GvWhIScxfdYjUERiAt9Jd84J6a16zf8JEKT3yCm8g1UxRv8CC4pyRhzR1uUAAAAASUVORK5CYII="
            }
            , menu: {
                image: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAgCAYAAAAbifjMAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAK6wAACusBgosNWgAAABx0RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNui8sowAAAAWdEVYdENyZWF0aW9uIFRpbWUAMDcvMTUvMTTPsvU0AAAAP0lEQVRIie2SMQoAIBDDUvH/X667g8sJJ9KOhYYOkW0qGaU1MPdC0vGSbV19EACo3YMPAFH5BUBUjsqfAPpVXtNgGDfxEDCtAAAAAElFTkSuQmCC"
            }
        };
    ! function () {
        Q.fSDec = function (a) {
            for (var b = "", c = 0; c < a.length; c++) b += String.fromCharCode(a[c]);
            return b
        }, Q.str = {
            tv: [84, 114, 105, 97, 108, 32, 86, 101, 114, 115, 105, 111, 110]
            , fntStr: [112, 120, 32, 67, 97, 108, 105, 98, 114, 105, 44, 32, 76, 117, 99, 105, 100, 97, 32, 71, 114, 97, 110, 100, 101, 44, 32, 76, 117, 99, 105, 100, 97, 32, 83, 97, 110, 115, 32, 85, 110, 105, 99, 111, 100, 101, 44, 32, 65, 114, 105, 97, 108, 44, 32, 115, 97, 110, 115, 45, 115, 101, 114, 105, 102]
            , tBl: [116, 101, 120, 116, 66, 97, 115, 101, 108, 105, 110, 101]
            , fnt: [102, 111, 110, 116]
            , fSy: [102, 105, 108, 108, 83, 116, 121, 108, 101]
            , fTx: [102, 105, 108, 108, 84, 101, 120, 116]
            , gr: [103, 114, 101, 121]
            , ct: [99, 116, 120]
            , tp: [116, 111, 112]
        }, delete S[Q.fSDec([67, 104, 97, 114, 116])][Q.fSDec([99, 114, 101, 100, 105, 116, 72, 114, 101, 102])], Q.pro = {
            sCH: S[Q.fSDec([67, 104, 97, 114, 116])][Q.fSDec([99, 114, 101, 100, 105, 116, 72, 114, 101, 102])]
        }, Q.fAWm = function (a) {
            if ("undefined" == typeof Q.pro.sCH && !ea) {
                var b = a[Q.fSDec(Q.str.ct)];
                b[Q.fSDec(Q.str.tBl)] = Q.fSDec(Q.str.tp), b[Q.fSDec(Q.str.fnt)] = 11 + Q.fSDec(Q.str.fntStr), b[Q.fSDec(Q.str.fSy)] = Q.fSDec(Q.str.gr), b[Q.fSDec(Q.str.fTx)](Q.fSDec(Q.str.tv), 2, a.height - 11 - 2)
            }
        }
    }(), z.prototype.setOptions = function (a, b) {
        if (S[this._defaultsKey]) {
            var d, c = S[this._defaultsKey];
            for (d in c) c.hasOwnProperty(d) && (this[d] = a && d in a ? a[d] : b && d in b ? b[d] : c[d])
        }
    }, z.prototype.updateOption = function (a) {
        var b = S[this._defaultsKey]
            , c = this._options.theme ? this._options.theme : this.chart && this.chart._options.theme ? this.chart._options.theme : "theme1"
            , d = {}
            , e = this[a];
        return c && V[c] && V[c][this._defaultsKey] && (d = V[c][this._defaultsKey]), a in b && (e = a in this._options ? this._options[a] : d && a in d ? d[a] : b[a]), e !== this[a] && (this[a] = e, !0)
    }, z.prototype.trackChanges = function (a) {
        if (!this.sessionVariables) throw "Session Variable Store not set";
        this.sessionVariables[a] = this._options[a]
    }, z.prototype.isBeingTracked = function (a) {
        return this._options._oldOptions || (this._options._oldOptions = {}), !!this._options._oldOptions[a]
    }, z.prototype.hasOptionChanged = function (a) {
        if (!this.sessionVariables) throw "Session Variable Store not set";
        return this.sessionVariables[a] !== this._options[a]
    }, z.prototype.addEventListener = function (a, b, c) {
        a && b && (this._eventListeners[a] = this._eventListeners[a] || [], this._eventListeners[a].push({
            context: c || this
            , eventHandler: b
        }))
    }, z.prototype.removeEventListener = function (a, b) {
        if (a && b && this._eventListeners[a])
            for (var c = this._eventListeners[a], d = 0; d < c.length; d++)
                if (c[d].eventHandler === b) {
                    c[d].splice(d, 1);
                    break
                }
    }, z.prototype.removeAllEventListeners = function () {
        this._eventListeners = []
    }, z.prototype.dispatchEvent = function (a, b, c) {
        if (a && this._eventListeners[a]) {
            b = b || {};
            for (var d = this._eventListeners[a], e = 0; e < d.length; e++) d[e].eventHandler.call(d[e].context, b)
        }
        "function" == typeof this[a] && this[a].call(c || this.chart._publicChartReference, b)
    }, a(A, z), A.prototype._updateOptions = function () {
        var a = this;
        if (this.updateOption("width"), this.updateOption("height"), this.updateOption("dataPointWidth"), this.updateOption("dataPointMinWidth"), this.updateOption("dataPointMaxWidth"), this.updateOption("interactivityEnabled"), this.updateOption("theme"), this.updateOption("colorSet") && (this._selectedColorSet = "undefined" != typeof U[this.colorSet] ? U[this.colorSet] : U.colorSet1), this.updateOption("backgroundColor"), this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)"), this.updateOption("culture"), this._cultureInfo = new O(this._options.culture), this.updateOption("animationEnabled"), this.animationEnabled = this.animationEnabled && R, this.updateOption("animationDuration"), this.updateOption("rangeChanging"), this.updateOption("rangeChanged"), this.updateOption("exportEnabled"), this.updateOption("exportFileName"), this.updateOption("zoomType"), this._options.zoomEnabled ? (this._zoomButton || (y(this._zoomButton = document.createElement("button")), w(this, this._zoomButton, "pan"), this._toolBar.appendChild(this._zoomButton), p(this._zoomButton, "click", function () {
                a.zoomEnabled ? (a.zoomEnabled = !1, a.panEnabled = !0, w(a, a._zoomButton, "zoom")) : (a.zoomEnabled = !0, a.panEnabled = !1, w(a, a._zoomButton, "pan")), a.render()
            })), this._resetButton || (y(this._resetButton = document.createElement("button")), w(this, this._resetButton, "reset"), this._toolBar.appendChild(this._resetButton), p(this._resetButton, "click", function () {
                a._toolTip.hide(), a.zoomEnabled || a.panEnabled ? (a.zoomEnabled = !0, a.panEnabled = !1, w(a, a._zoomButton, "pan"), a._defaultCursor = "default", a.overlaidCanvas.style.cursor = a._defaultCursor) : (a.zoomEnabled = !1, a.panEnabled = !1), a.sessionVariables.axisX && (a.sessionVariables.axisX.newViewportMinimum = null, a.sessionVariables.axisX.newViewportMaximum = null), a.sessionVariables.axisY && (a.sessionVariables.axisY.newViewportMinimum = null, a.sessionVariables.axisY.newViewportMaximum = null), a.sessionVariables.axisY2 && (a.sessionVariables.axisY2.newViewportMinimum = null, a.sessionVariables.axisY2.newViewportMaximum = null), a.resetOverlayedCanvas(), y(a._zoomButton, a._resetButton), a._dispatchRangeEvent("rangeChanging", "reset"), a.render(), a._dispatchRangeEvent("rangeChanged", "reset")
            }), this.overlaidCanvas.style.cursor = a._defaultCursor), this.zoomEnabled || this.panEnabled || (this._zoomButton ? (a._zoomButton.getAttribute("state") === a._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), x(a._zoomButton, a._resetButton)) : (this.zoomEnabled = !0, this.panEnabled = !1))) : this.panEnabled = this.zoomEnabled = !1, this._menuButton ? this.exportEnabled ? x(this._menuButton) : y(this._menuButton) : this.exportEnabled && R && (this._menuButton = document.createElement("button"), w(this, this._menuButton, "menu"), this._toolBar.appendChild(this._menuButton), p(this._menuButton, "click", function () {
                "none" !== a._dropdownMenu.style.display || a._dropDownCloseTime && 500 >= (new Date).getTime() - a._dropDownCloseTime.getTime() || (a._dropdownMenu.style.display = "block", a._menuButton.blur(), a._dropdownMenu.focus())
            }, !0)), !this._dropdownMenu && this.exportEnabled && R) {
            this._dropdownMenu = document.createElement("div"), this._dropdownMenu.setAttribute("tabindex", -1), this._dropdownMenu.style.cssText = "position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 1px;top: 25px;min-width: 120px;outline: 0;border: 1px solid silver;font-size: 14px;font-family: Calibri, Verdana, sans-serif;padding: 5px 0px 5px 0px;text-align: left;background-color: #fff;line-height: 20px;box-shadow: 2px 2px 10px #888888;", a._dropdownMenu.style.display = "none", this._toolBar.appendChild(this._dropdownMenu), p(this._dropdownMenu, "blur", function () {
                y(a._dropdownMenu), a._dropDownCloseTime = new Date
            }, !0);
            var b = document.createElement("div");
            b.style.cssText = "padding: 2px 15px 2px 10px", b.innerHTML = this._cultureInfo.saveJPGText, this._dropdownMenu.appendChild(b), p(b, "mouseover", function () {
                this.style.backgroundColor = "#EEEEEE"
            }, !0), p(b, "mouseout", function () {
                this.style.backgroundColor = "transparent"
            }, !0), p(b, "click", function () {
                v(a.canvas, "jpeg", a.exportFileName), y(a._dropdownMenu)
            }, !0), b = document.createElement("div"), b.style.cssText = "padding: 2px 15px 2px 10px", b.innerHTML = this._cultureInfo.savePNGText, this._dropdownMenu.appendChild(b), p(b, "mouseover", function () {
                this.style.backgroundColor = "#EEEEEE"
            }, !0), p(b, "mouseout", function () {
                this.style.backgroundColor = "transparent"
            }, !0), p(b, "click", function () {
                v(a.canvas, "png", a.exportFileName), y(a._dropdownMenu)
            }, !0)
        }
        "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled ? w(a, a._zoomButton, "zoom") : w(a, a._zoomButton, "pan"), a._resetButton.getAttribute("state") !== a._cultureInfo.resetText && w(a, a._resetButton, "reset")), this._options.toolTip && this._toolTip._options !== this._options.toolTip && (this._toolTip._options = this._options.toolTip);
        for (var c in this._toolTip._options) this._toolTip._options.hasOwnProperty(c) && this._toolTip.updateOption(c)
    }, A.prototype._updateSize = function () {
        var a = 0
            , b = 0;
        return this._options.width ? a = this.width : this.width = a = 0 < this._container.clientWidth ? this._container.clientWidth : this.width, this._options.height ? b = this.height : this.height = b = 0 < this._container.clientHeight ? this._container.clientHeight : this.height, (this.canvas.width !== a * da || this.canvas.height !== b * da) && (s(this.canvas, a, b), s(this.overlaidCanvas, a, b), s(this._eventManager.ghostCanvas, a, b), !0)
    }, A.prototype._initialize = function () {
        this._animator ? this._animator.cancelAllAnimations() : this._animator = new P(this), this.removeAllEventListeners(), this.disableToolTip = !1, this._axes = [], this.pieDoughnutClickHandler = null, this.animationRequestId && this.cancelRequestAnimFrame.call(window, this.animationRequestId), this._updateOptions(), this.animatedRender = R && this.animationEnabled && 0 === this.renderCount, this._updateSize(), this.clearCanvas(), this.ctx.beginPath(), this.axisY2 = this.axisY = this.axisX = null, this._indexLabels = [], this._dataInRenderedOrder = [], this._events = [], this._eventManager && this._eventManager.reset(), this.plotInfo = {
            axisPlacement: null
            , axisXValueType: null
            , plotTypes: []
        }, this.layoutManager = new D(0, 0, this.width, this.height, 2), this.plotArea.layoutManager && this.plotArea.layoutManager.reset(), this.data = [];
        var a = 0;
        if (this._options.data)
            for (var b = 0; b < this._options.data.length; b++)
                if (a++, !this._options.data[b].type || 0 <= A._supportedChartTypes.indexOf(this._options.data[b].type)) {
                    var c = new J(this, this._options.data[b], this.theme, a - 1, ++this._eventManager.lastObjectId);
                    null === c.name && (c.name = "DataSeries " + a), null === c.color ? 1 < this._options.data.length ? (c._colorSet = [this._selectedColorSet[c.index % this._selectedColorSet.length]], c.color = this._selectedColorSet[c.index % this._selectedColorSet.length]) : c._colorSet = "line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type || "candlestick" === c.type || "ohlc" === c.type ? [this._selectedColorSet[0]] : this._selectedColorSet : c._colorSet = [c.color], null === c.markerSize && (("line" === c.type || "stepLine" === c.type || "spline" === c.type || 0 <= c.type.toLowerCase().indexOf("area")) && c.dataPoints && c.dataPoints.length < this.width / 16 || "scatter" === c.type) && (c.markerSize = 8), "bubble" !== c.type && "scatter" !== c.type || !c.dataPoints || (c.dataPoints.some ? c.dataPoints.some(function (a) {
                        return a.x
                    }) && c.dataPoints.sort(h) : c.dataPoints.sort(h)), this.data.push(c);
                    var e, d = c.axisPlacement;
                    if ("normal" === d ? "xySwapped" === this.plotInfo.axisPlacement ? e = 'You cannot combine "' + c.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? e = 'You cannot combine "' + c.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === d ? "normal" === this.plotInfo.axisPlacement ? e = 'You cannot combine "' + c.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? e = 'You cannot combine "' + c.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" == d && ("normal" === this.plotInfo.axisPlacement ? e = 'You cannot combine "' + c.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? e = 'You cannot combine "' + c.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none")), e && window.console) return void window.console.log(e)
                }
        Q.fAWm && Q.fAWm(this), t(this), this._objectsInitialized = !0
    }, A._supportedChartTypes = function (a) {
        return a.indexOf || (a.indexOf = l), a
    }("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc rangeColumn rangeBar rangeArea rangeSplineArea pie doughnut funnel".split(" ")), A.prototype.render = function (a) {
        a && (this._options = a), this._initialize();
        var b = [];
        for (a = 0; a < this.data.length; a++) "normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || (this.data[a].axisYType && "primary" !== this.data[a].axisYType ? "secondary" === this.data[a].axisYType && (this.axisY2 || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2 = new K(this, this._options.axisY2, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2 = new K(this, this._options.axisY2, "axisY", "top"))), this.data[a].axisY = this.axisY2) : (this.axisY || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY = new K(this, this._options.axisY, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY = new K(this, this._options.axisY, "axisY", "bottom"))), this.data[a].axisY = this.axisY), this.axisX || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX = new K(this, this._options.axisX, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX = new K(this, this._options.axisX, "axisX", "left"))), this.data[a].axisX = this.axisX);
        this.axisY && this.axisY2 && (0 < this.axisY.gridThickness && "undefined" == typeof this.axisY2._options.gridThickness ? this.axisY2.gridThickness = 0 : 0 < this.axisY2.gridThickness && "undefined" == typeof this.axisY._options.gridThickness && (this.axisY.gridThickness = 0));
        var c = !1;
        if (0 < this._axes.length && (this.zoomEnabled || this.panEnabled))
            for (a = 0; a < this._axes.length; a++)
                if (null !== this._axes[a].viewportMinimum || null !== this._axes[a].viewportMaximum) {
                    c = !0;
                    break
                }
        if (c ? x(this._zoomButton, this._resetButton) : (y(this._zoomButton, this._resetButton), this._options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1)), this._processData(), this._options.title && (this._title = new F(this, this._options.title), this._title.dockInsidePlotArea ? b.push(this._title) : this._title.render()), this._options.subtitles)
            for (a = 0; a < this._options.subtitles.length; a++) this.subtitles = [], c = new G(this, this._options.subtitles[a]), this.subtitles.push(c), c.dockInsidePlotArea ? b.push(c) : c.render();
        for (this.legend = new H(this, this._options.legend, this.theme), a = 0; a < this.data.length; a++)(this.data[a].showInLegend || "pie" === this.data[a].type || "doughnut" === this.data[a].type) && this.legend.dataSeries.push(this.data[a]);
        if (this.legend.dockInsidePlotArea ? b.push(this.legend) : this.legend.render(), "normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) K.setLayoutAndRender(this.axisX, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace());
        else {
            if ("none" !== this.plotInfo.axisPlacement) return;
            this.preparePlotArea()
        }
        for (a = 0; a < b.length; a++) b[a].render();
        var d = [];
        if (this.animatedRender) {
            var e = u(this.width, this.height);
            e.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height)
        }
        for (a = 0; a < this.plotInfo.plotTypes.length; a++)
            for (b = this.plotInfo.plotTypes[a], c = 0; c < b.plotUnits.length; c++) {
                var f = b.plotUnits[c]
                    , g = null;
                f.targetCanvas = null, this.animatedRender && (f.targetCanvas = u(this.width, this.height), f.targetCanvasCtx = f.targetCanvas.getContext("2d")), "line" === f.type ? g = this.renderLine(f) : "stepLine" === f.type ? g = this.renderStepLine(f) : "spline" === f.type ? g = this.renderSpline(f) : "column" === f.type ? g = this.renderColumn(f) : "bar" === f.type ? g = this.renderBar(f) : "area" === f.type ? g = this.renderArea(f) : "stepArea" === f.type ? g = this.renderStepArea(f) : "splineArea" === f.type ? g = this.renderSplineArea(f) : "stackedColumn" === f.type ? g = this.renderStackedColumn(f) : "stackedColumn100" === f.type ? g = this.renderStackedColumn100(f) : "stackedBar" === f.type ? g = this.renderStackedBar(f) : "stackedBar100" === f.type ? g = this.renderStackedBar100(f) : "stackedArea" === f.type ? g = this.renderStackedArea(f) : "stackedArea100" === f.type ? g = this.renderStackedArea100(f) : "bubble" === f.type ? g = g = this.renderBubble(f) : "scatter" === f.type ? g = this.renderScatter(f) : "pie" === f.type ? this.renderPie(f) : "doughnut" === f.type ? this.renderPie(f) : "candlestick" === f.type ? g = this.renderCandlestick(f) : "ohlc" === f.type ? g = this.renderCandlestick(f) : "rangeColumn" === f.type ? g = this.renderRangeColumn(f) : "rangeBar" === f.type ? g = this.renderRangeBar(f) : "rangeArea" === f.type ? g = this.renderRangeArea(f) : "rangeSplineArea" === f.type && (g = this.renderRangeSplineArea(f));
                for (var h = 0; h < f.dataSeriesIndexes.length; h++) this._dataInRenderedOrder.push(this.data[f.dataSeriesIndexes[h]]);
                this.animatedRender && g && d.push(g)
            }
        this.animatedRender && 0 < this._indexLabels.length && (a = u(this.width, this.height).getContext("2d"), d.push(this.renderIndexLabels(a)));
        var i = this;
        0 < d.length ? (i.disableToolTip = !0, i._animator.animate(200, i.animationDuration, function (a) {
            i.ctx.clearRect(0, 0, i.width, i.height), i.ctx.drawImage(e, 0, 0, Math.floor(i.width * da), Math.floor(i.height * da), 0, 0, i.width, i.height);
            for (var b = 0; b < d.length; b++) g = d[b], 1 > a && "undefined" != typeof g.startTimePercent ? a >= g.startTimePercent && g.animationCallback(g.easingFunction(a - g.startTimePercent, 0, 1, 1 - g.startTimePercent), g) : g.animationCallback(g.easingFunction(a, 0, 1, 1), g);
            i.dispatchEvent("dataAnimationIterationEnd", {
                chart: i
            })
        }, function () {
            d = [];
            for (var a = 0; a < i.plotInfo.plotTypes.length; a++)
                for (var b = i.plotInfo.plotTypes[a], c = 0; c < b.plotUnits.length; c++) b.plotUnits[c].targetCanvas = null;
            e = null, i.disableToolTip = !1
        })) : (0 < i._indexLabels.length && i.renderIndexLabels(), i.dispatchEvent("dataAnimationIterationEnd", {
            chart: i
        })), this.attachPlotAreaEventHandlers(), this.zoomEnabled || this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display || y(this._zoomButton, this._resetButton), this._toolTip._updateToolTip(), this.renderCount++
    }, A.prototype.attachPlotAreaEventHandlers = function () {
        this.attachEvent({
            context: this
            , chart: this
            , mousedown: this._plotAreaMouseDown
            , mouseup: this._plotAreaMouseUp
            , mousemove: this._plotAreaMouseMove
            , cursor: this.zoomEnabled ? "col-resize" : "move"
            , cursor: this.panEnabled ? "move" : "default"
            , capture: !0
            , bounds: this.plotArea
        })
    }, A.prototype.categoriseDataSeries = function () {
        for (var a = "", b = 0; b < this.data.length; b++)
            if (a = this.data[b], a.dataPoints && 0 !== a.dataPoints.length && a.visible && 0 <= A._supportedChartTypes.indexOf(a.type)) {
                for (var c = null, d = !1, e = null, f = !1, g = 0; g < this.plotInfo.plotTypes.length; g++)
                    if (this.plotInfo.plotTypes[g].type === a.type) {
                        d = !0, c = this.plotInfo.plotTypes[g];
                        break
                    }
                for (d || (c = {
                        type: a.type
                        , totalDataSeries: 0
                        , plotUnits: []
                    }, this.plotInfo.plotTypes.push(c)), g = 0; g < c.plotUnits.length; g++)
                    if (c.plotUnits[g].axisYType === a.axisYType) {
                        f = !0, e = c.plotUnits[g];
                        break
                    }
                f || (e = {
                    type: a.type
                    , previousDataSeriesCount: 0
                    , index: c.plotUnits.length
                    , plotType: c
                    , axisYType: a.axisYType
                    , axisY: "primary" === a.axisYType ? this.axisY : this.axisY2
                    , axisX: this.axisX
                    , dataSeriesIndexes: []
                    , yTotals: []
                }, c.plotUnits.push(e)), c.totalDataSeries++, e.dataSeriesIndexes.push(b), a.plotUnit = e
            }
        for (b = 0; b < this.plotInfo.plotTypes.length; b++)
            for (c = this.plotInfo.plotTypes[b], g = a = 0; g < c.plotUnits.length; g++) c.plotUnits[g].previousDataSeriesCount = a, a += c.plotUnits[g].dataSeriesIndexes.length
    }, A.prototype.assignIdToDataPoints = function () {
        for (var a = 0; a < this.data.length; a++) {
            var b = this.data[a];
            if (b.dataPoints)
                for (var c = b.dataPoints.length, d = 0; d < c; d++) b.dataPointIds[d] = ++this._eventManager.lastObjectId
        }
    }, A.prototype._processData = function () {
        this.assignIdToDataPoints(), this.categoriseDataSeries();
        for (var a = 0; a < this.plotInfo.plotTypes.length; a++)
            for (var b = this.plotInfo.plotTypes[a], c = 0; c < b.plotUnits.length; c++) {
                var d = b.plotUnits[c];
                "line" === d.type || "stepLine" === d.type || "spline" === d.type || "column" === d.type || "area" === d.type || "stepArea" === d.type || "splineArea" === d.type || "bar" === d.type || "bubble" === d.type || "scatter" === d.type ? this._processMultiseriesPlotUnit(d) : "stackedColumn" === d.type || "stackedBar" === d.type || "stackedArea" === d.type ? this._processStackedPlotUnit(d) : "stackedColumn100" === d.type || "stackedBar100" === d.type || "stackedArea100" === d.type ? this._processStacked100PlotUnit(d) : "candlestick" !== d.type && "ohlc" !== d.type && "rangeColumn" !== d.type && "rangeBar" !== d.type && "rangeArea" !== d.type && "rangeSplineArea" !== d.type || this._processMultiYPlotUnit(d)
            }
    }, A.prototype._processMultiseriesPlotUnit = function (a) {
        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))
            for (var d, e, b = a.axisY.dataInfo, c = a.axisX.dataInfo, f = !1, g = 0; g < a.dataSeriesIndexes.length; g++) {
                var l, h = this.data[a.dataSeriesIndexes[g]]
                    , i = 0
                    , j = !1
                    , k = !1;
                if ("normal" === h.axisPlacement || "xySwapped" === h.axisPlacement) var m = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : a.axisX.logarithmic ? 0 : -(1 / 0)
                    , n = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : 1 / 0;
                for ((h.dataPoints[i].x && h.dataPoints[i].x.getTime || "dateTime" === h.xValueType) && (f = !0), i = 0; i < h.dataPoints.length; i++) {
                    if ("undefined" == typeof h.dataPoints[i].x && (h.dataPoints[i].x = i + (a.axisX.logarithmic ? 1 : 0)), h.dataPoints[i].x.getTime ? (f = !0, d = h.dataPoints[i].x.getTime()) : d = h.dataPoints[i].x, e = h.dataPoints[i].y, d < c.min && (c.min = d), d > c.max && (c.max = d), e < b.min && (b.min = e), e > b.max && (b.max = e), 0 < i) {
                        if (a.axisX.logarithmic) {
                            var o = d / h.dataPoints[i - 1].x;
                            1 > o && (o = 1 / o), c.minDiff > o && 1 !== o && (c.minDiff = o)
                        }
                        else o = d - h.dataPoints[i - 1].x, 0 > o && (o *= -1), c.minDiff > o && 0 !== o && (c.minDiff = o);
                        null !== e && null !== h.dataPoints[i - 1].y && (a.axisY.logarithmic ? (o = e / h.dataPoints[i - 1].y, 1 > o && (o = 1 / o), b.minDiff > o && 1 !== o && (b.minDiff = o)) : (o = e - h.dataPoints[i - 1].y, 0 > o && (o *= -1), b.minDiff > o && 0 !== o && (b.minDiff = o)))
                    }
                    if (d < m && !j) null !== e && (l = d);
                    else {
                        if (!j && (j = !0, 0 < i)) {
                            i -= 2;
                            continue
                        }
                        if (d > n && !k) k = !0;
                        else if (d > n && k) continue;
                        h.dataPoints[i].label && (a.axisX.labels[d] = h.dataPoints[i].label), d < c.viewPortMin && (c.viewPortMin = d), d > c.viewPortMax && (c.viewPortMax = d), null === e ? c.viewPortMin === d && l < d && (c.viewPortMin = l) : (e < b.viewPortMin && (b.viewPortMin = e), e > b.viewPortMax && (b.viewPortMax = e))
                    }
                }
                this.plotInfo.axisXValueType = h.xValueType = f ? "dateTime" : "number"
            }
    }, A.prototype._processStackedPlotUnit = function (a) {
        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
            for (var d, e, b = a.axisY.dataInfo, c = a.axisX.dataInfo, f = !1, g = [], h = [], i = 1 / 0, j = 0; j < a.dataSeriesIndexes.length; j++) {
                var p, k = this.data[a.dataSeriesIndexes[j]]
                    , l = 0
                    , n = !1
                    , o = !1;
                if ("normal" === k.axisPlacement || "xySwapped" === k.axisPlacement) var q = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : -(1 / 0)
                    , r = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : 1 / 0;
                for ((k.dataPoints[l].x && k.dataPoints[l].x.getTime || "dateTime" === k.xValueType) && (f = !0), l = 0; l < k.dataPoints.length; l++) {
                    if ("undefined" == typeof k.dataPoints[l].x && (k.dataPoints[l].x = l + (a.axisX.logarithmic ? 1 : 0)), k.dataPoints[l].x.getTime ? (f = !0, d = k.dataPoints[l].x.getTime()) : d = k.dataPoints[l].x, m(k.dataPoints[l].y) ? e = 0 : (e = k.dataPoints[l].y, 0 === j && (i = Math.min(e, i))), d < c.min && (c.min = d), d > c.max && (c.max = d), 0 < l) {
                        if (a.axisX.logarithmic) {
                            var s = d / k.dataPoints[l - 1].x;
                            1 > s && (s = 1 / s), c.minDiff > s && 1 !== s && (c.minDiff = s)
                        }
                        else s = d - k.dataPoints[l - 1].x, 0 > s && (s *= -1), c.minDiff > s && 0 !== s && (c.minDiff = s);
                        null !== e && null !== k.dataPoints[l - 1].y && (a.axisY.logarithmic ? 0 < e && (s = e / k.dataPoints[l - 1].y, 1 > s && (s = 1 / s), b.minDiff > s && 1 !== s && (b.minDiff = s)) : (s = e - k.dataPoints[l - 1].y, 0 > s && (s *= -1), b.minDiff > s && 0 !== s && (b.minDiff = s)))
                    }
                    if (d < q && !n) null !== k.dataPoints[l].y && (p = d);
                    else {
                        if (!n && (n = !0, 0 < l)) {
                            l -= 2;
                            continue
                        }
                        if (d > r && !o) o = !0;
                        else if (d > r && o) continue;
                        k.dataPoints[l].label && (a.axisX.labels[d] = k.dataPoints[l].label), d < c.viewPortMin && (c.viewPortMin = d), d > c.viewPortMax && (c.viewPortMax = d), null === k.dataPoints[l].y ? c.viewPortMin === d && p < d && (c.viewPortMin = p) : (a.yTotals[d] = (a.yTotals[d] ? a.yTotals[d] : 0) + Math.abs(e), 0 <= e ? g[d] = g[d] ? g[d] + e : e : h[d] = h[d] ? h[d] + e : e)
                    }
                }
                this.plotInfo.axisXValueType = k.xValueType = f ? "dateTime" : "number"
            }
            for (l in g) g.hasOwnProperty(l) && !isNaN(l) && (a = g[l], a < b.min && (b.min = Math.min(a, i)), a > b.max && (b.max = a), l < c.viewPortMin || l > c.viewPortMax || (a < b.viewPortMin && (b.viewPortMin = Math.min(a, i)), a > b.viewPortMax && (b.viewPortMax = a)));
            for (l in h) h.hasOwnProperty(l) && !isNaN(l) && (a = h[l], a < b.min && (b.min = Math.min(a, i)), a > b.max && (b.max = a), l < c.viewPortMin || l > c.viewPortMax || (a < b.viewPortMin && (b.viewPortMin = Math.min(a, i)), a > b.viewPortMax && (b.viewPortMax = a)))
        }
    }, A.prototype._processStacked100PlotUnit = function (a) {
        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length)) {
            for (var d, e, b = a.axisY.dataInfo, c = a.axisX.dataInfo, f = !1, g = !1, h = !1, i = [], j = 0; j < a.dataSeriesIndexes.length; j++) {
                var p, k = this.data[a.dataSeriesIndexes[j]]
                    , l = 0
                    , n = !1
                    , o = !1;
                if ("normal" === k.axisPlacement || "xySwapped" === k.axisPlacement) var q = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : -(1 / 0)
                    , r = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : 1 / 0;
                for ((k.dataPoints[l].x && k.dataPoints[l].x.getTime || "dateTime" === k.xValueType) && (f = !0), l = 0; l < k.dataPoints.length; l++) {
                    if ("undefined" == typeof k.dataPoints[l].x && (k.dataPoints[l].x = l + (a.axisX.logarithmic ? 1 : 0)), k.dataPoints[l].x.getTime ? (f = !0, d = k.dataPoints[l].x.getTime()) : d = k.dataPoints[l].x, e = m(k.dataPoints[l].y) ? null : k.dataPoints[l].y, d < c.min && (c.min = d), d > c.max && (c.max = d), 0 < l) {
                        if (a.axisX.logarithmic) {
                            var s = d / k.dataPoints[l - 1].x;
                            1 > s && (s = 1 / s), c.minDiff > s && 1 !== s && (c.minDiff = s)
                        }
                        else s = d - k.dataPoints[l - 1].x, 0 > s && (s *= -1), c.minDiff > s && 0 !== s && (c.minDiff = s);
                        m(e) || null === k.dataPoints[l - 1].y || (a.axisY.logarithmic ? 0 < e && (s = e / k.dataPoints[l - 1].y, 1 > s && (s = 1 / s), b.minDiff > s && 1 !== s && (b.minDiff = s)) : (s = e - k.dataPoints[l - 1].y, 0 > s && (s *= -1), b.minDiff > s && 0 !== s && (b.minDiff = s)))
                    }
                    if (d < q && !n) null !== e && (p = d);
                    else {
                        if (!n && (n = !0, 0 < l)) {
                            l -= 2;
                            continue
                        }
                        if (d > r && !o) o = !0;
                        else if (d > r && o) continue;
                        k.dataPoints[l].label && (a.axisX.labels[d] = k.dataPoints[l].label), d < c.viewPortMin && (c.viewPortMin = d), d > c.viewPortMax && (c.viewPortMax = d), null === e ? c.viewPortMin === d && p < d && (c.viewPortMin = p) : (a.yTotals[d] = (a.yTotals[d] ? a.yTotals[d] : 0) + Math.abs(e), 0 <= e ? g = !0 : 0 > e && (h = !0), i[d] = i[d] ? i[d] + Math.abs(e) : Math.abs(e))
                    }
                }
                this.plotInfo.axisXValueType = k.xValueType = f ? "dateTime" : "number"
            }
            a.axisY.logarithmic ? (b.max = m(b.viewPortMax) ? 99 * Math.pow(a.axisY.logarithmBase, -.05) : Math.max(b.viewPortMax, 99 * Math.pow(a.axisY.logarithmBase, -.05)), b.min = m(b.viewPortMin) ? 1 : Math.min(b.viewPortMin, 1)) : g && !h ? (b.max = m(b.viewPortMax) ? 99 : Math.max(b.viewPortMax, 99), b.min = m(b.viewPortMin) ? 1 : Math.min(b.viewPortMin, 1)) : g && h ? (b.max = m(b.viewPortMax) ? 99 : Math.max(b.viewPortMax, 99), b.min = m(b.viewPortMin) ? -99 : Math.min(b.viewPortMin, -99)) : !g && h && (b.max = m(b.viewPortMax) ? -1 : Math.max(b.viewPortMax, -1), b.min = m(b.viewPortMin) ? -99 : Math.min(b.viewPortMin, -99)), b.viewPortMin = b.min, b.viewPortMax = b.max, a.dataPointYSums = i
        }
    }, A.prototype._processMultiYPlotUnit = function (a) {
        if (a.dataSeriesIndexes && !(1 > a.dataSeriesIndexes.length))
            for (var d, e, f, g, b = a.axisY.dataInfo, c = a.axisX.dataInfo, h = !1, i = 0; i < a.dataSeriesIndexes.length; i++) {
                var n, o, p, j = this.data[a.dataSeriesIndexes[i]]
                    , k = 0
                    , l = !1
                    , m = !1;
                if ("normal" === j.axisPlacement || "xySwapped" === j.axisPlacement) var q = this.sessionVariables.axisX.newViewportMinimum ? this.sessionVariables.axisX.newViewportMinimum : this._options.axisX && this._options.axisX.viewportMinimum ? this._options.axisX.viewportMinimum : this._options.axisX && this._options.axisX.minimum ? this._options.axisX.minimum : -(1 / 0)
                    , r = this.sessionVariables.axisX.newViewportMaximum ? this.sessionVariables.axisX.newViewportMaximum : this._options.axisX && this._options.axisX.viewportMaximum ? this._options.axisX.viewportMaximum : this._options.axisX && this._options.axisX.maximum ? this._options.axisX.maximum : 1 / 0;
                for ((j.dataPoints[k].x && j.dataPoints[k].x.getTime || "dateTime" === j.xValueType) && (h = !0), k = 0; k < j.dataPoints.length; k++) {
                    if ("undefined" == typeof j.dataPoints[k].x && (j.dataPoints[k].x = k + (a.axisX.logarithmic ? 1 : 0)), j.dataPoints[k].x.getTime ? (h = !0, d = j.dataPoints[k].x.getTime()) : d = j.dataPoints[k].x, (e = j.dataPoints[k].y) && e.length) {
                        f = Math.min.apply(null, e), g = Math.max.apply(null, e), o = !0;
                        for (var s = 0; s < e.length; s++) null === e.k && (o = !1);
                        o && (l || (p = n), n = d)
                    }
                    if (d < c.min && (c.min = d), d > c.max && (c.max = d), f < b.min && (b.min = f), g > b.max && (b.max = g), 0 < k && (a.axisX.logarithmic ? (o = d / j.dataPoints[k - 1].x, 1 > o && (o = 1 / o), c.minDiff > o && 1 !== o && (c.minDiff = o)) : (o = d - j.dataPoints[k - 1].x, 0 > o && (o *= -1), c.minDiff > o && 0 !== o && (c.minDiff = o)), e && null !== e[0] && j.dataPoints[k - 1].y && null !== j.dataPoints[k - 1].y[0] && (a.axisY.logarithmic ? (o = e[0] / j.dataPoints[k - 1].y[0], 1 > o && (o = 1 / o), b.minDiff > o && 1 !== o && (b.minDiff = o)) : (o = e[0] - j.dataPoints[k - 1].y[0], 0 > o && (o *= -1), b.minDiff > o && 0 !== o && (b.minDiff = o)))), !(d < q) || l) {
                        if (!l && (l = !0, 0 < k)) {
                            k -= 2, n = p;
                            continue
                        }
                        if (d > r && !m) m = !0;
                        else if (d > r && m) continue;
                        if (j.dataPoints[k].label && (a.axisX.labels[d] = j.dataPoints[k].label), d < c.viewPortMin && (c.viewPortMin = d), d > c.viewPortMax && (c.viewPortMax = d), c.viewPortMin === d && e)
                            for (s = 0; s < e.length; s++)
                                if (null === e[s] && n < d) {
                                    c.viewPortMin = n;
                                    break
                                }
                        null === e ? c.viewPortMin === d && n < d && (c.viewPortMin = n) : (f < b.viewPortMin && (b.viewPortMin = f), g > b.viewPortMax && (b.viewPortMax = g))
                    }
                }
                this.plotInfo.axisXValueType = j.xValueType = h ? "dateTime" : "number"
            }
    }, A.prototype.getDataPointAtXY = function (a, b, c) {
        c = c || !1;
        for (var d = [], e = this._dataInRenderedOrder.length - 1; 0 <= e; e--) {
            var f = null;
            (f = this._dataInRenderedOrder[e].getDataPointAtXY(a, b, c)) && d.push(f)
        }
        for (a = null, b = !1, c = 0; c < d.length; c++)
            if (("line" === d[c].dataSeries.type || "stepLine" === d[c].dataSeries.type || "area" === d[c].dataSeries.type || "stepArea" === d[c].dataSeries.type) && (e = r("markerSize", d[c].dataPoint, d[c].dataSeries) || 8, d[c].distance <= e / 2)) {
                b = !0;
                break
            }
        for (c = 0; c < d.length; c++) b && "line" !== d[c].dataSeries.type && "stepLine" !== d[c].dataSeries.type && "area" !== d[c].dataSeries.type && "stepArea" !== d[c].dataSeries.type || (a ? d[c].distance <= a.distance && (a = d[c]) : a = d[c]);
        return a
    }, A.prototype.getObjectAtXY = function (a, b, c) {
        var d = null;
        if (c = this.getDataPointAtXY(a, b, c || !1)) d = c.dataSeries.dataPointIds[c.dataPointIndex];
        else if (R) d = q(a, b, this._eventManager.ghostCtx);
        else
            for (c = 0; c < this.legend.items.length; c++) {
                var e = this.legend.items[c];
                a >= e.x1 && a <= e.x2 && b >= e.y1 && b <= e.y2 && (d = e.id)
            }
        return d
    }, A.prototype.getAutoFontSize = function (a, b, c) {
        return a /= 400, Math.max(10, Math.round(Math.min(this.width, this.height) * a))
    }, A.prototype.resetOverlayedCanvas = function () {
        this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height)
    }, A.prototype.clearCanvas = function () {
        this.ctx.clearRect(0, 0, this.width, this.height), this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height))
    }, A.prototype.attachEvent = function (a) {
        this._events.push(a)
    }, A.prototype._touchEventHandler = function (a) {
        if (a.changedTouches && this.interactivityEnabled) {
            var b = []
                , c = a.changedTouches
                , d = c ? c[0] : a
                , e = null;
            switch (a.type) {
            case "touchstart":
            case "MSPointerDown":
                b = ["mousemove", "mousedown"], this._lastTouchData = _(d), this._lastTouchData.time = new Date;
                break;
            case "touchmove":
            case "MSPointerMove":
                b = ["mousemove"];
                break;
            case "touchend":
            case "MSPointerUp":
                b = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType ? ["mouseup", "click"] : ["mouseup"];
                break;
            default:
                return
            }
            if (!(c && 1 < c.length)) {
                e = _(d), e.time = new Date;
                try {
                    var f = e.y - this._lastTouchData.y
                        , g = e.time - this._lastTouchData.time;
                    if (15 < Math.abs(f) && (this._lastTouchData.scroll || 200 > g)) {
                        this._lastTouchData.scroll = !0;
                        var h = window.parent || window;
                        h && h.scrollBy && h.scrollBy(0, -f)
                    }
                }
                catch (a) {}
                if (this._lastTouchEventType = a.type, this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = !1;
                else
                    for (c = 0; c < b.length; c++) e = b[c], f = document.createEvent("MouseEvent"), f.initMouseEvent(e, !0, !0, window, 1, d.screenX, d.screenY, d.clientX, d.clientY, !1, !1, !1, !1, 0, null), d.target.dispatchEvent(f), a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault()
            }
        }
    }, A.prototype._dispatchRangeEvent = function (a, b) {
        var c = {};
        c.chart = this._publicChartReference, c.type = a, c.trigger = b;
        var d = [];
        this.axisX && d.push("axisX"), this.axisY && d.push("axisY"), this.axisY2 && d.push("axisY2");
        for (var e = 0; e < d.length; e++) c[d[e]] = {
            viewportMinimum: this[d[e]].sessionVariables.newViewportMinimum
            , viewportMaximum: this[d[e]].sessionVariables.newViewportMaximum
        };
        this.dispatchEvent(a, c, this._publicChartReference)
    }, A.prototype._mouseEventHandler = function (a) {
        "undefined" == typeof a.target && a.srcElement && (a.target = a.srcElement);
        var d, e, b = _(a)
            , c = a.type;
        if (a.which ? e = 3 == a.which : a.button && (e = 2 == a.button), A.capturedEventParam && (d = A.capturedEventParam, "mouseup" === c && (A.capturedEventParam = null, d.chart.overlaidCanvas.releaseCapture ? d.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", d.chart._mouseEventHandler, !1)), d.hasOwnProperty(c) && ("mouseup" !== c || d.chart.overlaidCanvas.releaseCapture ? a.target === d.chart.overlaidCanvas && d[c].call(d.context, b.x, b.y) : a.target !== d.chart.overlaidCanvas && (d.chart.isDrag = !1))), this.interactivityEnabled)
            if (this._ignoreNextEvent) this._ignoreNextEvent = !1;
            else if (a.preventManipulation && a.preventManipulation(), a.preventDefault && a.preventDefault(), !e) {
            if (!A.capturedEventParam && this._events) {
                for (var f = 0; f < this._events.length; f++)
                    if (this._events[f].hasOwnProperty(c)) {
                        if (d = this._events[f], e = d.bounds, b.x >= e.x1 && b.x <= e.x2 && b.y >= e.y1 && b.y <= e.y2) {
                            d[c].call(d.context, b.x, b.y), "mousedown" === c && !0 === d.capture ? (A.capturedEventParam = d, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, !1)) : "mouseup" === c && (d.chart.overlaidCanvas.releaseCapture ? d.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, !1));
                            break
                        }
                        d = null
                    }
                a.target.style.cursor = d && d.cursor ? d.cursor : this._defaultCursor
            }
            c = this.plotArea, (b.x < c.x1 || b.x > c.x2 || b.y < c.y1 || b.y > c.y2) && (this._toolTip && this._toolTip.enabled ? this._toolTip.hide() : this.resetOverlayedCanvas()), this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(a)
        }
    }, A.prototype._plotAreaMouseDown = function (a, b) {
        this.isDrag = !0, this.dragStartPoint = {
            x: a
            , y: b
        }
    }, A.prototype._plotAreaMouseUp = function (a, b) {
        if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) {
            var c = b - this.dragStartPoint.y
                , d = a - this.dragStartPoint.x
                , e = 0 <= this.zoomType.indexOf("x")
                , f = 0 <= this.zoomType.indexOf("y")
                , g = !1;
            if (this.resetOverlayedCanvas(), "xySwapped" === this.plotInfo.axisPlacement) var h = f
                , f = e
                , e = h;
            if (this.panEnabled || this.zoomEnabled) {
                if (this.panEnabled)
                    for (e = f = 0; e < this._axes.length; e++) c = this._axes[e], c.logarithmic ? c.viewportMinimum < c.minimum ? (f = c.minimum / c.viewportMinimum, c.sessionVariables.newViewportMinimum = c.viewportMinimum * f, c.sessionVariables.newViewportMaximum = c.viewportMaximum * f, g = !0) : c.viewportMaximum > c.maximum && (f = c.viewportMaximum / c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum / f, c.sessionVariables.newViewportMaximum = c.viewportMaximum / f, g = !0) : c.viewportMinimum < c.minimum ? (f = c.minimum - c.viewportMinimum, c.sessionVariables.newViewportMinimum = c.viewportMinimum + f, c.sessionVariables.newViewportMaximum = c.viewportMaximum + f, g = !0) : c.viewportMaximum > c.maximum && (f = c.viewportMaximum - c.maximum, c.sessionVariables.newViewportMinimum = c.viewportMinimum - f, c.sessionVariables.newViewportMaximum = c.viewportMaximum - f, g = !0);
                else if ((!e || 2 < Math.abs(d)) && (!f || 2 < Math.abs(c)) && this.zoomEnabled) {
                    if (!this.dragStartPoint) return;
                    c = e ? this.dragStartPoint.x : this.plotArea.x1, d = f ? this.dragStartPoint.y : this.plotArea.y1, e = e ? a : this.plotArea.x2, f = f ? b : this.plotArea.y2, 2 < Math.abs(c - e) && 2 < Math.abs(d - f) && this._zoomPanToSelectedRegion(c, d, e, f) && (g = !0)
                }
                g && (this._ignoreNextEvent = !0, this._dispatchRangeEvent("rangeChanging", "zoom"), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), g && this.zoomEnabled && "none" === this._zoomButton.style.display && (x(this._zoomButton, this._resetButton), w(this, this._zoomButton, "pan"), w(this, this._resetButton, "reset")))
            }
        }
        this.isDrag = !1
    }, A.prototype._plotAreaMouseMove = function (a, b) {
        if (this.isDrag && "none" !== this.plotInfo.axisPlacement) {
            var c = 0
                , d = 0
                , e = c = null
                , e = 0 <= this.zoomType.indexOf("x")
                , f = 0 <= this.zoomType.indexOf("y")
                , g = this;
            if ("xySwapped" === this.plotInfo.axisPlacement && (c = f, f = e, e = c), c = this.dragStartPoint.x - a, d = this.dragStartPoint.y - b, 2 < Math.abs(c) && 8 > Math.abs(c) && (this.panEnabled || this.zoomEnabled) ? this._toolTip.hide() : this.panEnabled || this.zoomEnabled || this._toolTip.mouseMoveHandler(a, b), (!e || 2 < Math.abs(c) || !f || 2 < Math.abs(d)) && (this.panEnabled || this.zoomEnabled))
                if (this.panEnabled) e = {
                    x1: e ? this.plotArea.x1 + c : this.plotArea.x1
                    , y1: f ? this.plotArea.y1 + d : this.plotArea.y1
                    , x2: e ? this.plotArea.x2 + c : this.plotArea.x2
                    , y2: f ? this.plotArea.y2 + d : this.plotArea.y2
                }, clearTimeout(g._panTimerId), g._panTimerId = setTimeout(function (c, d, e, f) {
                    return function () {
                        g._zoomPanToSelectedRegion(c, d, e, f, !0) && (g._dispatchRangeEvent("rangeChanging", "pan"), g.render(), g._dispatchRangeEvent("rangeChanged", "pan"), g.dragStartPoint.x = a, g.dragStartPoint.y = b)
                    }
                }(e.x1, e.y1, e.x2, e.y2), 0);
                else if (this.zoomEnabled) {
                this.resetOverlayedCanvas(), c = this.overlaidCanvasCtx.globalAlpha, this.overlaidCanvasCtx.fillStyle = "#A89896";
                var d = e ? this.dragStartPoint.x : this.plotArea.x1
                    , h = f ? this.dragStartPoint.y : this.plotArea.y1
                    , i = e ? a - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1
                    , j = f ? b - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;
                this.validateRegion(d, h, e ? a : this.plotArea.x2 - this.plotArea.x1, f ? b : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5"), this.overlaidCanvasCtx.globalAlpha = .7, this.overlaidCanvasCtx.fillRect(d, h, i, j), this.overlaidCanvasCtx.globalAlpha = c
            }
        }
        else this._toolTip.mouseMoveHandler(a, b)
    }, A.prototype._zoomPanToSelectedRegion = function (a, b, c, d, e) {
        if (a = this.validateRegion(a, b, c, d, e), b = a.axesWithValidRange, c = a.axesRanges, a.isValid)
            for (d = 0; d < b.length; d++) e = c[d], b[d].setViewPortRange(e.val1, e.val2);
        return a.isValid
    }, A.prototype.validateRegion = function (a, b, c, d, e) {
        e = e || !1;
        var f = 0 <= this.zoomType.indexOf("x")
            , g = 0 <= this.zoomType.indexOf("y")
            , h = !1
            , i = []
            , j = []
            , k = [];
        for (this.axisX && f && j.push(this.axisX), this.axisY && g && j.push(this.axisY), this.axisY2 && g && j.push(this.axisY2), f = 0; f < j.length; f++) {
            var g = j[f]
                , l = g.convertPixelToValue({
                    x: a
                    , y: b
                })
                , m = g.convertPixelToValue({
                    x: c
                    , y: d
                });
            if (l > m) var n = m
                , m = l
                , l = n;
            if (isFinite(g.dataInfo.minDiff))
                if (g.logarithmic && m / l < Math.pow(g.dataInfo.minDiff, 3) || !g.logarithmic && Math.abs(m - l) < 3 * Math.abs(g.dataInfo.minDiff) || l < g.minimum || m > g.maximum) {
                    if (!e) {
                        h = !1;
                        break
                    }
                }
                else i.push(g), k.push({
                    val1: l
                    , val2: m
                }), h = !0
        }
        return {
            isValid: h
            , axesWithValidRange: i
            , axesRanges: k
        }
    }, A.prototype.preparePlotArea = function () {
        var a = this.plotArea
            , b = this.axisY ? this.axisY : this.axisY2;
        !R && (0 < a.x1 || 0 < a.y1) && a.ctx.translate(a.x1, a.y1), this.axisX && b ? (a.x1 = this.axisX.lineCoordinates.x1 < this.axisX.lineCoordinates.x2 ? this.axisX.lineCoordinates.x1 : b.lineCoordinates.x1, a.y1 = this.axisX.lineCoordinates.y1 < b.lineCoordinates.y1 ? this.axisX.lineCoordinates.y1 : b.lineCoordinates.y1, a.x2 = this.axisX.lineCoordinates.x2 > b.lineCoordinates.x2 ? this.axisX.lineCoordinates.x2 : b.lineCoordinates.x2, a.y2 = this.axisX.lineCoordinates.y2 > this.axisX.lineCoordinates.y1 ? this.axisX.lineCoordinates.y2 : b.lineCoordinates.y2, a.width = a.x2 - a.x1, a.height = a.y2 - a.y1) : (b = this.layoutManager.getFreeSpace(), a.x1 = b.x1, a.x2 = b.x2, a.y1 = b.y1, a.y2 = b.y2, a.width = b.width, a.height = b.height), R || (a.canvas.width = a.width, a.canvas.height = a.height, a.canvas.style.left = a.x1 + "px", a.canvas.style.top = a.y1 + "px", (0 < a.x1 || 0 < a.y1) && a.ctx.translate(-a.x1, -a.y1)), a.layoutManager = new D(a.x1, a.y1, a.x2, a.y2, 2)
    }, A.prototype.getPixelCoordinatesOnPlotArea = function (a, b) {
        return {
            x: this.axisX.getPixelCoordinatesOnAxis(a).x
            , y: this.axisY.getPixelCoordinatesOnAxis(b).y
        }
    }, A.prototype.renderIndexLabels = function (a) {
        a = a || this.plotArea.ctx;
        for (var b = this.plotArea, c = 0, d = 0, e = 0, f = 0, g = c = f = d = e = 0, h = 0, i = 0; i < this._indexLabels.length; i++) {
            var l, n, j = this._indexLabels[i]
                , k = j.chartType.toLowerCase()
                , p = r("indexLabelFontColor", j.dataPoint, j.dataSeries)
                , g = r("indexLabelFontSize", j.dataPoint, j.dataSeries)
                , h = r("indexLabelFontFamily", j.dataPoint, j.dataSeries);
            l = r("indexLabelFontStyle", j.dataPoint, j.dataSeries), n = r("indexLabelFontWeight", j.dataPoint, j.dataSeries);
            var f = r("indexLabelBackgroundColor", j.dataPoint, j.dataSeries)
                , d = r("indexLabelMaxWidth", j.dataPoint, j.dataSeries)
                , e = r("indexLabelWrap", j.dataPoint, j.dataSeries)
                , q = r("indexLabelLineDashType", j.dataPoint, j.dataSeries)
                , s = r("indexLabelLineColor", j.dataPoint, j.dataSeries)
                , t = m(j.dataPoint.indexLabelLineThickness) ? m(j.dataSeries._options.indexLabelLineThickness) ? 0 : j.dataSeries._options.indexLabelLineThickness : j.dataPoint.indexLabelLineThickness
                , c = 0 < t ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0
                , u = {
                    percent: null
                    , total: null
                }
                , v = null;
            (0 <= j.dataSeries.type.indexOf("stacked") || "pie" === j.dataSeries.type || "doughnut" === j.dataSeries.type) && (u = this.getPercentAndTotal(j.dataSeries, j.dataPoint)), (j.dataSeries.indexLabelFormatter || j.dataPoint.indexLabelFormatter) && (v = {
                chart: this._publicChartReference
                , dataSeries: j.dataSeries
                , dataPoint: j.dataPoint
                , index: j.indexKeyword
                , total: u.total
                , percent: u.percent
            });
            var w = j.dataPoint.indexLabelFormatter ? j.dataPoint.indexLabelFormatter(v) : j.dataPoint.indexLabel ? this.replaceKeywordsWithValue(j.dataPoint.indexLabel, j.dataPoint, j.dataSeries, null, j.indexKeyword) : j.dataSeries.indexLabelFormatter ? j.dataSeries.indexLabelFormatter(v) : j.dataSeries.indexLabel ? this.replaceKeywordsWithValue(j.dataSeries.indexLabel, j.dataPoint, j.dataSeries, null, j.indexKeyword) : null;
            if (null !== w && "" !== w) {
                var u = r("indexLabelPlacement", j.dataPoint, j.dataSeries)
                    , v = r("indexLabelOrientation", j.dataPoint, j.dataSeries)
                    , x = j.direction
                    , y = j.dataSeries.axisX
                    , z = j.dataSeries.axisY
                    , A = !1
                    , p = new E(a, {
                        x: 0
                        , y: 0
                        , maxWidth: d ? d : .5 * this.width
                        , maxHeight: e ? 5 * g : 1.5 * g
                        , angle: "horizontal" === v ? 0 : -90
                        , text: w
                        , padding: 0
                        , backgroundColor: f
                        , horizontalAlign: "left"
                        , fontSize: g
                        , fontFamily: h
                        , fontWeight: n
                        , fontColor: p
                        , fontStyle: l
                        , textBaseline: "top"
                    });
                if (p.measureText(), 0 <= k.indexOf("line") || 0 <= k.indexOf("area") || 0 <= k.indexOf("bubble") || 0 <= k.indexOf("scatter")) {
                    if (j.dataPoint.x < y.viewportMinimum || j.dataPoint.x > y.viewportMaximum || j.dataPoint.y < z.viewportMinimum || j.dataPoint.y > z.viewportMaximum) continue
                }
                else if (0 <= k.indexOf("column")) {
                    if (j.dataPoint.x < y.viewportMinimum || j.dataPoint.x > y.viewportMaximum || j.bounds.y1 > b.y2 || j.bounds.y2 < b.y1) continue
                }
                else if (0 <= k.indexOf("bar")) {
                    if (j.dataPoint.x < y.viewportMinimum || j.dataPoint.x > y.viewportMaximum || j.bounds.x1 > b.x2 || j.bounds.x2 < b.x1) continue
                }
                else if (j.dataPoint.x < y.viewportMinimum || j.dataPoint.x > y.viewportMaximum) continue;
                d = f = 2, "horizontal" === v ? (g = p.width, h = p.height) : (h = p.width, g = p.height), "normal" === this.plotInfo.axisPlacement ? (0 <= k.indexOf("line") || 0 <= k.indexOf("area") ? (u = "auto", f = 4) : 0 <= k.indexOf("stacked") ? "auto" === u && (u = "inside") : "bubble" !== k && "scatter" !== k || (u = "inside"), l = j.point.x - g / 2, "inside" !== u ? (d = b.y1, e = b.y2, 0 < x ? (n = j.point.y - h - f - c, n < d && (n = "auto" === u ? Math.max(j.point.y, d) + f + c : d + f + c, A = n + h > j.point.y)) : (n = j.point.y + f + c, n > e - h - f - c && (n = "auto" === u ? Math.min(j.point.y, e) - h - f - c : e - h - f - c, A = n < j.point.y))) : (d = Math.max(j.bounds.y1, b.y1), e = Math.min(j.bounds.y2, b.y2), c = 0 <= k.indexOf("range") ? 0 < x ? Math.max(j.bounds.y1, b.y1) + h / 2 + f : Math.min(j.bounds.y2, b.y2) - h / 2 - f : (Math.max(j.bounds.y1, b.y1) + Math.min(j.bounds.y2, b.y2)) / 2, 0 < x ? (n = Math.max(j.point.y, c) - h / 2, n < d && ("bubble" === k || "scatter" === k) && (n = Math.max(j.point.y - h - f, b.y1 + f))) : (n = Math.min(j.point.y, c) - h / 2, n > e - h - f && ("bubble" === k || "scatter" === k) && (n = Math.min(j.point.y + f, b.y2 - h - f))), n = Math.min(n, e - h))) : (0 <= k.indexOf("line") || 0 <= k.indexOf("area") || 0 <= k.indexOf("scatter") ? (u = "auto", d = 4) : 0 <= k.indexOf("stacked") ? "auto" === u && (u = "inside") : "bubble" === k && (u = "inside"), n = j.point.y - h / 2, "inside" !== u ? (f = b.x1, e = b.x2, 0 > x ? (l = j.point.x - g - d - c, l < f && (l = "auto" === u ? Math.max(j.point.x, f) + d + c : f + d + c, A = l + g > j.point.x)) : (l = j.point.x + d + c, l > e - g - d - c && (l = "auto" === u ? Math.min(j.point.x, e) - g - d - c : e - g - d - c, A = l < j.point.x))) : (f = Math.max(j.bounds.x1, b.x1), Math.min(j.bounds.x2, b.x2), c = 0 <= k.indexOf("range") ? 0 > x ? Math.max(j.bounds.x1, b.x1) + g / 2 + d : Math.min(j.bounds.x2, b.x2) - g / 2 - d : (Math.max(j.bounds.x1, b.x1) + Math.min(j.bounds.x2, b.x2)) / 2, l = 0 > x ? Math.max(j.point.x, c) - g / 2 : Math.min(j.point.x, c) - g / 2, l = Math.max(l, f))), "vertical" === v && (n += h), p.x = l, p.y = n, p.render(!0), t && "inside" !== u && (0 > k.indexOf("bar") && j.point.x > b.x1 && j.point.x < b.x2 || !A) && (0 > k.indexOf("column") && j.point.y > b.y1 && j.point.y < b.y2 || !A) && (a.lineWidth = t, a.strokeStyle = s ? s : "gray", a.setLineDash && a.setLineDash(o(q, t)), a.beginPath(), a.moveTo(j.point.x, j.point.y), 0 <= k.indexOf("bar") ? a.lineTo(l + (0 < j.direction ? 0 : g), n + ("horizontal" === v ? h : -h) / 2) : 0 <= k.indexOf("column") ? a.lineTo(l + g / 2, n + ((0 < j.direction ? h : -h) + ("horizontal" === v ? h : -h)) / 2) : a.lineTo(l + g / 2, n + ((n < j.point.y ? h : -h) + ("horizontal" === v ? h : -h)) / 2), a.stroke())
            }
        }
        return {
            source: a
            , dest: this.plotArea.ctx
            , animationCallback: ia.fadeInAnimation
            , easingFunction: ia.easing.easeInQuad
            , animationBase: 0
            , startTimePercent: .7
        }
    }, A.prototype.renderLine = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = this._eventManager.ghostCtx;
            b.save();
            var d = this.plotArea;
            b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip();
            for (var d = [], e = 0; e < a.dataSeriesIndexes.length; e++) {
                var f = a.dataSeriesIndexes[e]
                    , g = this.data[f];
                b.lineWidth = g.lineThickness;
                var h = g.dataPoints
                    , i = "solid";
                if (b.setLineDash) {
                    var j = o(g.nullDataLineDashType, g.lineThickness)
                        , i = g.lineDashType
                        , l = o(i, g.lineThickness);
                    b.setLineDash(l)
                }
                var m = g.id;
                this._eventManager.objectMap[m] = {
                    objectType: "dataSeries"
                    , dataSeriesIndex: f
                }, m = k(m), c.strokeStyle = m, c.lineWidth = 0 < g.lineThickness ? Math.max(g.lineThickness, 4) : 0;
                var m = g._colorSet
                    , n = m = g._options.lineColor ? g._options.lineColor : m[0];
                b.strokeStyle = m;
                var r, s, p = !0
                    , q = 0;
                if (b.beginPath(), 0 < h.length) {
                    for (var t = !1, q = 0; q < h.length; q++)
                        if (r = h[q].x.getTime ? h[q].x.getTime() : h[q].x, !(r < a.axisX.dataInfo.viewPortMin || r > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !t)))
                            if ("number" != typeof h[q].y) 0 < q && !(g.connectNullData || t || p) && (b.stroke(), R && c.stroke()), t = !0;
                            else {
                                r = a.axisX.convertValueToPixel(r), s = a.axisY.convertValueToPixel(h[q].y);
                                var u = g.dataPointIds[q];
                                if (this._eventManager.objectMap[u] = {
                                        id: u
                                        , objectType: "dataPoint"
                                        , dataSeriesIndex: f
                                        , dataPointIndex: q
                                        , x1: r
                                        , y1: s
                                    }, p || t ? (!p && g.connectNullData ? (b.setLineDash && (g._options.nullDataLineDashType || i === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (b.stroke(), i = g.nullDataLineDashType, b.setLineDash(j)), b.lineTo(r, s), R && c.lineTo(r, s)) : (b.beginPath(), b.moveTo(r, s), R && (c.beginPath(), c.moveTo(r, s))), t = p = !1) : (b.lineTo(r, s), R && c.lineTo(r, s), 0 == q % 500 && (b.stroke(), b.beginPath(), b.moveTo(r, s), R && (c.stroke(), c.beginPath(), c.moveTo(r, s)))), q < h.length - 1 && (n !== (h[q].lineColor || m) || i !== (h[q].lineDashType || g.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(r, s), n = h[q].lineColor || m, b.strokeStyle = n, b.setLineDash && (h[q].lineDashType ? (i = h[q].lineDashType, b.setLineDash(o(i, g.lineThickness))) : (i = g.lineDashType, b.setLineDash(l)))), 0 < h[q].markerSize || 0 < g.markerSize) {
                                    var v = g.getMarkerProperties(q, r, s, b);
                                    d.push(v), u = k(u), R && d.push({
                                        x: r
                                        , y: s
                                        , ctx: c
                                        , type: v.type
                                        , size: v.size
                                        , color: u
                                        , borderColor: u
                                        , borderThickness: v.borderThickness
                                    })
                                }(h[q].indexLabel || g.indexLabel || h[q].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "line"
                                    , dataPoint: h[q]
                                    , dataSeries: g
                                    , point: {
                                        x: r
                                        , y: s
                                    }
                                    , direction: 0 > h[q].y === a.axisY.reversed ? 1 : -1
                                    , color: m
                                })
                            }
                    b.stroke(), R && c.stroke()
                }
            }
            return ja.drawMarkers(d), b.restore(), b.beginPath(), R && c.beginPath(), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.xClipAnimation
                , easingFunction: ia.easing.linear
                , animationBase: 0
            }
        }
    }, A.prototype.renderStepLine = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var c = this._eventManager.ghostCtx;
            b.save();
            var d = this.plotArea;
            b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip();
            for (var d = [], e = 0; e < a.dataSeriesIndexes.length; e++) {
                var f = a.dataSeriesIndexes[e]
                    , g = this.data[f];
                b.lineWidth = g.lineThickness;
                var h = g.dataPoints
                    , i = "solid";
                if (b.setLineDash) {
                    var j = o(g.nullDataLineDashType, g.lineThickness)
                        , i = g.lineDashType
                        , l = o(i, g.lineThickness);
                    b.setLineDash(l)
                }
                var m = g.id;
                this._eventManager.objectMap[m] = {
                    objectType: "dataSeries"
                    , dataSeriesIndex: f
                }, m = k(m), c.strokeStyle = m, c.lineWidth = 0 < g.lineThickness ? Math.max(g.lineThickness, 4) : 0;
                var m = g._colorSet
                    , n = m = g._options.lineColor ? g._options.lineColor : m[0];
                b.strokeStyle = m;
                var r, s, p = !0
                    , q = 0;
                if (b.beginPath(), 0 < h.length) {
                    for (var t = !1, q = 0; q < h.length; q++)
                        if (r = h[q].getTime ? h[q].x.getTime() : h[q].x, !(r < a.axisX.dataInfo.viewPortMin || r > a.axisX.dataInfo.viewPortMax && (!g.connectNullData || !t)))
                            if ("number" != typeof h[q].y) 0 < q && !(g.connectNullData || t || p) && (b.stroke(), R && c.stroke()), t = !0;
                            else {
                                var u = s;
                                r = a.axisX.convertValueToPixel(r), s = a.axisY.convertValueToPixel(h[q].y);
                                var v = g.dataPointIds[q];
                                this._eventManager.objectMap[v] = {
                                    id: v
                                    , objectType: "dataPoint"
                                    , dataSeriesIndex: f
                                    , dataPointIndex: q
                                    , x1: r
                                    , y1: s
                                }, p || t ? (!p && g.connectNullData ? (b.setLineDash && (g._options.nullDataLineDashType || i === g.lineDashType && g.lineDashType !== g.nullDataLineDashType) && (b.stroke(), i = g.nullDataLineDashType, b.setLineDash(j)), b.lineTo(r, u), b.lineTo(r, s), R && (c.lineTo(r, u), c.lineTo(r, s))) : (b.beginPath(), b.moveTo(r, s), R && (c.beginPath(), c.moveTo(r, s))), t = p = !1) : (b.lineTo(r, u), R && c.lineTo(r, u), b.lineTo(r, s), R && c.lineTo(r, s), 0 == q % 500 && (b.stroke(), b.beginPath(), b.moveTo(r, s), R && (c.stroke(), c.beginPath(), c.moveTo(r, s)))), q < h.length - 1 && (n !== (h[q].lineColor || m) || i !== (h[q].lineDashType || g.lineDashType)) && (b.stroke(), b.beginPath(), b.moveTo(r, s), n = h[q].lineColor || m, b.strokeStyle = n, b.setLineDash && (h[q].lineDashType ? (i = h[q].lineDashType, b.setLineDash(o(i, g.lineThickness))) : (i = g.lineDashType, b.setLineDash(l)))), (0 < h[q].markerSize || 0 < g.markerSize) && (u = g.getMarkerProperties(q, r, s, b), d.push(u), v = k(v), R && d.push({
                                    x: r
                                    , y: s
                                    , ctx: c
                                    , type: u.type
                                    , size: u.size
                                    , color: v
                                    , borderColor: v
                                    , borderThickness: u.borderThickness
                                })), (h[q].indexLabel || g.indexLabel || h[q].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "stepLine"
                                    , dataPoint: h[q]
                                    , dataSeries: g
                                    , point: {
                                        x: r
                                        , y: s
                                    }
                                    , direction: 0 > h[q].y === a.axisY.reversed ? 1 : -1
                                    , color: m
                                })
                            }
                    b.stroke(), R && c.stroke()
                }
            }
            return ja.drawMarkers(d), b.restore(), b.beginPath(), R && c.beginPath(), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.xClipAnimation
                , easingFunction: ia.easing.linear
                , animationBase: 0
            }
        }
    }, A.prototype.renderSpline = function (a) {
        function b(a) {
            if (a = B(a, 2), 0 < a.length) {
                c.beginPath(), R && d.beginPath(), c.moveTo(a[0].x, a[0].y), a[0].newStrokeStyle && (c.strokeStyle = a[0].newStrokeStyle), a[0].newLineDashArray && c.setLineDash(a[0].newLineDashArray), R && d.moveTo(a[0].x, a[0].y);
                for (var b = 0; b < a.length - 3; b += 3) c.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), R && d.bezierCurveTo(a[b + 1].x, a[b + 1].y, a[b + 2].x, a[b + 2].y, a[b + 3].x, a[b + 3].y), (0 < b && 0 === b % 3e3 || a[b + 3].newStrokeStyle || a[b + 3].newLineDashArray) && (c.stroke(), c.beginPath(), c.moveTo(a[b + 3].x, a[b + 3].y), a[b + 3].newStrokeStyle && (c.strokeStyle = a[b + 3].newStrokeStyle), a[b + 3].newLineDashArray && c.setLineDash(a[b + 3].newLineDashArray), R && (d.stroke(), d.beginPath(), d.moveTo(a[b + 3].x, a[b + 3].y)));
                c.stroke(), R && d.stroke()
            }
        }
        var c = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = this._eventManager.ghostCtx;
            c.save();
            var e = this.plotArea;
            c.beginPath(), c.rect(e.x1, e.y1, e.width, e.height), c.clip();
            for (var e = [], f = 0; f < a.dataSeriesIndexes.length; f++) {
                var g = a.dataSeriesIndexes[f]
                    , h = this.data[g];
                c.lineWidth = h.lineThickness;
                var i = h.dataPoints
                    , j = "solid";
                if (c.setLineDash) {
                    var l = o(h.nullDataLineDashType, h.lineThickness)
                        , j = h.lineDashType
                        , m = o(j, h.lineThickness);
                    c.setLineDash(m)
                }
                var n = h.id;
                this._eventManager.objectMap[n] = {
                    objectType: "dataSeries"
                    , dataSeriesIndex: g
                }, n = k(n), d.strokeStyle = n, d.lineWidth = 0 < h.lineThickness ? Math.max(h.lineThickness, 4) : 0;
                var n = h._colorSet
                    , p = n = h._options.lineColor ? h._options.lineColor : n[0];
                c.strokeStyle = n;
                var r, s, q = 0
                    , t = [];
                if (c.beginPath(), 0 < i.length)
                    for (s = !1, q = 0; q < i.length; q++)
                        if (r = i[q].getTime ? i[q].x.getTime() : i[q].x, !(r < a.axisX.dataInfo.viewPortMin || r > a.axisX.dataInfo.viewPortMax && (!h.connectNullData || !s)))
                            if ("number" != typeof i[q].y) 0 < q && !s && (h.connectNullData ? c.setLineDash && 0 < t.length && (h._options.nullDataLineDashType || !i[q - 1].lineDashType) && (t[t.length - 1].newLineDashArray = l, j = h.nullDataLineDashType) : (b(t), t = [])), s = !0;
                            else {
                                r = a.axisX.convertValueToPixel(r), s = a.axisY.convertValueToPixel(i[q].y);
                                var u = h.dataPointIds[q];
                                if (this._eventManager.objectMap[u] = {
                                        id: u
                                        , objectType: "dataPoint"
                                        , dataSeriesIndex: g
                                        , dataPointIndex: q
                                        , x1: r
                                        , y1: s
                                    }, t[t.length] = {
                                        x: r
                                        , y: s
                                    }, q < i.length - 1 && (p !== (i[q].lineColor || n) || j !== (i[q].lineDashType || h.lineDashType)) && (p = i[q].lineColor || n, t[t.length - 1].newStrokeStyle = p, c.setLineDash && (i[q].lineDashType ? (j = i[q].lineDashType, t[t.length - 1].newLineDashArray = o(j, h.lineThickness)) : (j = h.lineDashType, t[t.length - 1].newLineDashArray = m))), 0 < i[q].markerSize || 0 < h.markerSize) {
                                    var v = h.getMarkerProperties(q, r, s, c);
                                    e.push(v), u = k(u), R && e.push({
                                        x: r
                                        , y: s
                                        , ctx: d
                                        , type: v.type
                                        , size: v.size
                                        , color: u
                                        , borderColor: u
                                        , borderThickness: v.borderThickness
                                    })
                                }(i[q].indexLabel || h.indexLabel || i[q].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "spline"
                                    , dataPoint: i[q]
                                    , dataSeries: h
                                    , point: {
                                        x: r
                                        , y: s
                                    }
                                    , direction: 0 > i[q].y === a.axisY.reversed ? 1 : -1
                                    , color: n
                                }), s = !1
                            }
                b(t)
            }
            return ja.drawMarkers(e), c.restore(), c.beginPath(), R && d.beginPath(), {
                source: c
                , dest: this.plotArea.ctx
                , animationCallback: ia.xClipAnimation
                , easingFunction: ia.easing.linear
                , animationBase: 0
            }
        }
    };
    var ga = function (a, b, c, d, e, f, g, h, i, j, k, l, m) {
        "undefined" == typeof m && (m = 1), g = g || 0, h = h || "black";
        var n = 15 < d - b && 15 < e - c ? 8 : .35 * Math.min(d - b, e - c);
        a.beginPath(), a.moveTo(b, c), a.save(), a.fillStyle = f, a.globalAlpha = m, a.fillRect(b, c, d - b, e - c), a.globalAlpha = 1, 0 < g && (m = 0 === g % 2 ? 0 : .5, a.beginPath(), a.lineWidth = g, a.strokeStyle = h, a.moveTo(b, c), a.rect(b - m, c - m, d - b + 2 * m, e - c + 2 * m), a.stroke()), a.restore(), !0 === i && (a.save(), a.beginPath(), a.moveTo(b, c), a.lineTo(b + n, c + n), a.lineTo(d - n, c + n), a.lineTo(d, c), a.closePath(), g = a.createLinearGradient((d + b) / 2, c + n, (d + b) / 2, c), g.addColorStop(0, f), g.addColorStop(1, "rgba(255, 255, 255, .4)"), a.fillStyle = g, a.fill(), a.restore()), !0 === j && (a.save(), a.beginPath(), a.moveTo(b, e), a.lineTo(b + n, e - n), a.lineTo(d - n, e - n), a.lineTo(d, e), a.closePath(), g = a.createLinearGradient((d + b) / 2, e - n, (d + b) / 2, e), g.addColorStop(0, f), g.addColorStop(1, "rgba(255, 255, 255, .4)"), a.fillStyle = g, a.fill(), a.restore()), !0 === k && (a.save(), a.beginPath(), a.moveTo(b, c), a.lineTo(b + n, c + n), a.lineTo(b + n, e - n), a.lineTo(b, e), a.closePath(), g = a.createLinearGradient(b + n, (e + c) / 2, b, (e + c) / 2), g.addColorStop(0, f), g.addColorStop(1, "rgba(255, 255, 255, 0.1)"), a.fillStyle = g, a.fill(), a.restore()), !0 === l && (a.save(), a.beginPath(), a.moveTo(d, c), a.lineTo(d - n, c + n), a.lineTo(d - n, e - n), a.lineTo(d, e), g = a.createLinearGradient(d - n, (e + c) / 2, d, (e + c) / 2), g.addColorStop(0, f), g.addColorStop(1, "rgba(255, 255, 255, 0.1)"), a.fillStyle = g, g.addColorStop(0, f), g.addColorStop(1, "rgba(255, 255, 255, 0.1)"), a.fillStyle = g, a.fill(), a.closePath(), a.restore())
    };
    A.prototype.renderColumn = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var f, g, h, c = null
                , d = this.plotArea
                , e = 0
                , i = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                , e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1
                , j = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.width, .9 * (this.plotArea.width / a.plotType.totalDataSeries)) << 0
                , l = a.axisX.dataInfo.minDiff;
            for (isFinite(l) || (l = .3 * Math.abs(a.axisX.range)), l = this.dataPointWidth ? this.dataPointWidth : .9 * (d.width * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0, this.dataPointMaxWidth && e > j && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, j)), !this.dataPointMaxWidth && this.dataPointMinWidth && j < e && (j = Math.max(this.dataPointWidth ? this.dataPointWidth : -(1 / 0), e)), l < e && (l = e), l > j && (l = j), b.save(), R && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(), R && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip()), d = 0; d < a.dataSeriesIndexes.length; d++) {
                var j = a.dataSeriesIndexes[d]
                    , m = this.data[j]
                    , n = m.dataPoints;
                if (0 < n.length)
                    for (var o = !!(5 < l && m.bevelEnabled), e = 0; e < n.length; e++)
                        if (h = n[e].getTime ? n[e].x.getTime() : n[e].x, !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && "number" == typeof n[e].y) {
                            f = a.axisX.convertValueToPixel(h), g = a.axisY.convertValueToPixel(n[e].y), f = a.axisX.reversed ? f + a.plotType.totalDataSeries * l / 2 - (a.previousDataSeriesCount + d) * l << 0 : f - a.plotType.totalDataSeries * l / 2 + (a.previousDataSeriesCount + d) * l << 0;
                            var q, p = a.axisX.reversed ? f - l << 0 : f + l << 0;
                            0 <= n[e].y ? q = i : (q = g, g = i), g > q && (c = g, g = q, q = c), c = n[e].color ? n[e].color : m._colorSet[e % m._colorSet.length], ga(b, f, g, p, q, c, 0, null, o && 0 <= n[e].y, 0 > n[e].y && o, !1, !1, m.fillOpacity), c = m.dataPointIds[e], this._eventManager.objectMap[c] = {
                                id: c
                                , objectType: "dataPoint"
                                , dataSeriesIndex: j
                                , dataPointIndex: e
                                , x1: f
                                , y1: g
                                , x2: p
                                , y2: q
                            }, c = k(c), R && ga(this._eventManager.ghostCtx, f, g, p, q, c, 0, null, !1, !1, !1, !1), (n[e].indexLabel || m.indexLabel || n[e].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
                                chartType: "column"
                                , dataPoint: n[e]
                                , dataSeries: m
                                , point: {
                                    x: f + (p - f) / 2
                                    , y: 0 > n[e].y === a.axisY.reversed ? g : q
                                }
                                , direction: 0 > n[e].y === a.axisY.reversed ? 1 : -1
                                , bounds: {
                                    x1: f
                                    , y1: Math.min(g, q)
                                    , x2: p
                                    , y2: Math.max(g, q)
                                }
                                , color: c
                            })
                        }
            }
            return b.restore(), R && this._eventManager.ghostCtx.restore(), a = Math.min(i, a.axisY.boundingRect.y2), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.yScaleAnimation
                , easingFunction: ia.easing.easeOutQuart
                , animationBase: a
            }
        }
    }, A.prototype.renderStackedColumn = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var i, c = null
                , d = this.plotArea
                , e = []
                , f = []
                , g = []
                , h = 0
                , j = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                , h = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1
                , l = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .15 * this.width << 0
                , m = a.axisX.dataInfo.minDiff;
            for (isFinite(m) || (m = .3 * Math.abs(a.axisX.range)), m = this.dataPointWidth ? this.dataPointWidth : .9 * (d.width * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0, this.dataPointMaxWidth && h > l && (h = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, l)), !this.dataPointMaxWidth && this.dataPointMinWidth && l < h && (l = Math.max(this.dataPointWidth ? this.dataPointWidth : -(1 / 0), h)), m < h && (m = h), m > l && (m = l), b.save(), R && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(), R && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip()), l = 0; l < a.dataSeriesIndexes.length; l++) {
                var n = a.dataSeriesIndexes[l]
                    , o = this.data[n]
                    , p = o.dataPoints;
                if (0 < p.length) {
                    var q = !!(5 < m && o.bevelEnabled);
                    for (b.strokeStyle = "#4572A7 ", h = 0; h < p.length; h++)
                        if (c = p[h].x.getTime ? p[h].x.getTime() : p[h].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" == typeof p[h].y) {
                            var t, d = a.axisX.convertValueToPixel(c)
                                , r = d - a.plotType.plotUnits.length * m / 2 + a.index * m << 0
                                , s = r + m << 0;
                            if (a.axisY.logarithmic) g[c] = p[h].y + (g[c] ? g[c] : 0), 0 < g[c] && (i = a.axisY.convertValueToPixel(g[c]), t = e[c] ? e[c] : j, e[c] = i);
                            else if (i = a.axisY.convertValueToPixel(p[h].y), 0 <= p[h].y) {
                                var u = e[c] ? e[c] : 0;
                                i -= u, t = j - u, e[c] = u + (t - i)
                            }
                            else u = f[c] ? f[c] : 0, t = i + u, i = j + u, f[c] = u + (t - i);
                            c = p[h].color ? p[h].color : o._colorSet[h % o._colorSet.length], ga(b, r, i, s, t, c, 0, null, q && 0 <= p[h].y, 0 > p[h].y && q, !1, !1, o.fillOpacity), c = o.dataPointIds[h], this._eventManager.objectMap[c] = {
                                id: c
                                , objectType: "dataPoint"
                                , dataSeriesIndex: n
                                , dataPointIndex: h
                                , x1: r
                                , y1: i
                                , x2: s
                                , y2: t
                            }, c = k(c), R && ga(this._eventManager.ghostCtx, r, i, s, t, c, 0, null, !1, !1, !1, !1), (p[h].indexLabel || o.indexLabel || p[h].indexLabelFormatter || o.indexLabelFormatter) && this._indexLabels.push({
                                chartType: "stackedColumn"
                                , dataPoint: p[h]
                                , dataSeries: o
                                , point: {
                                    x: d
                                    , y: 0 <= p[h].y ? i : t
                                }
                                , direction: 0 > p[h].y === a.axisY.reversed ? 1 : -1
                                , bounds: {
                                    x1: r
                                    , y1: Math.min(i, t)
                                    , x2: s
                                    , y2: Math.max(i, t)
                                }
                                , color: c
                            })
                        }
                }
            }
            return b.restore(), R && this._eventManager.ghostCtx.restore(), a = Math.min(j, a.axisY.boundingRect.y2), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.yScaleAnimation
                , easingFunction: ia.easing.easeOutQuart
                , animationBase: a
            }
        }
    }, A.prototype.renderStackedColumn100 = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var i, c = null
                , d = this.plotArea
                , e = []
                , f = []
                , g = []
                , h = 0
                , j = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                , h = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1
                , l = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .15 * this.width << 0
                , m = a.axisX.dataInfo.minDiff;
            for (isFinite(m) || (m = .3 * Math.abs(a.axisX.range)), m = this.dataPointWidth ? this.dataPointWidth : .9 * (d.width * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0, this.dataPointMaxWidth && h > l && (h = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, l)), !this.dataPointMaxWidth && this.dataPointMinWidth && l < h && (l = Math.max(this.dataPointWidth ? this.dataPointWidth : -(1 / 0), h)), m < h && (m = h), m > l && (m = l), b.save(), R && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(), R && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip()), l = 0; l < a.dataSeriesIndexes.length; l++) {
                var n = a.dataSeriesIndexes[l]
                    , o = this.data[n]
                    , p = o.dataPoints;
                if (0 < p.length)
                    for (var q = !!(5 < m && o.bevelEnabled), h = 0; h < p.length; h++)
                        if (c = p[h].x.getTime ? p[h].x.getTime() : p[h].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" == typeof p[h].y) {
                            d = a.axisX.convertValueToPixel(c), i = 0 !== a.dataPointYSums[c] ? 100 * (p[h].y / a.dataPointYSums[c]) : 0;
                            var t, r = d - a.plotType.plotUnits.length * m / 2 + a.index * m << 0
                                , s = r + m << 0;
                            if (a.axisY.logarithmic) {
                                if (g[c] = i + (g[c] ? g[c] : 0), 0 >= g[c]) continue;
                                i = a.axisY.convertValueToPixel(g[c]), t = e[c] ? e[c] : j, e[c] = i
                            }
                            else if (i = a.axisY.convertValueToPixel(i), 0 <= p[h].y) {
                                var u = e[c] ? e[c] : 0;
                                i -= u, t = j - u, e[c] = u + (t - i)
                            }
                            else u = f[c] ? f[c] : 0, t = i + u, i = j + u, f[c] = u + (t - i);
                            c = p[h].color ? p[h].color : o._colorSet[h % o._colorSet.length], ga(b, r, i, s, t, c, 0, null, q && 0 <= p[h].y, 0 > p[h].y && q, !1, !1, o.fillOpacity), c = o.dataPointIds[h], this._eventManager.objectMap[c] = {
                                id: c
                                , objectType: "dataPoint"
                                , dataSeriesIndex: n
                                , dataPointIndex: h
                                , x1: r
                                , y1: i
                                , x2: s
                                , y2: t
                            }, c = k(c), R && ga(this._eventManager.ghostCtx, r, i, s, t, c, 0, null, !1, !1, !1, !1), (p[h].indexLabel || o.indexLabel || p[h].indexLabelFormatter || o.indexLabelFormatter) && this._indexLabels.push({
                                chartType: "stackedColumn100"
                                , dataPoint: p[h]
                                , dataSeries: o
                                , point: {
                                    x: d
                                    , y: 0 <= p[h].y ? i : t
                                }
                                , direction: 0 > p[h].y === a.axisY.reversed ? 1 : -1
                                , bounds: {
                                    x1: r
                                    , y1: Math.min(i, t)
                                    , x2: s
                                    , y2: Math.max(i, t)
                                }
                                , color: c
                            })
                        }
            }
            return b.restore(), R && this._eventManager.ghostCtx.restore(), a = Math.min(j, a.axisY.boundingRect.y2), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.yScaleAnimation
                , easingFunction: ia.easing.easeOutQuart
                , animationBase: a
            }
        }
    }, A.prototype.renderBar = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var f, g, h, c = null
                , d = this.plotArea
                , e = 0
                , i = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                , e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1
                , j = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.height, .9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0
                , l = a.axisX.dataInfo.minDiff;
            for (isFinite(l) || (l = .3 * Math.abs(a.axisX.range)), l = this.dataPointWidth ? this.dataPointWidth : .9 * (d.height * (a.axisX.logarithmic ? Math.log(l) / Math.log(a.axisX.range) : Math.abs(l) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0, this.dataPointMaxWidth && e > j && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, j)), !this.dataPointMaxWidth && this.dataPointMinWidth && j < e && (j = Math.max(this.dataPointWidth ? this.dataPointWidth : -(1 / 0), e)), l < e && (l = e), l > j && (l = j), b.save(), R && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(), R && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip()), d = 0; d < a.dataSeriesIndexes.length; d++) {
                var j = a.dataSeriesIndexes[d]
                    , m = this.data[j]
                    , n = m.dataPoints;
                if (0 < n.length) {
                    var o = !!(5 < l && m.bevelEnabled);
                    for (b.strokeStyle = "#4572A7 ", e = 0; e < n.length; e++)
                        if (h = n[e].getTime ? n[e].x.getTime() : n[e].x, !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && "number" == typeof n[e].y) {
                            g = a.axisX.convertValueToPixel(h), f = a.axisY.convertValueToPixel(n[e].y), g = a.axisX.reversed ? g + a.plotType.totalDataSeries * l / 2 - (a.previousDataSeriesCount + d) * l << 0 : g - a.plotType.totalDataSeries * l / 2 + (a.previousDataSeriesCount + d) * l << 0;
                            var q, p = a.axisX.reversed ? g - l << 0 : g + l << 0;
                            0 <= n[e].y ? q = i : (q = f, f = i), c = n[e].color ? n[e].color : m._colorSet[e % m._colorSet.length], ga(b, q, g, f, p, c, 0, null, o, !1, !1, !1, m.fillOpacity), c = m.dataPointIds[e], this._eventManager.objectMap[c] = {
                                id: c
                                , objectType: "dataPoint"
                                , dataSeriesIndex: j
                                , dataPointIndex: e
                                , x1: q
                                , y1: g
                                , x2: f
                                , y2: p
                            }, c = k(c), R && ga(this._eventManager.ghostCtx, q, g, f, p, c, 0, null, !1, !1, !1, !1), (n[e].indexLabel || m.indexLabel || n[e].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
                                chartType: "bar"
                                , dataPoint: n[e]
                                , dataSeries: m
                                , point: {
                                    x: 0 <= n[e].y ? f : q
                                    , y: g + (p - g) / 2
                                }
                                , direction: 0 > n[e].y === a.axisY.reversed ? 1 : -1
                                , bounds: {
                                    x1: Math.min(q, f)
                                    , y1: g
                                    , x2: Math.max(q, f)
                                    , y2: p
                                }
                                , color: c
                            })
                        }
                }
            }
            return b.restore(), R && this._eventManager.ghostCtx.restore(), a = Math.max(i, a.axisX.boundingRect.x2), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.xScaleAnimation
                , easingFunction: ia.easing.easeOutQuart
                , animationBase: a
            }
        }
    }, A.prototype.renderStackedBar = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var i, c = null
                , d = this.plotArea
                , e = []
                , f = []
                , g = []
                , h = 0
                , j = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                , h = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1
                , l = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .15 * this.height << 0
                , m = a.axisX.dataInfo.minDiff;
            for (isFinite(m) || (m = .3 * Math.abs(a.axisX.range)), m = this.dataPointWidth ? this.dataPointWidth : .9 * (d.height * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0, this.dataPointMaxWidth && h > l && (h = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, l)), !this.dataPointMaxWidth && this.dataPointMinWidth && l < h && (l = Math.max(this.dataPointWidth ? this.dataPointWidth : -(1 / 0), h)), m < h && (m = h), m > l && (m = l), b.save(), R && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(), R && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip()), l = 0; l < a.dataSeriesIndexes.length; l++) {
                var n = a.dataSeriesIndexes[l]
                    , o = this.data[n]
                    , p = o.dataPoints;
                if (0 < p.length) {
                    var q = !!(5 < m && o.bevelEnabled);
                    for (b.strokeStyle = "#4572A7 ", h = 0; h < p.length; h++)
                        if (c = p[h].x.getTime ? p[h].x.getTime() : p[h].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" == typeof p[h].y) {
                            var t, d = a.axisX.convertValueToPixel(c)
                                , r = d - a.plotType.plotUnits.length * m / 2 + a.index * m << 0
                                , s = r + m << 0;
                            if (a.axisY.logarithmic) g[c] = p[h].y + (g[c] ? g[c] : 0), 0 < g[c] && (t = e[c] ? e[c] : j, e[c] = i = a.axisY.convertValueToPixel(g[c]));
                            else if (i = a.axisY.convertValueToPixel(p[h].y), 0 <= p[h].y) {
                                var u = e[c] ? e[c] : 0;
                                t = j + u, i += u, e[c] = u + (i - t)
                            }
                            else u = f[c] ? f[c] : 0, t = i - u, i = j - u, f[c] = u + (i - t);
                            c = p[h].color ? p[h].color : o._colorSet[h % o._colorSet.length], ga(b, t, r, i, s, c, 0, null, q, !1, !1, !1, o.fillOpacity), c = o.dataPointIds[h], this._eventManager.objectMap[c] = {
                                id: c
                                , objectType: "dataPoint"
                                , dataSeriesIndex: n
                                , dataPointIndex: h
                                , x1: t
                                , y1: r
                                , x2: i
                                , y2: s
                            }, c = k(c), R && ga(this._eventManager.ghostCtx, t, r, i, s, c, 0, null, !1, !1, !1, !1), (p[h].indexLabel || o.indexLabel || p[h].indexLabelFormatter || o.indexLabelFormatter) && this._indexLabels.push({
                                chartType: "stackedBar"
                                , dataPoint: p[h]
                                , dataSeries: o
                                , point: {
                                    x: 0 <= p[h].y ? i : t
                                    , y: d
                                }
                                , direction: 0 > p[h].y === a.axisY.reversed ? 1 : -1
                                , bounds: {
                                    x1: Math.min(t, i)
                                    , y1: r
                                    , x2: Math.max(t, i)
                                    , y2: s
                                }
                                , color: c
                            })
                        }
                }
            }
            return b.restore(), R && this._eventManager.ghostCtx.restore(), a = Math.max(j, a.axisX.boundingRect.x2), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.xScaleAnimation
                , easingFunction: ia.easing.easeOutQuart
                , animationBase: a
            }
        }
    }, A.prototype.renderStackedBar100 = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var i, c = null
                , d = this.plotArea
                , e = []
                , f = []
                , g = []
                , h = 0
                , j = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                , h = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1
                , l = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .15 * this.height << 0
                , m = a.axisX.dataInfo.minDiff;
            for (isFinite(m) || (m = .3 * Math.abs(a.axisX.range)), m = this.dataPointWidth ? this.dataPointWidth : .9 * (d.height * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) / a.plotType.plotUnits.length) << 0, this.dataPointMaxWidth && h > l && (h = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, l)), !this.dataPointMaxWidth && this.dataPointMinWidth && l < h && (l = Math.max(this.dataPointWidth ? this.dataPointWidth : -(1 / 0), h)), m < h && (m = h), m > l && (m = l), b.save(), R && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(), R && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip()), l = 0; l < a.dataSeriesIndexes.length; l++) {
                var n = a.dataSeriesIndexes[l]
                    , o = this.data[n]
                    , p = o.dataPoints;
                if (0 < p.length) {
                    var q = !!(5 < m && o.bevelEnabled);
                    for (b.strokeStyle = "#4572A7 ", h = 0; h < p.length; h++)
                        if (c = p[h].x.getTime ? p[h].x.getTime() : p[h].x, !(c < a.axisX.dataInfo.viewPortMin || c > a.axisX.dataInfo.viewPortMax) && "number" == typeof p[h].y) {
                            var r, d = a.axisX.convertValueToPixel(c);
                            r = 0 !== a.dataPointYSums[c] ? 100 * (p[h].y / a.dataPointYSums[c]) : 0;
                            var s = d - a.plotType.plotUnits.length * m / 2 + a.index * m << 0
                                , t = s + m << 0;
                            if (a.axisY.logarithmic) {
                                if (g[c] = r + (g[c] ? g[c] : 0), 0 >= g[c]) continue;
                                r = e[c] ? e[c] : j, e[c] = i = a.axisY.convertValueToPixel(g[c])
                            }
                            else if (i = a.axisY.convertValueToPixel(r), 0 <= p[h].y) {
                                var u = e[c] ? e[c] : 0;
                                r = j + u, i += u, e[c] = u + (i - r)
                            }
                            else u = f[c] ? f[c] : 0, r = i - u, i = j - u, f[c] = u + (i - r);
                            c = p[h].color ? p[h].color : o._colorSet[h % o._colorSet.length], ga(b, r, s, i, t, c, 0, null, q, !1, !1, !1, o.fillOpacity), c = o.dataPointIds[h], this._eventManager.objectMap[c] = {
                                id: c
                                , objectType: "dataPoint"
                                , dataSeriesIndex: n
                                , dataPointIndex: h
                                , x1: r
                                , y1: s
                                , x2: i
                                , y2: t
                            }, c = k(c), R && ga(this._eventManager.ghostCtx, r, s, i, t, c, 0, null, !1, !1, !1, !1), (p[h].indexLabel || o.indexLabel || p[h].indexLabelFormatter || o.indexLabelFormatter) && this._indexLabels.push({
                                chartType: "stackedBar100"
                                , dataPoint: p[h]
                                , dataSeries: o
                                , point: {
                                    x: 0 <= p[h].y ? i : r
                                    , y: d
                                }
                                , direction: 0 > p[h].y === a.axisY.reversed ? 1 : -1
                                , bounds: {
                                    x1: Math.min(r, i)
                                    , y1: s
                                    , x2: Math.max(r, i)
                                    , y2: t
                                }
                                , color: c
                            })
                        }
                }
            }
            return b.restore(), R && this._eventManager.ghostCtx.restore(), a = Math.max(j, a.axisX.boundingRect.x2), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.xScaleAnimation
                , easingFunction: ia.easing.easeOutQuart
                , animationBase: a
            }
        }
    }, A.prototype.renderArea = function (a) {
        function b() {
            u && (0 < j.lineThickness && c.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? t = s : 0 > a.axisY.viewportMaximum ? t = f.y1 : 0 < a.axisY.viewportMinimum && (t = e.y2), c.lineTo(p, t), c.lineTo(u.x, t), c.closePath(), c.globalAlpha = j.fillOpacity, c.fill(), c.globalAlpha = 1, R && (d.lineTo(p, t), d.lineTo(u.x, t), d.closePath(), d.fill()), c.beginPath(), c.moveTo(p, q), d.beginPath(), d.moveTo(p, q), u = {
                x: p
                , y: q
            })
        }
        var c = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = this._eventManager.ghostCtx
                , e = a.axisX.lineCoordinates
                , f = a.axisY.lineCoordinates
                , g = []
                , h = this.plotArea;
            for (c.save(), R && d.save(), c.beginPath(), c.rect(h.x1, h.y1, h.width, h.height), c.clip(), R && (d.beginPath(), d.rect(h.x1, h.y1, h.width, h.height), d.clip()), h = 0; h < a.dataSeriesIndexes.length; h++) {
                var i = a.dataSeriesIndexes[h]
                    , j = this.data[i]
                    , l = j.dataPoints
                    , g = j.id;
                this._eventManager.objectMap[g] = {
                    objectType: "dataSeries"
                    , dataSeriesIndex: i
                }, g = k(g), d.fillStyle = g;
                var p, q, r, t, g = []
                    , m = !0
                    , n = 0
                    , s = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                    , u = null;
                if (0 < l.length) {
                    var v = j._colorSet[n % j._colorSet.length]
                        , w = j._options.lineColor || v
                        , x = w;
                    c.fillStyle = v, c.strokeStyle = w, c.lineWidth = j.lineThickness;
                    var y = "solid";
                    if (c.setLineDash) {
                        var z = o(j.nullDataLineDashType, j.lineThickness)
                            , y = j.lineDashType
                            , A = o(y, j.lineThickness);
                        c.setLineDash(A)
                    }
                    for (var B = !0; n < l.length; n++)
                        if (r = l[n].x.getTime ? l[n].x.getTime() : l[n].x, !(r < a.axisX.dataInfo.viewPortMin || r > a.axisX.dataInfo.viewPortMax && (!j.connectNullData || !B)))
                            if ("number" != typeof l[n].y) j.connectNullData || B || m || b(), B = !0;
                            else {
                                p = a.axisX.convertValueToPixel(r), q = a.axisY.convertValueToPixel(l[n].y), m || B ? (!m && j.connectNullData ? (c.setLineDash && (j._options.nullDataLineDashType || y === j.lineDashType && j.lineDashType !== j.nullDataLineDashType) && (c.stroke(), y = j.nullDataLineDashType, c.setLineDash(z)), c.lineTo(p, q), R && d.lineTo(p, q)) : (c.beginPath(), c.moveTo(p, q), R && (d.beginPath(), d.moveTo(p, q)), u = {
                                    x: p
                                    , y: q
                                }), B = m = !1) : (c.lineTo(p, q), R && d.lineTo(p, q), 0 == n % 250 && b()), n < l.length - 1 && (x !== (l[n].lineColor || w) || y !== (l[n].lineDashType || j.lineDashType)) && (b(), x = l[n].lineColor || w, c.strokeStyle = x, c.setLineDash && (l[n].lineDashType ? (y = l[n].lineDashType, c.setLineDash(o(y, j.lineThickness))) : (y = j.lineDashType, c.setLineDash(A))));
                                var C = j.dataPointIds[n];
                                this._eventManager.objectMap[C] = {
                                    id: C
                                    , objectType: "dataPoint"
                                    , dataSeriesIndex: i
                                    , dataPointIndex: n
                                    , x1: p
                                    , y1: q
                                }, 0 !== l[n].markerSize && (0 < l[n].markerSize || 0 < j.markerSize) && (r = j.getMarkerProperties(n, p, q, c), g.push(r), C = k(C), R && g.push({
                                    x: p
                                    , y: q
                                    , ctx: d
                                    , type: r.type
                                    , size: r.size
                                    , color: C
                                    , borderColor: C
                                    , borderThickness: r.borderThickness
                                })), (l[n].indexLabel || j.indexLabel || l[n].indexLabelFormatter || j.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "area"
                                    , dataPoint: l[n]
                                    , dataSeries: j
                                    , point: {
                                        x: p
                                        , y: q
                                    }
                                    , direction: 0 > l[n].y === a.axisY.reversed ? 1 : -1
                                    , color: v
                                })
                            }
                    b(), ja.drawMarkers(g)
                }
            }
            return c.restore(), R && this._eventManager.ghostCtx.restore(), {
                source: c
                , dest: this.plotArea.ctx
                , animationCallback: ia.xClipAnimation
                , easingFunction: ia.easing.linear
                , animationBase: 0
            }
        }
    }, A.prototype.renderSplineArea = function (a) {
        function b() {
            var b = B(t, 2);
            if (0 < b.length) {
                if (0 < j.lineThickness) {
                    c.beginPath(), c.moveTo(b[0].x, b[0].y), b[0].newStrokeStyle && (c.strokeStyle = b[0].newStrokeStyle), b[0].newLineDashArray && c.setLineDash(b[0].newLineDashArray);
                    for (var g = 0; g < b.length - 3; g += 3) c.bezierCurveTo(b[g + 1].x, b[g + 1].y, b[g + 2].x, b[g + 2].y, b[g + 3].x, b[g + 3].y), R && d.bezierCurveTo(b[g + 1].x, b[g + 1].y, b[g + 2].x, b[g + 2].y, b[g + 3].x, b[g + 3].y), (b[g + 3].newStrokeStyle || b[g + 3].newLineDashArray) && (c.stroke(), c.beginPath(), c.moveTo(b[g + 3].x, b[g + 3].y), b[g + 3].newStrokeStyle && (c.strokeStyle = b[g + 3].newStrokeStyle), b[g + 3].newLineDashArray && c.setLineDash(b[g + 3].newLineDashArray));
                    c.stroke()
                }
                for (c.beginPath(), c.moveTo(b[0].x, b[0].y), R && (d.beginPath(), d.moveTo(b[0].x, b[0].y)), g = 0; g < b.length - 3; g += 3) c.bezierCurveTo(b[g + 1].x, b[g + 1].y, b[g + 2].x, b[g + 2].y, b[g + 3].x, b[g + 3].y), R && d.bezierCurveTo(b[g + 1].x, b[g + 1].y, b[g + 2].x, b[g + 2].y, b[g + 3].x, b[g + 3].y);
                a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? r = q : 0 > a.axisY.viewportMaximum ? r = f.y1 : 0 < a.axisY.viewportMinimum && (r = e.y2), s = {
                    x: b[0].x
                    , y: b[0].y
                }, c.lineTo(b[b.length - 1].x, r), c.lineTo(s.x, r), c.closePath(), c.globalAlpha = j.fillOpacity, c.fill(), c.globalAlpha = 1, R && (d.lineTo(b[b.length - 1].x, r), d.lineTo(s.x, r), d.closePath(), d.fill())
            }
        }
        var c = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = this._eventManager.ghostCtx
                , e = a.axisX.lineCoordinates
                , f = a.axisY.lineCoordinates
                , g = []
                , h = this.plotArea;
            for (c.save(), R && d.save(), c.beginPath(), c.rect(h.x1, h.y1, h.width, h.height), c.clip(), R && (d.beginPath(), d.rect(h.x1, h.y1, h.width, h.height), d.clip()), h = 0; h < a.dataSeriesIndexes.length; h++) {
                var i = a.dataSeriesIndexes[h]
                    , j = this.data[i]
                    , l = j.dataPoints
                    , g = j.id;
                this._eventManager.objectMap[g] = {
                    objectType: "dataSeries"
                    , dataSeriesIndex: i
                }, g = k(g), d.fillStyle = g;
                var n, p, r, g = []
                    , m = 0
                    , q = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                    , s = null
                    , t = [];
                if (0 < l.length) {
                    var u = j._colorSet[m % j._colorSet.length]
                        , v = j._options.lineColor || u
                        , w = v;
                    c.fillStyle = u, c.strokeStyle = v, c.lineWidth = j.lineThickness;
                    var x = "solid";
                    if (c.setLineDash) {
                        var y = o(j.nullDataLineDashType, j.lineThickness)
                            , x = j.lineDashType
                            , z = o(x, j.lineThickness);
                        c.setLineDash(z)
                    }
                    for (p = !1; m < l.length; m++)
                        if (n = l[m].x.getTime ? l[m].x.getTime() : l[m].x, !(n < a.axisX.dataInfo.viewPortMin || n > a.axisX.dataInfo.viewPortMax && (!j.connectNullData || !p)))
                            if ("number" != typeof l[m].y) 0 < m && !p && (j.connectNullData ? c.setLineDash && 0 < t.length && (j._options.nullDataLineDashType || !l[m - 1].lineDashType) && (t[t.length - 1].newLineDashArray = y, x = j.nullDataLineDashType) : (b(), t = [])), p = !0;
                            else {
                                n = a.axisX.convertValueToPixel(n), p = a.axisY.convertValueToPixel(l[m].y);
                                var A = j.dataPointIds[m];
                                if (this._eventManager.objectMap[A] = {
                                        id: A
                                        , objectType: "dataPoint"
                                        , dataSeriesIndex: i
                                        , dataPointIndex: m
                                        , x1: n
                                        , y1: p
                                    }, t[t.length] = {
                                        x: n
                                        , y: p
                                    }, m < l.length - 1 && (w !== (l[m].lineColor || v) || x !== (l[m].lineDashType || j.lineDashType)) && (w = l[m].lineColor || v, t[t.length - 1].newStrokeStyle = w, c.setLineDash && (l[m].lineDashType ? (x = l[m].lineDashType, t[t.length - 1].newLineDashArray = o(x, j.lineThickness)) : (x = j.lineDashType, t[t.length - 1].newLineDashArray = z))), 0 !== l[m].markerSize && (0 < l[m].markerSize || 0 < j.markerSize)) {
                                    var C = j.getMarkerProperties(m, n, p, c);
                                    g.push(C), A = k(A), R && g.push({
                                        x: n
                                        , y: p
                                        , ctx: d
                                        , type: C.type
                                        , size: C.size
                                        , color: A
                                        , borderColor: A
                                        , borderThickness: C.borderThickness
                                    })
                                }(l[m].indexLabel || j.indexLabel || l[m].indexLabelFormatter || j.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "splineArea"
                                    , dataPoint: l[m]
                                    , dataSeries: j
                                    , point: {
                                        x: n
                                        , y: p
                                    }
                                    , direction: 0 > l[m].y === a.axisY.reversed ? 1 : -1
                                    , color: u
                                }), p = !1
                            }
                    b(), ja.drawMarkers(g)
                }
            }
            return c.restore(), R && this._eventManager.ghostCtx.restore(), {
                source: c
                , dest: this.plotArea.ctx
                , animationCallback: ia.xClipAnimation
                , easingFunction: ia.easing.linear
                , animationBase: 0
            }
        }
    }, A.prototype.renderStepArea = function (a) {
        function b() {
            u && (0 < j.lineThickness && c.stroke(), a.axisY.logarithmic || 0 >= a.axisY.viewportMinimum && 0 <= a.axisY.viewportMaximum ? t = s : 0 > a.axisY.viewportMaximum ? t = f.y1 : 0 < a.axisY.viewportMinimum && (t = e.y2), c.lineTo(p, t), c.lineTo(u.x, t), c.closePath(), c.globalAlpha = j.fillOpacity, c.fill(), c.globalAlpha = 1, R && (d.lineTo(p, t), d.lineTo(u.x, t), d.closePath(), d.fill()), c.beginPath(), c.moveTo(p, q), d.beginPath(), d.moveTo(p, q), u = {
                x: p
                , y: q
            })
        }
        var c = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = this._eventManager.ghostCtx
                , e = a.axisX.lineCoordinates
                , f = a.axisY.lineCoordinates
                , g = []
                , h = this.plotArea;
            for (c.save(), R && d.save(), c.beginPath(), c.rect(h.x1, h.y1, h.width, h.height), c.clip(), R && (d.beginPath(), d.rect(h.x1, h.y1, h.width, h.height), d.clip()), h = 0; h < a.dataSeriesIndexes.length; h++) {
                var i = a.dataSeriesIndexes[h]
                    , j = this.data[i]
                    , l = j.dataPoints
                    , g = j.id;
                this._eventManager.objectMap[g] = {
                    objectType: "dataSeries"
                    , dataSeriesIndex: i
                }, g = k(g), d.fillStyle = g;
                var p, q, r, t, g = []
                    , m = !0
                    , n = 0
                    , s = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                    , u = null
                    , v = !1;
                if (0 < l.length) {
                    var w = j._colorSet[n % j._colorSet.length]
                        , x = j._options.lineColor || w
                        , y = x;
                    c.fillStyle = w, c.strokeStyle = x, c.lineWidth = j.lineThickness;
                    var z = "solid";
                    if (c.setLineDash) {
                        var A = o(j.nullDataLineDashType, j.lineThickness)
                            , z = j.lineDashType
                            , B = o(z, j.lineThickness);
                        c.setLineDash(B)
                    }
                    for (; n < l.length; n++)
                        if (r = l[n].x.getTime ? l[n].x.getTime() : l[n].x, !(r < a.axisX.dataInfo.viewPortMin || r > a.axisX.dataInfo.viewPortMax && (!j.connectNullData || !v))) {
                            var C = q;
                            "number" != typeof l[n].y ? (j.connectNullData || v || m || b(), v = !0) : (p = a.axisX.convertValueToPixel(r), q = a.axisY.convertValueToPixel(l[n].y), m || v ? (!m && j.connectNullData ? (c.setLineDash && (j._options.nullDataLineDashType || z === j.lineDashType && j.lineDashType !== j.nullDataLineDashType) && (c.stroke(), z = j.nullDataLineDashType, c.setLineDash(A)), c.lineTo(p, C), c.lineTo(p, q), R && (d.lineTo(p, C), d.lineTo(p, q))) : (c.beginPath(), c.moveTo(p, q), R && (d.beginPath(), d.moveTo(p, q)), u = {
                                x: p
                                , y: q
                            }), v = m = !1) : (c.lineTo(p, C), R && d.lineTo(p, C), c.lineTo(p, q), R && d.lineTo(p, q), 0 == n % 250 && b()), n < l.length - 1 && (y !== (l[n].lineColor || x) || z !== (l[n].lineDashType || j.lineDashType)) && (b(), y = l[n].lineColor || x, c.strokeStyle = y, c.setLineDash && (l[n].lineDashType ? (z = l[n].lineDashType, c.setLineDash(o(z, j.lineThickness))) : (z = j.lineDashType, c.setLineDash(B)))), C = j.dataPointIds[n], this._eventManager.objectMap[C] = {
                                id: C
                                , objectType: "dataPoint"
                                , dataSeriesIndex: i
                                , dataPointIndex: n
                                , x1: p
                                , y1: q
                            }, 0 !== l[n].markerSize && (0 < l[n].markerSize || 0 < j.markerSize) && (r = j.getMarkerProperties(n, p, q, c), g.push(r), C = k(C), R && g.push({
                                x: p
                                , y: q
                                , ctx: d
                                , type: r.type
                                , size: r.size
                                , color: C
                                , borderColor: C
                                , borderThickness: r.borderThickness
                            })), (l[n].indexLabel || j.indexLabel || l[n].indexLabelFormatter || j.indexLabelFormatter) && this._indexLabels.push({
                                chartType: "stepArea"
                                , dataPoint: l[n]
                                , dataSeries: j
                                , point: {
                                    x: p
                                    , y: q
                                }
                                , direction: 0 > l[n].y === a.axisY.reversed ? 1 : -1
                                , color: w
                            }))
                        }
                    b(), ja.drawMarkers(g)
                }
            }
            return c.restore(), R && this._eventManager.ghostCtx.restore(), {
                source: c
                , dest: this.plotArea.ctx
                , animationCallback: ia.xClipAnimation
                , easingFunction: ia.easing.linear
                , animationBase: 0
            }
        }
    }, A.prototype.renderStackedArea = function (a) {
        function b() {
            if (!(1 > i.length)) {
                for (0 < v.lineThickness && c.stroke(); 0 < i.length;) {
                    var a = i.pop();
                    c.lineTo(a.x, a.y), R && s.lineTo(a.x, a.y)
                }
                c.closePath(), c.globalAlpha = v.fillOpacity, c.fill(), c.globalAlpha = 1, c.beginPath(), R && (s.closePath(), s.fill(), s.beginPath()), i = []
            }
        }
        var c = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var n, p, q, d = null
                , e = []
                , f = this.plotArea
                , h = []
                , i = []
                , j = []
                , l = []
                , m = 0
                , r = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                , s = this._eventManager.ghostCtx;
            R && s.beginPath(), c.save(), R && s.save(), c.beginPath(), c.rect(f.x1, f.y1, f.width, f.height), c.clip(), R && (s.beginPath(), s.rect(f.x1, f.y1, f.width, f.height), s.clip());
            for (var t = [], f = 0; f < a.dataSeriesIndexes.length; f++) {
                var u = a.dataSeriesIndexes[f]
                    , v = this.data[u]
                    , w = v.dataPoints;
                for (v.dataPointIndexes = [], m = 0; m < w.length; m++) u = w[m].x.getTime ? w[m].x.getTime() : w[m].x, v.dataPointIndexes[u] = m, t[u] || (j.push(u), t[u] = !0);
                j.sort(g)
            }
            for (f = 0; f < a.dataSeriesIndexes.length; f++) {
                if (u = a.dataSeriesIndexes[f], v = this.data[u], w = v.dataPoints, t = !0, i = [], m = v.id, this._eventManager.objectMap[m] = {
                        objectType: "dataSeries"
                        , dataSeriesIndex: u
                    }, m = k(m), s.fillStyle = m, 0 < j.length) {
                    var d = v._colorSet[0]
                        , x = v._options.lineColor || d
                        , y = x;
                    c.fillStyle = d, c.strokeStyle = x, c.lineWidth = v.lineThickness;
                    var z = "solid";
                    if (c.setLineDash) {
                        var A = o(v.nullDataLineDashType, v.lineThickness)
                            , z = v.lineDashType
                            , B = o(z, v.lineThickness);
                        c.setLineDash(B)
                    }
                    for (var C = !0, m = 0; m < j.length; m++) {
                        q = j[m];
                        var D = null
                            , D = 0 <= v.dataPointIndexes[q] ? w[v.dataPointIndexes[q]] : {
                                x: q
                                , y: null
                            };
                        if (!(q < a.axisX.dataInfo.viewPortMin || q > a.axisX.dataInfo.viewPortMax && (!v.connectNullData || !C)))
                            if ("number" != typeof D.y) v.connectNullData || C || t || b(), C = !0;
                            else {
                                n = a.axisX.convertValueToPixel(q);
                                var E = h[q] ? h[q] : 0;
                                if (a.axisY.logarithmic) {
                                    if (l[q] = D.y + (l[q] ? l[q] : 0), 0 >= l[q]) continue;
                                    p = a.axisY.convertValueToPixel(l[q])
                                }
                                else p = a.axisY.convertValueToPixel(D.y), p -= E;
                                if (i.push({
                                        x: n
                                        , y: r - E
                                    }), h[q] = r - p, t || C ? (!t && v.connectNullData ? (c.setLineDash && (v._options.nullDataLineDashType || z === v.lineDashType && v.lineDashType !== v.nullDataLineDashType) && (c.stroke(), z = v.nullDataLineDashType, c.setLineDash(A)), c.lineTo(n, p), R && s.lineTo(n, p)) : (c.beginPath(), c.moveTo(n, p), R && (s.beginPath(), s.moveTo(n, p))), C = t = !1) : (c.lineTo(n, p), R && s.lineTo(n, p), 0 == m % 250 && (b(), c.moveTo(n, p), R && s.moveTo(n, p), i.push({
                                        x: n
                                        , y: r - E
                                    }))), m < w.length - 1 && (y !== (w[m].lineColor || x) || z !== (w[m].lineDashType || v.lineDashType)) && (b(), c.beginPath(), c.moveTo(n, p), i.push({
                                        x: n
                                        , y: r - E
                                    }), y = w[m].lineColor || x, c.strokeStyle = y, c.setLineDash && (w[m].lineDashType ? (z = w[m].lineDashType, c.setLineDash(o(z, v.lineThickness))) : (z = v.lineDashType, c.setLineDash(B)))), 0 <= v.dataPointIndexes[q]) {
                                    var F = v.dataPointIds[v.dataPointIndexes[q]];
                                    this._eventManager.objectMap[F] = {
                                        id: F
                                        , objectType: "dataPoint"
                                        , dataSeriesIndex: u
                                        , dataPointIndex: v.dataPointIndexes[q]
                                        , x1: n
                                        , y1: p
                                    }
                                }
                                0 <= v.dataPointIndexes[q] && 0 !== D.markerSize && (0 < D.markerSize || 0 < v.markerSize) && (q = v.getMarkerProperties(m, n, p, c), e.push(q), markerColor = k(F), R && e.push({
                                    x: n
                                    , y: p
                                    , ctx: s
                                    , type: q.type
                                    , size: q.size
                                    , color: markerColor
                                    , borderColor: markerColor
                                    , borderThickness: q.borderThickness
                                })), (D.indexLabel || v.indexLabel || D.indexLabelFormatter || v.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "stackedArea"
                                    , dataPoint: D
                                    , dataSeries: v
                                    , point: {
                                        x: n
                                        , y: p
                                    }
                                    , direction: 0 > w[m].y === a.axisY.reversed ? 1 : -1
                                    , color: d
                                })
                            }
                    }
                    b(), c.moveTo(n, p), R && s.moveTo(n, p)
                }
                delete v.dataPointIndexes
            }
            return ja.drawMarkers(e), c.restore(), R && s.restore(), {
                source: c
                , dest: this.plotArea.ctx
                , animationCallback: ia.xClipAnimation
                , easingFunction: ia.easing.linear
                , animationBase: 0
            }
        }
    }, A.prototype.renderStackedArea100 = function (a) {
        function b() {
            for (0 < v.lineThickness && c.stroke(); 0 < i.length;) {
                var a = i.pop();
                c.lineTo(a.x, a.y), R && s.lineTo(a.x, a.y)
            }
            c.closePath(), c.globalAlpha = v.fillOpacity, c.fill(), c.globalAlpha = 1, c.beginPath(), R && (s.closePath(), s.fill(), s.beginPath()), i = []
        }
        var c = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var n, p, q, d = null
                , e = this.plotArea
                , f = []
                , h = []
                , i = []
                , j = []
                , l = []
                , m = 0
                , r = a.axisY.convertValueToPixel(a.axisY.logarithmic ? a.axisY.viewportMinimum : 0)
                , s = this._eventManager.ghostCtx;
            c.save(), R && s.save(), c.beginPath(), c.rect(e.x1, e.y1, e.width, e.height), c.clip(), R && (s.beginPath(), s.rect(e.x1, e.y1, e.width, e.height), s.clip());
            for (var t = [], e = 0; e < a.dataSeriesIndexes.length; e++) {
                var u = a.dataSeriesIndexes[e]
                    , v = this.data[u]
                    , w = v.dataPoints;
                for (v.dataPointIndexes = [], m = 0; m < w.length; m++) u = w[m].x.getTime ? w[m].x.getTime() : w[m].x, v.dataPointIndexes[u] = m, t[u] || (j.push(u), t[u] = !0);
                j.sort(g)
            }
            for (e = 0; e < a.dataSeriesIndexes.length; e++) {
                if (u = a.dataSeriesIndexes[e], v = this.data[u], w = v.dataPoints, t = !0, d = v.id, this._eventManager.objectMap[d] = {
                        objectType: "dataSeries"
                        , dataSeriesIndex: u
                    }, d = k(d), s.fillStyle = d, i = [], 0 < j.length) {
                    var d = v._colorSet[m % v._colorSet.length]
                        , x = v._options.lineColor || d
                        , y = x;
                    c.fillStyle = d, c.strokeStyle = x, c.lineWidth = v.lineThickness;
                    var z = "solid";
                    if (c.setLineDash) {
                        var A = o(v.nullDataLineDashType, v.lineThickness)
                            , z = v.lineDashType
                            , B = o(z, v.lineThickness);
                        c.setLineDash(B)
                    }
                    for (var C = !0, m = 0; m < j.length; m++) {
                        q = j[m];
                        var D = null
                            , D = 0 <= v.dataPointIndexes[q] ? w[v.dataPointIndexes[q]] : {
                                x: q
                                , y: null
                            };
                        if (!(q < a.axisX.dataInfo.viewPortMin || q > a.axisX.dataInfo.viewPortMax && (!v.connectNullData || !C)))
                            if ("number" != typeof D.y) v.connectNullData || C || t || b(), C = !0;
                            else {
                                var E;
                                E = 0 !== a.dataPointYSums[q] ? 100 * (D.y / a.dataPointYSums[q]) : 0, n = a.axisX.convertValueToPixel(q);
                                var F = h[q] ? h[q] : 0;
                                if (a.axisY.logarithmic) {
                                    if (l[q] = E + (l[q] ? l[q] : 0), 0 >= l[q]) continue;
                                    p = a.axisY.convertValueToPixel(l[q])
                                }
                                else p = a.axisY.convertValueToPixel(E), p -= F;
                                if (i.push({
                                        x: n
                                        , y: r - F
                                    }), h[q] = r - p, t || C ? (!t && v.connectNullData ? (c.setLineDash && (v._options.nullDataLineDashType || z === v.lineDashType && v.lineDashType !== v.nullDataLineDashType) && (c.stroke(), z = v.nullDataLineDashType, c.setLineDash(A)), c.lineTo(n, p), R && s.lineTo(n, p)) : (c.beginPath(), c.moveTo(n, p), R && (s.beginPath(), s.moveTo(n, p))), C = t = !1) : (c.lineTo(n, p), R && s.lineTo(n, p), 0 == m % 250 && (b(), c.moveTo(n, p), R && s.moveTo(n, p), i.push({
                                        x: n
                                        , y: r - F
                                    }))), m < w.length - 1 && (y !== (w[m].lineColor || x) || z !== (w[m].lineDashType || v.lineDashType)) && (b(), c.beginPath(), c.moveTo(n, p), i.push({
                                        x: n
                                        , y: r - F
                                    }), y = w[m].lineColor || x, c.strokeStyle = y, c.setLineDash && (w[m].lineDashType ? (z = w[m].lineDashType, c.setLineDash(o(z, v.lineThickness))) : (z = v.lineDashType, c.setLineDash(B)))), 0 <= v.dataPointIndexes[q]) {
                                    var G = v.dataPointIds[v.dataPointIndexes[q]];
                                    this._eventManager.objectMap[G] = {
                                        id: G
                                        , objectType: "dataPoint"
                                        , dataSeriesIndex: u
                                        , dataPointIndex: v.dataPointIndexes[q]
                                        , x1: n
                                        , y1: p
                                    }
                                }
                                0 <= v.dataPointIndexes[q] && 0 !== D.markerSize && (0 < D.markerSize || 0 < v.markerSize) && (q = v.getMarkerProperties(m, n, p, c), f.push(q), markerColor = k(G), R && f.push({
                                    x: n
                                    , y: p
                                    , ctx: s
                                    , type: q.type
                                    , size: q.size
                                    , color: markerColor
                                    , borderColor: markerColor
                                    , borderThickness: q.borderThickness
                                })), (D.indexLabel || v.indexLabel || D.indexLabelFormatter || v.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "stackedArea100"
                                    , dataPoint: D
                                    , dataSeries: v
                                    , point: {
                                        x: n
                                        , y: p
                                    }
                                    , direction: 0 > w[m].y === a.axisY.reversed ? 1 : -1
                                    , color: d
                                })
                            }
                    }
                    b(), c.moveTo(n, p), R && s.moveTo(n, p)
                }
                delete v.dataPointIndexes
            }
            return ja.drawMarkers(f), c.restore(), R && s.restore(), {
                source: c
                , dest: this.plotArea.ctx
                , animationCallback: ia.xClipAnimation
                , easingFunction: ia.easing.linear
                , animationBase: 0
            }
        }
    }, A.prototype.renderBubble = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var e, f, c = this.plotArea
                , d = 0;
            b.save(), R && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(c.x1, c.y1, c.width, c.height), b.clip(), R && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());
            for (var g = -(1 / 0), h = 1 / 0, i = 0; i < a.dataSeriesIndexes.length; i++)
                for (var j = a.dataSeriesIndexes[i], l = this.data[j], m = l.dataPoints, n = 0, d = 0; d < m.length; d++) e = e = m[d].getTime ? m[d].x.getTime() : m[d].x, e < a.axisX.dataInfo.viewPortMin || e > a.axisX.dataInfo.viewPortMax || "undefined" == typeof m[d].z || (n = m[d].z, n > g && (g = n), n < h && (h = n));
            for (var o = 25 * Math.PI, c = Math.max(Math.pow(.25 * Math.min(c.height, c.width) / 2, 2) * Math.PI, o), i = 0; i < a.dataSeriesIndexes.length; i++)
                if (j = a.dataSeriesIndexes[i], l = this.data[j], m = l.dataPoints, 0 < m.length)
                    for (b.strokeStyle = "#4572A7 ", d = 0; d < m.length; d++)
                        if (e = e = m[d].getTime ? m[d].x.getTime() : m[d].x, !(e < a.axisX.dataInfo.viewPortMin || e > a.axisX.dataInfo.viewPortMax) && "number" == typeof m[d].y) {
                            e = a.axisX.convertValueToPixel(e), f = a.axisY.convertValueToPixel(m[d].y);
                            var n = m[d].z
                                , p = 2 * Math.max(Math.sqrt((g === h ? c / 2 : o + (c - o) / (g - h) * (n - h)) / Math.PI) << 0, 1)
                                , n = l.getMarkerProperties(d, b);
                            n.size = p, b.globalAlpha = l.fillOpacity, ja.drawMarker(e, f, b, n.type, n.size, n.color, n.borderColor, n.borderThickness), b.globalAlpha = 1;
                            var q = l.dataPointIds[d];
                            this._eventManager.objectMap[q] = {
                                id: q
                                , objectType: "dataPoint"
                                , dataSeriesIndex: j
                                , dataPointIndex: d
                                , x1: e
                                , y1: f
                                , size: p
                            }, p = k(q), R && ja.drawMarker(e, f, this._eventManager.ghostCtx, n.type, n.size, p, p, n.borderThickness), (m[d].indexLabel || l.indexLabel || m[d].indexLabelFormatter || l.indexLabelFormatter) && this._indexLabels.push({
                                chartType: "bubble"
                                , dataPoint: m[d]
                                , dataSeries: l
                                , point: {
                                    x: e
                                    , y: f
                                }
                                , direction: 1
                                , bounds: {
                                    x1: e - n.size / 2
                                    , y1: f - n.size / 2
                                    , x2: e + n.size / 2
                                    , y2: f + n.size / 2
                                }
                                , color: null
                            })
                        }
            return b.restore(), R && this._eventManager.ghostCtx.restore(), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.fadeInAnimation
                , easingFunction: ia.easing.easeInQuad
                , animationBase: 0
            }
        }
    }, A.prototype.renderScatter = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var e, f, c = this.plotArea
                , d = 0;
            b.save(), R && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(c.x1, c.y1, c.width, c.height), b.clip(), R && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.clip());
            for (var g = 0; g < a.dataSeriesIndexes.length; g++) {
                var h = a.dataSeriesIndexes[g]
                    , i = this.data[h]
                    , j = i.dataPoints;
                if (0 < j.length) {
                    b.strokeStyle = "#4572A7 ", Math.pow(.3 * Math.min(c.height, c.width) / 2, 2);
                    for (var l = 0, m = 0, d = 0; d < j.length; d++)
                        if (e = e = j[d].getTime ? j[d].x.getTime() : j[d].x, !(e < a.axisX.dataInfo.viewPortMin || e > a.axisX.dataInfo.viewPortMax) && "number" == typeof j[d].y) {
                            e = a.axisX.convertValueToPixel(e), f = a.axisY.convertValueToPixel(j[d].y);
                            var n = i.getMarkerProperties(d, e, f, b);
                            b.globalAlpha = i.fillOpacity, ja.drawMarker(n.x, n.y, n.ctx, n.type, n.size, n.color, n.borderColor, n.borderThickness), b.globalAlpha = 1, Math.sqrt((l - e) * (l - e) + (m - f) * (m - f)) < Math.min(n.size, 5) && j.length > Math.min(this.plotArea.width, this.plotArea.height) || (l = i.dataPointIds[d], this._eventManager.objectMap[l] = {
                                id: l
                                , objectType: "dataPoint"
                                , dataSeriesIndex: h
                                , dataPointIndex: d
                                , x1: e
                                , y1: f
                            }, l = k(l), R && ja.drawMarker(n.x, n.y, this._eventManager.ghostCtx, n.type, n.size, l, l, n.borderThickness), (j[d].indexLabel || i.indexLabel || j[d].indexLabelFormatter || i.indexLabelFormatter) && this._indexLabels.push({
                                chartType: "scatter"
                                , dataPoint: j[d]
                                , dataSeries: i
                                , point: {
                                    x: e
                                    , y: f
                                }
                                , direction: 1
                                , bounds: {
                                    x1: e - n.size / 2
                                    , y1: f - n.size / 2
                                    , x2: e + n.size / 2
                                    , y2: f + n.size / 2
                                }
                                , color: null
                            }), l = e, m = f)
                        }
                }
            }
            return b.restore(), R && this._eventManager.ghostCtx.restore(), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.fadeInAnimation
                , easingFunction: ia.easing.easeInQuad
                , animationBase: 0
            }
        }
    }, A.prototype.renderCandlestick = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx
            , c = this._eventManager.ghostCtx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var f, g, h, i, j, l, d = null
                , d = this.plotArea
                , e = 0
                , e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
            f = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .015 * this.width;
            var m = a.axisX.dataInfo.minDiff;
            isFinite(m) || (m = .3 * Math.abs(a.axisX.range)), m = this.dataPointWidth ? this.dataPointWidth : .7 * d.width * (a.axisX.logarithmic ? Math.log(m) / Math.log(a.axisX.range) : Math.abs(m) / Math.abs(a.axisX.range)) << 0, this.dataPointMaxWidth && e > f && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, f)), !this.dataPointMaxWidth && this.dataPointMinWidth && f < e && (f = Math.max(this.dataPointWidth ? this.dataPointWidth : -(1 / 0), e)), m < e && (m = e), m > f && (m = f), b.save(), R && c.save(), b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(), R && (c.beginPath(), c.rect(d.x1, d.y1, d.width, d.height), c.clip());
            for (var n = 0; n < a.dataSeriesIndexes.length; n++) {
                var o = a.dataSeriesIndexes[n]
                    , p = this.data[o]
                    , q = p.dataPoints;
                if (0 < q.length)
                    for (var r = !!(5 < m && p.bevelEnabled), e = 0; e < q.length; e++)
                        if (l = q[e].getTime ? q[e].x.getTime() : q[e].x, !(l < a.axisX.dataInfo.viewPortMin || l > a.axisX.dataInfo.viewPortMax) && null !== q[e].y && q[e].y.length && "number" == typeof q[e].y[0] && "number" == typeof q[e].y[1] && "number" == typeof q[e].y[2] && "number" == typeof q[e].y[3]) {
                            f = a.axisX.convertValueToPixel(l), g = a.axisY.convertValueToPixel(q[e].y[0]), h = a.axisY.convertValueToPixel(q[e].y[1]), i = a.axisY.convertValueToPixel(q[e].y[2]), j = a.axisY.convertValueToPixel(q[e].y[3]);
                            var s = f - m / 2 << 0
                                , t = s + m << 0
                                , d = q[e].color ? q[e].color : p._colorSet[0]
                                , u = Math.round(Math.max(1, .15 * m))
                                , v = 0 === u % 2 ? 0 : .5
                                , w = p.dataPointIds[e];
                            this._eventManager.objectMap[w] = {
                                id: w
                                , objectType: "dataPoint"
                                , dataSeriesIndex: o
                                , dataPointIndex: e
                                , x1: s
                                , y1: g
                                , x2: t
                                , y2: h
                                , x3: f
                                , y3: i
                                , x4: f
                                , y4: j
                                , borderThickness: u
                                , color: d
                            }, b.strokeStyle = d, b.beginPath(), b.lineWidth = u, c.lineWidth = Math.max(u, 4), "candlestick" === p.type ? (b.moveTo(f - v, h), b.lineTo(f - v, Math.min(g, j)), b.stroke(), b.moveTo(f - v, Math.max(g, j)), b.lineTo(f - v, i), b.stroke(), ga(b, s, Math.min(g, j), t, Math.max(g, j), q[e].y[0] <= q[e].y[3] ? p.risingColor : d, u, d, r, r, !1, !1, p.fillOpacity), R && (d = k(w), c.strokeStyle = d, c.moveTo(f - v, h), c.lineTo(f - v, Math.min(g, j)), c.stroke(), c.moveTo(f - v, Math.max(g, j)), c.lineTo(f - v, i), c.stroke(), ga(c, s, Math.min(g, j), t, Math.max(g, j), d, 0, null, !1, !1, !1, !1))) : "ohlc" === p.type && (b.moveTo(f - v, h), b.lineTo(f - v, i), b.stroke(), b.beginPath(), b.moveTo(f, g), b.lineTo(s, g), b.stroke(), b.beginPath(), b.moveTo(f, j), b.lineTo(t, j), b.stroke(), R && (d = k(w), c.strokeStyle = d, c.moveTo(f - v, h), c.lineTo(f - v, i), c.stroke(), c.beginPath(), c.moveTo(f, g), c.lineTo(s, g), c.stroke(), c.beginPath(), c.moveTo(f, j), c.lineTo(t, j), c.stroke())), (q[e].indexLabel || p.indexLabel || q[e].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({
                                chartType: p.type
                                , dataPoint: q[e]
                                , dataSeries: p
                                , point: {
                                    x: s + (t - s) / 2
                                    , y: a.axisY.reversed ? i : h
                                }
                                , direction: 1
                                , bounds: {
                                    x1: s
                                    , y1: Math.min(h, i)
                                    , x2: t
                                    , y2: Math.max(h, i)
                                }
                                , color: d
                            })
                        }
            }
            return b.restore(), R && c.restore(), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.fadeInAnimation
                , easingFunction: ia.easing.easeInQuad
                , animationBase: 0
            }
        }
    }, A.prototype.renderRangeColumn = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var f, g, c = null
                , d = this.plotArea
                , e = 0
                , e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
            f = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : .03 * this.width;
            var h = a.axisX.dataInfo.minDiff;
            isFinite(h) || (h = .3 * Math.abs(a.axisX.range)), h = this.dataPointWidth ? this.dataPointWidth : .9 * (d.width * (a.axisX.logarithmic ? Math.log(h) / Math.log(a.axisX.range) : Math.abs(h) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0, this.dataPointMaxWidth && e > f && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, f)), !this.dataPointMaxWidth && this.dataPointMinWidth && f < e && (f = Math.max(this.dataPointWidth ? this.dataPointWidth : -(1 / 0), e)), h < e && (h = e), h > f && (h = f), b.save(), R && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(), R && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip());
            for (var i = 0; i < a.dataSeriesIndexes.length; i++) {
                var j = a.dataSeriesIndexes[i]
                    , l = this.data[j]
                    , m = l.dataPoints;
                if (0 < m.length)
                    for (var n = !!(5 < h && l.bevelEnabled), e = 0; e < m.length; e++)
                        if (g = m[e].getTime ? m[e].x.getTime() : m[e].x, !(g < a.axisX.dataInfo.viewPortMin || g > a.axisX.dataInfo.viewPortMax) && null !== m[e].y && m[e].y.length && "number" == typeof m[e].y[0] && "number" == typeof m[e].y[1]) {
                            c = a.axisX.convertValueToPixel(g), d = a.axisY.convertValueToPixel(m[e].y[0]), f = a.axisY.convertValueToPixel(m[e].y[1]);
                            var o = a.axisX.reversed ? c + a.plotType.totalDataSeries * h / 2 - (a.previousDataSeriesCount + i) * h << 0 : c - a.plotType.totalDataSeries * h / 2 + (a.previousDataSeriesCount + i) * h << 0
                                , p = a.axisX.reversed ? o - h << 0 : o + h << 0
                                , c = m[e].color ? m[e].color : l._colorSet[e % l._colorSet.length];
                            if (d > f) {
                                var q = d
                                    , d = f;
                                f = q
                            }
                            q = l.dataPointIds[e], this._eventManager.objectMap[q] = {
                                id: q
                                , objectType: "dataPoint"
                                , dataSeriesIndex: j
                                , dataPointIndex: e
                                , x1: o
                                , y1: d
                                , x2: p
                                , y2: f
                            }, ga(b, o, d, p, f, c, 0, c, n, n, !1, !1, l.fillOpacity), c = k(q), R && ga(this._eventManager.ghostCtx, o, d, p, f, c, 0, null, !1, !1, !1, !1), (m[e].indexLabel || l.indexLabel || m[e].indexLabelFormatter || l.indexLabelFormatter) && (this._indexLabels.push({
                                chartType: "rangeColumn"
                                , dataPoint: m[e]
                                , dataSeries: l
                                , indexKeyword: 0
                                , point: {
                                    x: o + (p - o) / 2
                                    , y: m[e].y[1] >= m[e].y[0] ? f : d
                                }
                                , direction: m[e].y[1] >= m[e].y[0] ? -1 : 1
                                , bounds: {
                                    x1: o
                                    , y1: Math.min(d, f)
                                    , x2: p
                                    , y2: Math.max(d, f)
                                }
                                , color: c
                            }), this._indexLabels.push({
                                chartType: "rangeColumn"
                                , dataPoint: m[e]
                                , dataSeries: l
                                , indexKeyword: 1
                                , point: {
                                    x: o + (p - o) / 2
                                    , y: m[e].y[1] >= m[e].y[0] ? d : f
                                }
                                , direction: m[e].y[1] >= m[e].y[0] ? 1 : -1
                                , bounds: {
                                    x1: o
                                    , y1: Math.min(d, f)
                                    , x2: p
                                    , y2: Math.max(d, f)
                                }
                                , color: c
                            }))
                        }
            }
            return b.restore(), R && this._eventManager.ghostCtx.restore(), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.fadeInAnimation
                , easingFunction: ia.easing.easeInQuad
                , animationBase: 0
            }
        }
    }, A.prototype.renderRangeBar = function (a) {
        var b = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var f, g, h, c = null
                , d = this.plotArea
                , e = 0
                , e = this.dataPointMinWidth ? this.dataPointMinWidth : this.dataPointWidth ? this.dataPointWidth : 1;
            f = this.dataPointMaxWidth ? this.dataPointMaxWidth : this.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.height, .9 * (this.plotArea.height / a.plotType.totalDataSeries)) << 0;
            var i = a.axisX.dataInfo.minDiff;
            isFinite(i) || (i = .3 * Math.abs(a.axisX.range)), i = this.dataPointWidth ? this.dataPointWidth : .9 * (d.height * (a.axisX.logarithmic ? Math.log(i) / Math.log(a.axisX.range) : Math.abs(i) / Math.abs(a.axisX.range)) / a.plotType.totalDataSeries) << 0, this.dataPointMaxWidth && e > f && (e = Math.min(this.dataPointWidth ? this.dataPointWidth : 1 / 0, f)), !this.dataPointMaxWidth && this.dataPointMinWidth && f < e && (f = Math.max(this.dataPointWidth ? this.dataPointWidth : -(1 / 0), e)), i < e && (i = e), i > f && (i = f), b.save(), R && this._eventManager.ghostCtx.save(), b.beginPath(), b.rect(d.x1, d.y1, d.width, d.height), b.clip(), R && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(d.x1, d.y1, d.width, d.height), this._eventManager.ghostCtx.clip());
            for (var j = 0; j < a.dataSeriesIndexes.length; j++) {
                var l = a.dataSeriesIndexes[j]
                    , m = this.data[l]
                    , n = m.dataPoints;
                if (0 < n.length) {
                    var o = !!(5 < i && m.bevelEnabled);
                    for (b.strokeStyle = "#4572A7 ", e = 0; e < n.length; e++)
                        if (h = n[e].getTime ? n[e].x.getTime() : n[e].x, !(h < a.axisX.dataInfo.viewPortMin || h > a.axisX.dataInfo.viewPortMax) && null !== n[e].y && n[e].y.length && "number" == typeof n[e].y[0] && "number" == typeof n[e].y[1]) {
                            d = a.axisY.convertValueToPixel(n[e].y[0]), f = a.axisY.convertValueToPixel(n[e].y[1]), g = a.axisX.convertValueToPixel(h), g = a.axisX.reversed ? g + a.plotType.totalDataSeries * i / 2 - (a.previousDataSeriesCount + j) * i << 0 : g - a.plotType.totalDataSeries * i / 2 + (a.previousDataSeriesCount + j) * i << 0;
                            var p = a.axisX.reversed ? g - i << 0 : g + i << 0;
                            d > f && (c = d, d = f, f = c), c = n[e].color ? n[e].color : m._colorSet[e % m._colorSet.length], ga(b, d, g, f, p, c, 0, null, o, !1, !1, !1, m.fillOpacity), c = m.dataPointIds[e], this._eventManager.objectMap[c] = {
                                id: c
                                , objectType: "dataPoint"
                                , dataSeriesIndex: l
                                , dataPointIndex: e
                                , x1: d
                                , y1: g
                                , x2: f
                                , y2: p
                            }, c = k(c), R && ga(this._eventManager.ghostCtx, d, g, f, p, c, 0, null, !1, !1, !1, !1), (n[e].indexLabel || m.indexLabel || n[e].indexLabelFormatter || m.indexLabelFormatter) && (this._indexLabels.push({
                                chartType: "rangeBar"
                                , dataPoint: n[e]
                                , dataSeries: m
                                , indexKeyword: 0
                                , point: {
                                    x: n[e].y[1] >= n[e].y[0] ? d : f
                                    , y: g + (p - g) / 2
                                }
                                , direction: n[e].y[1] >= n[e].y[0] ? -1 : 1
                                , bounds: {
                                    x1: Math.min(d, f)
                                    , y1: g
                                    , x2: Math.max(d, f)
                                    , y2: p
                                }
                                , color: c
                            }), this._indexLabels.push({
                                chartType: "rangeBar"
                                , dataPoint: n[e]
                                , dataSeries: m
                                , indexKeyword: 1
                                , point: {
                                    x: n[e].y[1] >= n[e].y[0] ? f : d
                                    , y: g + (p - g) / 2
                                }
                                , direction: n[e].y[1] >= n[e].y[0] ? 1 : -1
                                , bounds: {
                                    x1: Math.min(d, f)
                                    , y1: g
                                    , x2: Math.max(d, f)
                                    , y2: p
                                }
                                , color: c
                            }))
                        }
                }
            }
            return b.restore(), R && this._eventManager.ghostCtx.restore(), {
                source: b
                , dest: this.plotArea.ctx
                , animationCallback: ia.fadeInAnimation
                , easingFunction: ia.easing.easeInQuad
                , animationBase: 0
            }
        }
    }, A.prototype.renderRangeArea = function (a) {
        function b() {
            if (s) {
                var a = null;
                0 < i.lineThickness && c.stroke();
                for (var b = g.length - 1; 0 <= b; b--) a = g[b], c.lineTo(a.x, a.y), d.lineTo(a.x, a.y);
                if (c.closePath(), c.globalAlpha = i.fillOpacity, c.fill(), c.globalAlpha = 1, d.fill(), 0 < i.lineThickness) {
                    for (c.beginPath(), c.moveTo(a.x, a.y), b = 0; b < g.length; b++) a = g[b], c.lineTo(a.x, a.y);
                    c.stroke()
                }
                c.beginPath(), c.moveTo(n, p), d.beginPath(), d.moveTo(n, p), s = {
                    x: n
                    , y: p
                }, g = [], g.push({
                    x: n
                    , y: q
                })
            }
        }
        var c = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = this._eventManager.ghostCtx
                , e = []
                , f = this.plotArea;
            for (c.save(), R && d.save(), c.beginPath(), c.rect(f.x1, f.y1, f.width, f.height), c.clip(), R && (d.beginPath(), d.rect(f.x1, f.y1, f.width, f.height), d.clip()), f = 0; f < a.dataSeriesIndexes.length; f++) {
                var g = []
                    , h = a.dataSeriesIndexes[f]
                    , i = this.data[h]
                    , j = i.dataPoints
                    , e = i.id;
                this._eventManager.objectMap[e] = {
                    objectType: "dataSeries"
                    , dataSeriesIndex: h
                }, e = k(e), d.fillStyle = e;
                var n, p, q, r, e = []
                    , l = !0
                    , m = 0
                    , s = null;
                if (0 < j.length) {
                    var t = i._colorSet[m % i._colorSet.length]
                        , u = i._options.lineColor || t
                        , v = u;
                    c.fillStyle = t, c.strokeStyle = u, c.lineWidth = i.lineThickness;
                    var w = "solid";
                    if (c.setLineDash) {
                        var x = o(i.nullDataLineDashType, i.lineThickness)
                            , w = i.lineDashType
                            , y = o(w, i.lineThickness);
                        c.setLineDash(y)
                    }
                    for (var z = !0; m < j.length; m++)
                        if (r = j[m].x.getTime ? j[m].x.getTime() : j[m].x, !(r < a.axisX.dataInfo.viewPortMin || r > a.axisX.dataInfo.viewPortMax && (!i.connectNullData || !z)))
                            if (null !== j[m].y && j[m].y.length && "number" == typeof j[m].y[0] && "number" == typeof j[m].y[1]) {
                                if (n = a.axisX.convertValueToPixel(r), p = a.axisY.convertValueToPixel(j[m].y[0]), q = a.axisY.convertValueToPixel(j[m].y[1]), l || z ? (i.connectNullData && !l ? (c.setLineDash && (i._options.nullDataLineDashType || w === i.lineDashType && i.lineDashType !== i.nullDataLineDashType) && (g[g.length - 1].newLineDashArray = y, w = i.nullDataLineDashType, c.setLineDash(x)), c.lineTo(n, p), R && d.lineTo(n, p), g.push({
                                        x: n
                                        , y: q
                                    })) : (c.beginPath(), c.moveTo(n, p), s = {
                                        x: n
                                        , y: p
                                    }, g = [], g.push({
                                        x: n
                                        , y: q
                                    }), R && (d.beginPath(), d.moveTo(n, p))), z = l = !1) : (c.lineTo(n, p), g.push({
                                        x: n
                                        , y: q
                                    }), R && d.lineTo(n, p), 0 == m % 250 && b()), r = i.dataPointIds[m], this._eventManager.objectMap[r] = {
                                        id: r
                                        , objectType: "dataPoint"
                                        , dataSeriesIndex: h
                                        , dataPointIndex: m
                                        , x1: n
                                        , y1: p
                                        , y2: q
                                    }, m < j.length - 1 && (v !== (j[m].lineColor || u) || w !== (j[m].lineDashType || i.lineDashType)) && (b(), v = j[m].lineColor || u, g[g.length - 1].newStrokeStyle = v, c.strokeStyle = v, c.setLineDash && (j[m].lineDashType ? (w = j[m].lineDashType, g[g.length - 1].newLineDashArray = o(w, i.lineThickness), c.setLineDash(g[g.length - 1].newLineDashArray)) : (w = i.lineDashType, g[g.length - 1].newLineDashArray = y, c.setLineDash(y)))), 0 !== j[m].markerSize && (0 < j[m].markerSize || 0 < i.markerSize)) {
                                    var A = i.getMarkerProperties(m, n, q, c);
                                    e.push(A);
                                    var B = k(r);
                                    R && e.push({
                                        x: n
                                        , y: q
                                        , ctx: d
                                        , type: A.type
                                        , size: A.size
                                        , color: B
                                        , borderColor: B
                                        , borderThickness: A.borderThickness
                                    }), A = i.getMarkerProperties(m, n, p, c), e.push(A), B = k(r), R && e.push({
                                        x: n
                                        , y: p
                                        , ctx: d
                                        , type: A.type
                                        , size: A.size
                                        , color: B
                                        , borderColor: B
                                        , borderThickness: A.borderThickness
                                    })
                                }(j[m].indexLabel || i.indexLabel || j[m].indexLabelFormatter || i.indexLabelFormatter) && (this._indexLabels.push({
                                    chartType: "rangeArea"
                                    , dataPoint: j[m]
                                    , dataSeries: i
                                    , indexKeyword: 0
                                    , point: {
                                        x: n
                                        , y: p
                                    }
                                    , direction: j[m].y[0] > j[m].y[1] === a.axisY.reversed ? -1 : 1
                                    , color: t
                                }), this._indexLabels.push({
                                    chartType: "rangeArea"
                                    , dataPoint: j[m]
                                    , dataSeries: i
                                    , indexKeyword: 1
                                    , point: {
                                        x: n
                                        , y: q
                                    }
                                    , direction: j[m].y[0] > j[m].y[1] === a.axisY.reversed ? 1 : -1
                                    , color: t
                                }))
                            }
                            else z || l || b(), z = !0;
                    b(), ja.drawMarkers(e)
                }
            }
            return c.restore(), R && this._eventManager.ghostCtx.restore(), {
                source: c
                , dest: this.plotArea.ctx
                , animationCallback: ia.xClipAnimation
                , easingFunction: ia.easing.linear
                , animationBase: 0
            }
        }
    }, A.prototype.renderRangeSplineArea = function (a) {
        function b(a, b) {
            var e = B(p, 2);
            if (0 < e.length) {
                if (0 < h.lineThickness) {
                    c.strokeStyle = b, c.setLineDash && c.setLineDash(a), c.beginPath(), c.moveTo(e[0].x, e[0].y);
                    for (var f = 0; f < e.length - 3; f += 3)(e[f].newStrokeStyle || e[f].newLineDashArray) && (c.stroke(), c.beginPath(), c.moveTo(e[f].x, e[f].y), e[f].newStrokeStyle && (c.strokeStyle = e[f].newStrokeStyle), e[f].newLineDashArray && c.setLineDash(e[f].newLineDashArray)), c.bezierCurveTo(e[f + 1].x, e[f + 1].y, e[f + 2].x, e[f + 2].y, e[f + 3].x, e[f + 3].y);
                    c.stroke()
                }
                for (c.beginPath(), c.moveTo(e[0].x, e[0].y), R && (d.beginPath(), d.moveTo(e[0].x, e[0].y)), f = 0; f < e.length - 3; f += 3) c.bezierCurveTo(e[f + 1].x, e[f + 1].y, e[f + 2].x, e[f + 2].y, e[f + 3].x, e[f + 3].y), R && d.bezierCurveTo(e[f + 1].x, e[f + 1].y, e[f + 2].x, e[f + 2].y, e[f + 3].x, e[f + 3].y);
                for (e = B(q, 2), c.lineTo(q[q.length - 1].x, q[q.length - 1].y), f = e.length - 1; 2 < f; f -= 3) c.bezierCurveTo(e[f - 1].x, e[f - 1].y, e[f - 2].x, e[f - 2].y, e[f - 3].x, e[f - 3].y), R && d.bezierCurveTo(e[f - 1].x, e[f - 1].y, e[f - 2].x, e[f - 2].y, e[f - 3].x, e[f - 3].y);
                if (c.closePath(), c.globalAlpha = h.fillOpacity, c.fill(), R && (d.closePath(), d.fill()), c.globalAlpha = 1, 0 < h.lineThickness) {
                    c.strokeStyle = b, c.setLineDash && c.setLineDash(a), c.beginPath(), c.moveTo(e[0].x, e[0].y);
                    for (var g = f = 0; f < e.length - 3; f += 3, g++)(p[g].newStrokeStyle || p[g].newLineDashArray) && (c.stroke(), c.beginPath(), c.moveTo(e[f].x, e[f].y), p[g].newStrokeStyle && (c.strokeStyle = p[g].newStrokeStyle), p[g].newLineDashArray && c.setLineDash(p[g].newLineDashArray)), c.bezierCurveTo(e[f + 1].x, e[f + 1].y, e[f + 2].x, e[f + 2].y, e[f + 3].x, e[f + 3].y);
                    c.stroke()
                }
                c.beginPath()
            }
        }
        var c = a.targetCanvasCtx || this.plotArea.ctx;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var d = this._eventManager.ghostCtx
                , e = []
                , f = this.plotArea;
            for (c.save(), R && d.save(), c.beginPath(), c.rect(f.x1, f.y1, f.width, f.height), c.clip(), R && (d.beginPath(), d.rect(f.x1, f.y1, f.width, f.height), d.clip()), f = 0; f < a.dataSeriesIndexes.length; f++) {
                var g = a.dataSeriesIndexes[f]
                    , h = this.data[g]
                    , i = h.dataPoints
                    , e = h.id;
                this._eventManager.objectMap[e] = {
                    objectType: "dataSeries"
                    , dataSeriesIndex: g
                }, e = k(e), d.fillStyle = e;
                var l, m, n, e = []
                    , j = 0
                    , p = []
                    , q = [];
                if (0 < i.length) {
                    var r = h._colorSet[j % h._colorSet.length]
                        , s = h._options.lineColor || r
                        , t = s;
                    c.fillStyle = r, c.lineWidth = h.lineThickness;
                    var v, u = "solid";
                    if (c.setLineDash) {
                        var w = o(h.nullDataLineDashType, h.lineThickness)
                            , u = h.lineDashType;
                        v = o(u, h.lineThickness)
                    }
                    for (m = !1; j < i.length; j++)
                        if (l = i[j].x.getTime ? i[j].x.getTime() : i[j].x, !(l < a.axisX.dataInfo.viewPortMin || l > a.axisX.dataInfo.viewPortMax && (!h.connectNullData || !m)))
                            if (null !== i[j].y && i[j].y.length && "number" == typeof i[j].y[0] && "number" == typeof i[j].y[1]) {
                                l = a.axisX.convertValueToPixel(l), m = a.axisY.convertValueToPixel(i[j].y[0]), n = a.axisY.convertValueToPixel(i[j].y[1]);
                                var x = h.dataPointIds[j];
                                if (this._eventManager.objectMap[x] = {
                                        id: x
                                        , objectType: "dataPoint"
                                        , dataSeriesIndex: g
                                        , dataPointIndex: j
                                        , x1: l
                                        , y1: m
                                        , y2: n
                                    }, p[p.length] = {
                                        x: l
                                        , y: m
                                    }, q[q.length] = {
                                        x: l
                                        , y: n
                                    }, j < i.length - 1 && (t !== (i[j].lineColor || s) || u !== (i[j].lineDashType || h.lineDashType)) && (t = i[j].lineColor || s, p[p.length - 1].newStrokeStyle = t, c.setLineDash && (i[j].lineDashType ? (u = i[j].lineDashType, p[p.length - 1].newLineDashArray = o(u, h.lineThickness)) : (u = h.lineDashType, p[p.length - 1].newLineDashArray = v))), 0 !== i[j].markerSize && (0 < i[j].markerSize || 0 < h.markerSize)) {
                                    var y = h.getMarkerProperties(j, l, m, c);
                                    e.push(y);
                                    var z = k(x);
                                    R && e.push({
                                        x: l
                                        , y: m
                                        , ctx: d
                                        , type: y.type
                                        , size: y.size
                                        , color: z
                                        , borderColor: z
                                        , borderThickness: y.borderThickness
                                    }), y = h.getMarkerProperties(j, l, n, c), e.push(y), z = k(x), R && e.push({
                                        x: l
                                        , y: n
                                        , ctx: d
                                        , type: y.type
                                        , size: y.size
                                        , color: z
                                        , borderColor: z
                                        , borderThickness: y.borderThickness
                                    })
                                }(i[j].indexLabel || h.indexLabel || i[j].indexLabelFormatter || h.indexLabelFormatter) && (this._indexLabels.push({
                                    chartType: "splineArea"
                                    , dataPoint: i[j]
                                    , dataSeries: h
                                    , indexKeyword: 0
                                    , point: {
                                        x: l
                                        , y: m
                                    }
                                    , direction: i[j].y[0] <= i[j].y[1] ? -1 : 1
                                    , color: r
                                }), this._indexLabels.push({
                                    chartType: "splineArea"
                                    , dataPoint: i[j]
                                    , dataSeries: h
                                    , indexKeyword: 1
                                    , point: {
                                        x: l
                                        , y: n
                                    }
                                    , direction: i[j].y[0] <= i[j].y[1] ? 1 : -1
                                    , color: r
                                })), m = !1
                            }
                            else 0 < j && !m && (h.connectNullData ? c.setLineDash && 0 < p.length && (h._options.nullDataLineDashType || !i[j - 1].lineDashType) && (p[p.length - 1].newLineDashArray = w, u = h.nullDataLineDashType) : (b(v, s), p = [], q = [])), m = !0;
                    b(v, s), ja.drawMarkers(e)
                }
            }
            return c.restore(), R && this._eventManager.ghostCtx.restore(), {
                source: c
                , dest: this.plotArea.ctx
                , animationCallback: ia.xClipAnimation
                , easingFunction: ia.easing.linear
                , animationBase: 0
            }
        }
    };
    var ha = function (a, b, c, d, e, f, g, h, i) {
        if (!(0 > c)) {
            if ("undefined" == typeof h && (h = 1), !R) {
                var j = Number((g % (2 * Math.PI)).toFixed(8));
                Number((f % (2 * Math.PI)).toFixed(8)) === j && (g -= 1e-4)
            }
            a.save(), a.globalAlpha = h, "pie" === e ? (a.beginPath(), a.moveTo(b.x, b.y), a.arc(b.x, b.y, c, f, g, !1), a.fillStyle = d, a.strokeStyle = "white", a.lineWidth = 2, a.closePath(), a.fill()) : "doughnut" === e && (a.beginPath(), a.arc(b.x, b.y, c, f, g, !1), 0 <= i && a.arc(b.x, b.y, i * c, g, f, !0), a.closePath(), a.fillStyle = d, a.strokeStyle = "white", a.lineWidth = 2, a.fill()), a.globalAlpha = 1, a.restore()
        }
    };
    A.prototype.renderPie = function (a) {
        function b() {
            if (j && k) {
                for (var a = 0, b = 0, c = 0, d = 0, e = 0; e < k.length; e++) {
                    var f = k[e]
                        , g = j.dataPointIds[e]
                        , h = {
                            id: g
                            , objectType: "dataPoint"
                            , dataPointIndex: e
                            , dataSeriesIndex: 0
                        };
                    p.push(h);
                    var l = {
                            percent: null
                            , total: null
                        }
                        , o = null
                        , l = i.getPercentAndTotal(j, f);
                    (j.indexLabelFormatter || f.indexLabelFormatter) && (o = {
                        chart: i._options
                        , dataSeries: j
                        , dataPoint: f
                        , total: l.total
                        , percent: l.percent
                    }), l = f.indexLabelFormatter ? f.indexLabelFormatter(o) : f.indexLabel ? i.replaceKeywordsWithValue(f.indexLabel, f, j, e) : j.indexLabelFormatter ? j.indexLabelFormatter(o) : j.indexLabel ? i.replaceKeywordsWithValue(j.indexLabel, f, j, e) : f.label ? f.label : "", i._eventManager.objectMap[g] = h, h.center = {
                        x: v.x
                        , y: v.y
                    }, h.y = f.y, h.radius = y, h.percentInnerRadius = A, h.indexLabelText = l, h.indexLabelPlacement = j.indexLabelPlacement, h.indexLabelLineColor = f.indexLabelLineColor ? f.indexLabelLineColor : j.indexLabelLineColor ? j.indexLabelLineColor : f.color ? f.color : j._colorSet[e % j._colorSet.length], h.indexLabelLineThickness = m(f.indexLabelLineThickness) ? j.indexLabelLineThickness : f.indexLabelLineThickness, h.indexLabelLineDashType = f.indexLabelLineDashType ? f.indexLabelLineDashType : j.indexLabelLineDashType, h.indexLabelFontColor = f.indexLabelFontColor ? f.indexLabelFontColor : j.indexLabelFontColor, h.indexLabelFontStyle = f.indexLabelFontStyle ? f.indexLabelFontStyle : j.indexLabelFontStyle, h.indexLabelFontWeight = f.indexLabelFontWeight ? f.indexLabelFontWeight : j.indexLabelFontWeight, h.indexLabelFontSize = f.indexLabelFontSize ? f.indexLabelFontSize : j.indexLabelFontSize, h.indexLabelFontFamily = f.indexLabelFontFamily ? f.indexLabelFontFamily : j.indexLabelFontFamily, h.indexLabelBackgroundColor = f.indexLabelBackgroundColor ? f.indexLabelBackgroundColor : j.indexLabelBackgroundColor ? j.indexLabelBackgroundColor : null, h.indexLabelMaxWidth = f.indexLabelMaxWidth ? f.indexLabelMaxWidth : j.indexLabelMaxWidth ? j.indexLabelMaxWidth : .33 * n.width, h.indexLabelWrap = "undefined" != typeof f.indexLabelWrap ? f.indexLabelWrap : j.indexLabelWrap, h.startAngle = 0 === e ? j.startAngle ? j.startAngle / 180 * Math.PI : 0 : p[e - 1].endAngle, h.startAngle = (h.startAngle + 2 * Math.PI) % (2 * Math.PI), h.endAngle = h.startAngle + 2 * Math.PI / w * Math.abs(f.y), f = (h.endAngle + h.startAngle) / 2, f = (f + 2 * Math.PI) % (2 * Math.PI), h.midAngle = f, h.midAngle > Math.PI / 2 - t && h.midAngle < Math.PI / 2 + t ? ((0 === a || p[c].midAngle > h.midAngle) && (c = e), a++) : h.midAngle > 3 * Math.PI / 2 - t && h.midAngle < 3 * Math.PI / 2 + t && ((0 === b || p[d].midAngle > h.midAngle) && (d = e), b++), h.hemisphere = f > Math.PI / 2 && f <= 3 * Math.PI / 2 ? "left" : "right", h.indexLabelTextBlock = new E(i.plotArea.ctx, {
                        fontSize: h.indexLabelFontSize
                        , fontFamily: h.indexLabelFontFamily
                        , fontColor: h.indexLabelFontColor
                        , fontStyle: h.indexLabelFontStyle
                        , fontWeight: h.indexLabelFontWeight
                        , horizontalAlign: "left"
                        , backgroundColor: h.indexLabelBackgroundColor
                        , maxWidth: h.indexLabelMaxWidth
                        , maxHeight: h.indexLabelWrap ? 5 * h.indexLabelFontSize : 1.5 * h.indexLabelFontSize
                        , text: h.indexLabelText
                        , padding: 0
                        , textBaseline: "top"
                    }), h.indexLabelTextBlock.measureText()
                }
                for (g = f = 0, l = !1, e = 0; e < k.length; e++) h = p[(c + e) % k.length], 1 < a && h.midAngle > Math.PI / 2 - t && h.midAngle < Math.PI / 2 + t && (f <= a / 2 && !l ? (h.hemisphere = "right", f++) : (h.hemisphere = "left", l = !0));
                for (l = !1, e = 0; e < k.length; e++) h = p[(d + e) % k.length], 1 < b && h.midAngle > 3 * Math.PI / 2 - t && h.midAngle < 3 * Math.PI / 2 + t && (g <= b / 2 && !l ? (h.hemisphere = "left", g++) : (h.hemisphere = "right", l = !0))
            }
        }

        function c(a) {
            var b = i.plotArea.ctx;
            for (b.clearRect(n.x1, n.y1, n.width, n.height), b.fillStyle = i.backgroundColor, b.fillRect(n.x1, n.y1, n.width, n.height), b = 0; b < k.length; b++) {
                var c = p[b].startAngle
                    , d = p[b].endAngle;
                if (d > c) {
                    var e = .07 * y * Math.cos(p[b].midAngle)
                        , f = .07 * y * Math.sin(p[b].midAngle)
                        , g = !1;
                    k[b].exploded ? (1e-9 < Math.abs(p[b].center.x - (v.x + e)) || 1e-9 < Math.abs(p[b].center.y - (v.y + f))) && (p[b].center.x = v.x + e * a, p[b].center.y = v.y + f * a, g = !0) : (0 < Math.abs(p[b].center.x - v.x) || 0 < Math.abs(p[b].center.y - v.y)) && (p[b].center.x = v.x + e * (1 - a), p[b].center.y = v.y + f * (1 - a), g = !0), g && (e = {}, e.dataSeries = j, e.dataPoint = j.dataPoints[b], e.index = b, i._toolTip.highlightObjects([e])), ha(i.plotArea.ctx, p[b].center, p[b].radius, k[b].color ? k[b].color : j._colorSet[b % j._colorSet.length], j.type, c, d, j.fillOpacity, p[b].percentInnerRadius)
                }
            }
            for (a = i.plotArea.ctx, a.save(), a.fillStyle = "black", a.strokeStyle = "grey", a.textBaseline = "middle", a.lineJoin = "round", b = b = 0; b < k.length; b++) c = p[b], c.indexLabelText && (c.indexLabelTextBlock.y -= c.indexLabelTextBlock.height / 2, d = 0, d = "left" === c.hemisphere ? "inside" !== j.indexLabelPlacement ? -(c.indexLabelTextBlock.width + l) : -c.indexLabelTextBlock.width / 2 : "inside" !== j.indexLabelPlacement ? l : -c.indexLabelTextBlock.width / 2, c.indexLabelTextBlock.x += d, c.indexLabelTextBlock.render(!0), c.indexLabelTextBlock.x -= d, c.indexLabelTextBlock.y += c.indexLabelTextBlock.height / 2, "inside" !== c.indexLabelPlacement && 0 < c.indexLabelLineThickness && (d = c.center.x + y * Math.cos(c.midAngle), e = c.center.y + y * Math.sin(c.midAngle), a.strokeStyle = c.indexLabelLineColor, a.lineWidth = c.indexLabelLineThickness, a.setLineDash && a.setLineDash(o(c.indexLabelLineDashType, c.indexLabelLineThickness)), a.beginPath(), a.moveTo(d, e), a.lineTo(c.indexLabelTextBlock.x, c.indexLabelTextBlock.y), a.lineTo(c.indexLabelTextBlock.x + ("left" === c.hemisphere ? -l : l), c.indexLabelTextBlock.y), a.stroke()), a.lineJoin = "miter");
            a.save()
        }

        function d(a, b) {
            var c = 0
                , c = a.indexLabelTextBlock.y - a.indexLabelTextBlock.height / 2
                , d = a.indexLabelTextBlock.y + a.indexLabelTextBlock.height / 2
                , e = b.indexLabelTextBlock.y - b.indexLabelTextBlock.height / 2
                , f = b.indexLabelTextBlock.y + b.indexLabelTextBlock.height / 2;
            return c = b.indexLabelTextBlock.y > a.indexLabelTextBlock.y ? e - d : c - f
        }

        function e(a) {
            for (var b = null, c = 1; c < k.length; c++) {
                if (b = (a + c + p.length) % p.length, p[b].hemisphere !== p[a].hemisphere) {
                    b = null;
                    break
                }
                if (p[b].indexLabelText && b !== a && (0 > d(p[b], p[a]) || ("right" === p[a].hemisphere ? p[b].indexLabelTextBlock.y >= p[a].indexLabelTextBlock.y : p[b].indexLabelTextBlock.y <= p[a].indexLabelTextBlock.y))) break;
                b = null
            }
            return b
        }

        function f(a, b, c) {
            if (c = (c || 0) + 1, 1e3 < c) return 0;
            b = b || 0;
            var g = 0
                , h = v.y - 1 * r
                , i = v.y + 1 * r;
            if (0 <= a && a < k.length) {
                var j = p[a];
                if (0 > b && j.indexLabelTextBlock.y < h || 0 < b && j.indexLabelTextBlock.y > i) return 0;
                var l = 0
                    , m = 0
                    , m = l = l = 0;
                for (0 > b ? j.indexLabelTextBlock.y - j.indexLabelTextBlock.height / 2 > h && j.indexLabelTextBlock.y - j.indexLabelTextBlock.height / 2 + b < h && (b = -(h - (j.indexLabelTextBlock.y - j.indexLabelTextBlock.height / 2 + b))) : j.indexLabelTextBlock.y + j.indexLabelTextBlock.height / 2 < h && j.indexLabelTextBlock.y + j.indexLabelTextBlock.height / 2 + b > i && (b = j.indexLabelTextBlock.y + j.indexLabelTextBlock.height / 2 + b - i), b = j.indexLabelTextBlock.y + b, h = 0, h = "right" === j.hemisphere ? v.x + Math.sqrt(Math.pow(r, 2) - Math.pow(b - v.y, 2)) : v.x - Math.sqrt(Math.pow(r, 2) - Math.pow(b - v.y, 2)), m = v.x + y * Math.cos(j.midAngle), l = v.y + y * Math.sin(j.midAngle), l = Math.sqrt(Math.pow(h - m, 2) + Math.pow(b - l, 2)), m = Math.acos(y / r), l = Math.acos((r * r + y * y - l * l) / (2 * y * r)), b = l < m ? b - j.indexLabelTextBlock.y : 0, h = null, i = 1; i < k.length; i++) {
                    if (h = (a - i + p.length) % p.length, p[h].hemisphere !== p[a].hemisphere) {
                        h = null;
                        break
                    }
                    if (p[h].indexLabelText && p[h].hemisphere === p[a].hemisphere && h !== a && (0 > d(p[h], p[a]) || ("right" === p[a].hemisphere ? p[h].indexLabelTextBlock.y <= p[a].indexLabelTextBlock.y : p[h].indexLabelTextBlock.y >= p[a].indexLabelTextBlock.y))) break;
                    h = null
                }
                m = h, l = e(a), i = h = 0, 0 > b ? (i = "right" === j.hemisphere ? m : l, g = b, null !== i && (m = -b, b = j.indexLabelTextBlock.y - j.indexLabelTextBlock.height / 2 - (p[i].indexLabelTextBlock.y + p[i].indexLabelTextBlock.height / 2), b - m < q && (h = -m, i = f(i, h, c + 1), +i.toFixed(u) > +h.toFixed(u) && (g = b > q ? -(b - q) : -(m - (i - h)))))) : 0 < b && (i = "right" === j.hemisphere ? l : m, g = b, null !== i && (m = b, b = p[i].indexLabelTextBlock.y - p[i].indexLabelTextBlock.height / 2 - (j.indexLabelTextBlock.y + j.indexLabelTextBlock.height / 2), b - m < q && (h = m, i = f(i, h, c + 1), +i.toFixed(u) < +h.toFixed(u) && (g = b > q ? b - q : m - (h - i))))), g && (c = j.indexLabelTextBlock.y + g, b = 0, b = "right" === j.hemisphere ? v.x + Math.sqrt(Math.pow(r, 2) - Math.pow(c - v.y, 2)) : v.x - Math.sqrt(Math.pow(r, 2) - Math.pow(c - v.y, 2)), j.midAngle > Math.PI / 2 - t && j.midAngle < Math.PI / 2 + t ? (h = (a - 1 + p.length) % p.length, h = p[h], a = p[(a + 1 + p.length) % p.length], "left" === j.hemisphere && "right" === h.hemisphere && b > h.indexLabelTextBlock.x ? b = h.indexLabelTextBlock.x - 15 : "right" === j.hemisphere && "left" === a.hemisphere && b < a.indexLabelTextBlock.x && (b = a.indexLabelTextBlock.x + 15)) : j.midAngle > 3 * Math.PI / 2 - t && j.midAngle < 3 * Math.PI / 2 + t && (h = (a - 1 + p.length) % p.length, h = p[h], a = p[(a + 1 + p.length) % p.length], "right" === j.hemisphere && "left" === h.hemisphere && b < h.indexLabelTextBlock.x ? b = h.indexLabelTextBlock.x + 15 : "left" === j.hemisphere && "right" === a.hemisphere && b > a.indexLabelTextBlock.x && (b = a.indexLabelTextBlock.x - 15)), j.indexLabelTextBlock.y = c, j.indexLabelTextBlock.x = b, j.indexLabelAngle = Math.atan2(j.indexLabelTextBlock.y - v.y, j.indexLabelTextBlock.x - v.x))
            }
            return g
        }

        function g() {
            var a = i.plotArea.ctx;
            a.fillStyle = "grey", a.strokeStyle = "grey", a.font = "16px Arial", a.textBaseline = "middle";
            for (var b = a = 0, c = 0, g = !0, b = 0; 10 > b && (1 > b || 0 < c); b++) {
                if ((j.radius || !j.radius && "undefined" != typeof j.innerRadius && null !== j.innerRadius && y - c <= z) && (g = !1), g && (y -= c), c = 0, "inside" !== j.indexLabelPlacement) {
                    for (r = y * s, a = 0; a < k.length; a++) {
                        var h = p[a];
                        h.indexLabelTextBlock.x = v.x + r * Math.cos(h.midAngle), h.indexLabelTextBlock.y = v.y + r * Math.sin(h.midAngle), h.indexLabelAngle = h.midAngle, h.radius = y, h.percentInnerRadius = A
                    }
                    for (var m, o, a = 0; a < k.length; a++) {
                        var h = p[a]
                            , t = e(a);
                        if (null !== t) {
                            m = p[a], o = p[t];
                            var w = 0
                                , w = d(m, o) - q;
                            if (0 > w) {
                                for (var x = o = 0, B = 0; B < k.length; B++) B !== a && p[B].hemisphere === h.hemisphere && (p[B].indexLabelTextBlock.y < h.indexLabelTextBlock.y ? o++ : x++);
                                o = w / (o + x || 1) * x;
                                var x = -1 * (w - o)
                                    , C = B = 0;
                                "right" === h.hemisphere ? (B = f(a, o), x = -1 * (w - B), C = f(t, x), +C.toFixed(u) < +x.toFixed(u) && +B.toFixed(u) <= +o.toFixed(u) && f(a, -(x - C))) : (B = f(t, o), x = -1 * (w - B), C = f(a, x), +C.toFixed(u) < +x.toFixed(u) && +B.toFixed(u) <= +o.toFixed(u) && f(t, -(x - C)))
                            }
                        }
                    }
                }
                else
                    for (a = 0; a < k.length; a++) h = p[a], r = "pie" === j.type ? .7 * y : .8 * y, t = v.x + r * Math.cos(h.midAngle), o = v.y + r * Math.sin(h.midAngle), h.indexLabelTextBlock.x = t, h.indexLabelTextBlock.y = o;
                for (a = 0; a < k.length; a++) h = p[a], t = h.indexLabelTextBlock.measureText(), 0 !== t.height && 0 !== t.width && (t = t = 0, "right" === h.hemisphere ? (t = n.x2 - (h.indexLabelTextBlock.x + h.indexLabelTextBlock.width + l), t *= -1) : t = n.x1 - (h.indexLabelTextBlock.x - h.indexLabelTextBlock.width - l), 0 < t && (!g && h.indexLabelText && (o = "right" === h.hemisphere ? n.x2 - h.indexLabelTextBlock.x : h.indexLabelTextBlock.x - n.x1, .3 * h.indexLabelTextBlock.maxWidth > o ? h.indexLabelText = "" : h.indexLabelTextBlock.maxWidth = .85 * o, .3 * h.indexLabelTextBlock.maxWidth < o && (h.indexLabelTextBlock.x -= "right" === h.hemisphere ? 2 : -2)), Math.abs(h.indexLabelTextBlock.y - h.indexLabelTextBlock.height / 2 - v.y) < y || Math.abs(h.indexLabelTextBlock.y + h.indexLabelTextBlock.height / 2 - v.y) < y) && (t /= Math.abs(Math.cos(h.indexLabelAngle)), 9 < t && (t *= .3), t > c && (c = t)), t = t = 0, 0 < h.indexLabelAngle && h.indexLabelAngle < Math.PI ? (t = n.y2 - (h.indexLabelTextBlock.y + h.indexLabelTextBlock.height / 2 + 5), t *= -1) : t = n.y1 - (h.indexLabelTextBlock.y - h.indexLabelTextBlock.height / 2 - 5), 0 < t && (!g && h.indexLabelText && (o = 0 < h.indexLabelAngle && h.indexLabelAngle < Math.PI ? -1 : 1, 0 === f(a, t * o) && f(a, 2 * o)), Math.abs(h.indexLabelTextBlock.x - v.x) < y && (t /= Math.abs(Math.sin(h.indexLabelAngle)), 9 < t && (t *= .3), t > c && (c = t))));
                var D = function (a, b, c) {
                    for (var d = [], e = 0; d.push(p[b]), b !== c; b = (b + 1 + k.length) % k.length);
                    for (d.sort(function (a, b) {
                            return a.y - b.y
                        }), b = 0; b < d.length && (c = d[b], e < .7 * a); b++) e += c.indexLabelTextBlock.height, c.indexLabelTextBlock.text = "", c.indexLabelText = "", c.indexLabelTextBlock.measureText()
                };
                ! function () {
                    for (var a = -1, b = -1, c = 0, f = !1, g = 0; g < k.length; g++)
                        if (f = !1, m = p[g], m.indexLabelText) {
                            var h = e(g);
                            if (null !== h) {
                                var i = p[h];
                                w = 0, w = d(m, i);
                                var j;
                                if (j = 0 > w) {
                                    j = m.indexLabelTextBlock.x;
                                    var n = m.indexLabelTextBlock.y - m.indexLabelTextBlock.height / 2
                                        , o = m.indexLabelTextBlock.y + m.indexLabelTextBlock.height / 2
                                        , q = i.indexLabelTextBlock.y - i.indexLabelTextBlock.height / 2
                                        , r = i.indexLabelTextBlock.x + i.indexLabelTextBlock.width
                                        , s = i.indexLabelTextBlock.y + i.indexLabelTextBlock.height / 2;
                                    j = !(m.indexLabelTextBlock.x + m.indexLabelTextBlock.width < i.indexLabelTextBlock.x - l || j > r + l || n > s + l || o < q - l)
                                }
                                j ? (0 > a && (a = g), h !== a && (b = h, c += -w), 0 === g % Math.max(k.length / 10, 3) && (f = !0)) : f = !0, f && 0 < c && 0 <= a && 0 <= b && (D(c, a, b), b = a = -1, c = 0)
                            }
                        }
                    0 < c && D(c, a, b)
                }()
            }
        }

        function h() {
            if (i.plotArea.layoutManager.reset(), i._title && (i._title.dockInsidePlotArea || "center" === i._title.horizontalAlign && "center" === i._title.verticalAlign) && i._title.render(), i.subtitles)
                for (var a = 0; a < i.subtitles.length; a++) {
                    var b = i.subtitles[a];
                    (b.dockInsidePlotArea || "center" === b.horizontalAlign && "center" === b.verticalAlign) && b.render()
                }
            i.legend && (i.legend.dockInsidePlotArea || "center" === i.legend.horizontalAlign && "center" === i.legend.verticalAlign) && i.legend.render()
        }
        var i = this;
        if (!(0 >= a.dataSeriesIndexes.length)) {
            var r, j = this.data[a.dataSeriesIndexes[0]]
                , k = j.dataPoints
                , l = 10
                , n = this.plotArea
                , p = []
                , q = 2
                , s = 1.3
                , t = 20 / 180 * Math.PI
                , u = 6
                , v = {
                    x: (n.x2 + n.x1) / 2
                    , y: (n.y2 + n.y1) / 2
                }
                , w = 0;
            a = !1;
            for (var x = 0; x < k.length; x++) w += Math.abs(k[x].y), !a && "undefined" != typeof k[x].indexLabel && null !== k[x].indexLabel && 0 < k[x].indexLabel.toString().length && (a = !0), !a && "undefined" != typeof k[x].label && null !== k[x].label && 0 < k[x].label.toString().length && (a = !0);
            if (0 !== w) {
                a = a || "undefined" != typeof j.indexLabel && null !== j.indexLabel && 0 < j.indexLabel.toString().length;
                var y = "inside" !== j.indexLabelPlacement && a ? .75 * Math.min(n.width, n.height) / 2 : .92 * Math.min(n.width, n.height) / 2;
                j.radius && (y = C(j.radius, y));
                var z = "undefined" != typeof j.innerRadius && null !== j.innerRadius ? C(j.innerRadius, y) : .7 * y
                    , A = Math.min(z / y, (y - 1) / y);
                this.pieDoughnutClickHandler = function (a) {
                    i.isAnimating || !m(a.dataSeries.explodeOnClick) && !a.dataSeries.explodeOnClick || (a = a.dataPoint, a.exploded = !a.exploded, 1 < this.dataPoints.length && i._animator.animate(0, 500, function (a) {
                        c(a), h()
                    }))
                }, b(), g(), g(), g(), g(), this.disableToolTip = !0, this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function (a) {
                    var b = i.plotArea.ctx;
                    for (b.clearRect(n.x1, n.y1, n.width, n.height), b.fillStyle = i.backgroundColor, b.fillRect(n.x1, n.y1, n.width, n.height), a = p[0].startAngle + 2 * Math.PI * a, b = 0; b < k.length; b++) {
                        var c = 0 === b ? p[b].startAngle : d
                            , d = c + (p[b].endAngle - p[b].startAngle)
                            , e = !1;
                        d > a && (d = a, e = !0);
                        var f = k[b].color ? k[b].color : j._colorSet[b % j._colorSet.length];
                        if (d > c && ha(i.plotArea.ctx, p[b].center, p[b].radius, f, j.type, c, d, j.fillOpacity, p[b].percentInnerRadius), e) break
                    }
                    h()
                }, function () {
                    i.disableToolTip = !1, i._animator.animate(0, i.animatedRender ? 500 : 0, function (a) {
                        c(a), h()
                    })
                })
            }
        }
    }, A.prototype.animationRequestId = null, A.prototype.requestAnimFrame = function () {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (a) {
            window.setTimeout(a, 1e3 / 60)
        }
    }(), A.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout, D.prototype.registerSpace = function (a, b) {
        "top" === a ? this._topOccupied += b.height : "bottom" === a ? this._bottomOccupied += b.height : "left" === a ? this._leftOccupied += b.width : "right" === a && (this._rightOccupied += b.width)
    }, D.prototype.unRegisterSpace = function (a, b) {
        "top" === a ? this._topOccupied -= b.height : "bottom" === a ? this._bottomOccupied -= b.height : "left" === a ? this._leftOccupied -= b.width : "right" === a && (this._rightOccupied -= b.width)
    }, D.prototype.getFreeSpace = function () {
        return {
            x1: this._x1 + this._leftOccupied
            , y1: this._y1 + this._topOccupied
            , x2: this._x2 - this._rightOccupied
            , y2: this._y2 - this._bottomOccupied
            , width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied
            , height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied
        }
    }, D.prototype.reset = function () {
        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding
    }, a(E, z), E.prototype.render = function (a) {
        a && this.ctx.save();
        var b = this.ctx.font;
        this.ctx.textBaseline = this.textBaseline;
        var c = 0;
        this._isDirty && this.measureText(this.ctx), this.ctx.translate(this.x, this.y + c), "middle" === this.textBaseline && (c = -this._lineHeight / 2), this.ctx.font = this._getFontString(), this.ctx.rotate(Math.PI / 180 * this.angle);
        var d = 0
            , e = this.padding
            , f = null;
        for ((0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, c, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor), this.ctx.fillStyle = this.fontColor, c = 0; c < this._wrappedText.lines.length; c++) f = this._wrappedText.lines[c], "right" === this.horizontalAlign ? d = this.width - f.width - this.padding : "left" === this.horizontalAlign ? d = this.padding : "center" === this.horizontalAlign && (d = (this.width - 2 * this.padding) / 2 - f.width / 2 + this.padding), this.ctx.fillText(f.text, d, e), e += f.height;
        this.ctx.font = b, a && this.ctx.restore()
    }, E.prototype.setText = function (a) {
        this.text = a, this._isDirty = !0, this._wrappedText = null
    }, E.prototype.measureText = function () {
        if (this._lineHeight = n(this.fontFamily, this.fontSize, this.fontWeight), null === this.maxWidth) throw "Please set maxWidth and height for TextBlock";
        return this._wrapText(this.ctx), this._isDirty = !1, {
            width: this.width
            , height: this.height
        }
    }, E.prototype._getLineWithWidth = function (a, b, c) {
        if (a = String(a), !a) return {
            text: ""
            , width: 0
        };
        var d = c = 0
            , e = a.length - 1
            , f = 1 / 0;
        for (this.ctx.font = this._getFontString(); d <= e;) {
            var f = Math.floor((d + e) / 2)
                , g = a.substr(0, f + 1);
            if (c = this.ctx.measureText(g).width, c < b) d = f + 1;
            else {
                if (!(c > b)) break;
                e = f - 1
            }
        }
        return c > b && 1 < g.length && (g = g.substr(0, g.length - 1), c = this.ctx.measureText(g).width), b = !0, g.length !== a.length && " " !== a[g.length] || (b = !1), b && (a = g.split(" "), 1 < a.length && a.pop(), g = a.join(" "), c = this.ctx.measureText(g).width), {
            text: g
            , width: c
        }
    }, E.prototype._wrapText = function () {
        var a = new String(e(String(this.text)))
            , b = []
            , c = this.ctx.font
            , d = 0
            , f = 0;
        for (this.ctx.font = this._getFontString(); 0 < a.length;) {
            var g = this.maxHeight - 2 * this.padding
                , h = this._getLineWithWidth(a, this.maxWidth - 2 * this.padding, !1);
            h.height = this._lineHeight, b.push(h);
            var i = f
                , f = Math.max(f, h.width)
                , d = d + h.height
                , a = e(a.slice(h.text.length, a.length));
            g && d > g && (h = b.pop(), d -= h.height, f = i)
        }
        this._wrappedText = {
            lines: b
            , width: f
            , height: d
        }, this.width = f + 2 * this.padding, this.height = d + 2 * this.padding, this.ctx.font = c
    }, E.prototype._getFontString = function () {
        var a;
        a = "" + (this.fontStyle ? this.fontStyle + " " : ""), a += this.fontWeight ? this.fontWeight + " " : "", a += this.fontSize ? this.fontSize + "px " : "";
        var b = this.fontFamily ? this.fontFamily + "" : "";
        return !R && b && (b = b.split(",")[0], "'" !== b[0] && '"' !== b[0] && (b = "'" + b + "'")), a += b
    }, a(F, z), F.prototype.render = function () {
        if (this.text) {
            var h, i, a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart
                , b = a.layoutManager.getFreeSpace()
                , c = b.x1
                , d = b.y1
                , e = 0
                , f = 0
                , g = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 22 : 0;
            "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = b.width - 4 - g * ("center" === this.horizontalAlign ? 2 : 1)), f = .5 * b.height - this.margin - 2, e = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = b.height - 4), f = .5 * b.width - this.margin - 2) : "center" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = b.width - 4), f = .5 * b.height - 4)), this.wrap || (f = Math.min(f, Math.max(1.5 * this.fontSize, this.fontSize + 2.5 * this.padding)));
            var f = new E(this.ctx, {
                    fontSize: this.fontSize
                    , fontFamily: this.fontFamily
                    , fontColor: this.fontColor
                    , fontStyle: this.fontStyle
                    , fontWeight: this.fontWeight
                    , horizontalAlign: this.horizontalAlign
                    , verticalAlign: this.verticalAlign
                    , borderColor: this.borderColor
                    , borderThickness: this.borderThickness
                    , backgroundColor: this.backgroundColor
                    , maxWidth: this.maxWidth
                    , maxHeight: f
                    , cornerRadius: this.cornerRadius
                    , text: this.text
                    , padding: this.padding
                    , textBaseline: "top"
                })
                , j = f.measureText();
            "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (d = b.y1 + 2, i = "top") : "bottom" === this.verticalAlign && (d = b.y2 - 2 - j.height, i = "bottom"), "left" === this.horizontalAlign ? c = b.x1 + 2 : "center" === this.horizontalAlign ? c = b.x1 + b.width / 2 - j.width / 2 : "right" === this.horizontalAlign && (c = b.x2 - 2 - j.width - g), h = this.horizontalAlign, this.width = j.width, this.height = j.height) : "center" === this.verticalAlign && ("left" === this.horizontalAlign ? (c = b.x1 + 2, d = b.y2 - 2 - (this.maxWidth / 2 - j.width / 2), e = -90, i = "left", this.width = j.height, this.height = j.width) : "right" === this.horizontalAlign ? (c = b.x2 - 2, d = b.y1 + 2 + (this.maxWidth / 2 - j.width / 2), e = 90, i = "right", this.width = j.height, this.height = j.width) : "center" === this.horizontalAlign && (d = a.y1 + (a.height / 2 - j.height / 2), c = a.x1 + (a.width / 2 - j.width / 2), i = "center", this.width = j.width, this.height = j.height), h = "center"), f.x = c, f.y = d, f.angle = e, f.horizontalAlign = h, f.render(!0), a.layoutManager.registerSpace(i, {
                width: this.width + ("left" === i || "right" === i ? this.margin + 2 : 0)
                , height: this.height + ("top" === i || "bottom" === i ? this.margin + 2 : 0)
            }), this.bounds = {
                x1: c
                , y1: d
                , x2: c + this.width
                , y2: d + this.height
            }, this.ctx.textBaseline = "top"
        }
    }, a(G, z), G.prototype.render = F.prototype.render, a(H, z), H.prototype.render = function () {
        var a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart
            , b = a.layoutManager.getFreeSpace()
            , c = null
            , d = 0
            , e = 0
            , f = 0
            , g = 0
            , h = this.chart._options.legend && !m(this.chart._options.legend.markerMargin) ? this.chart._options.legend.markerMargin : .3 * this.fontSize;
        this.height = 0;
        var i = []
            , j = [];
        "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (this.orientation = "horizontal", c = this.verticalAlign, f = null !== this.maxWidth ? this.maxWidth : b.width, g = null !== this.maxHeight ? this.maxHeight : .5 * b.height) : "center" === this.verticalAlign && (this.orientation = "vertical", c = this.horizontalAlign, f = null !== this.maxWidth ? this.maxWidth : .5 * b.width, g = null !== this.maxHeight ? this.maxHeight : b.height);
        for (var l = 0; l < this.dataSeries.length; l++) {
            var n = this.dataSeries[l];
            if ("pie" !== n.type && "doughnut" !== n.type && "funnel" !== n.type) {
                var o = n.legendMarkerType ? n.legendMarkerType : "line" !== n.type && "stepLine" !== n.type && "spline" !== n.type && "scatter" !== n.type && "bubble" !== n.type || !n.markerType ? J.getDefaultLegendMarker(n.type) : n.markerType
                    , p = n.legendText ? n.legendText : this.itemTextFormatter ? this.itemTextFormatter({
                        chart: this.chart._publicChartReference
                        , legend: this._options
                        , dataSeries: n
                        , dataPoint: null
                    }) : n.name
                    , q = n.legendMarkerColor ? n.legendMarkerColor : n.markerColor ? n.markerColor : n._colorSet[0]
                    , r = n.markerSize || "line" !== n.type && "stepLine" !== n.type && "spline" !== n.type ? .75 * this.lineHeight : 0
                    , s = n.legendMarkerBorderColor ? n.legendMarkerBorderColor : n.markerBorderColor
                    , t = n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : n.markerBorderThickness ? Math.max(1, Math.round(.2 * r)) : 0
                    , p = this.chart.replaceKeywordsWithValue(p, n.dataPoints[0], n, l)
                    , o = {
                        markerType: o
                        , markerColor: q
                        , text: p
                        , textBlock: null
                        , chartType: n.type
                        , markerSize: r
                        , lineColor: n._colorSet[0]
                        , dataSeriesIndex: n.index
                        , dataPointIndex: null
                        , markerBorderColor: s
                        , markerBorderThickness: t
                    };
                i.push(o)
            }
            else
                for (var u = 0; u < n.dataPoints.length; u++) {
                    var v = n.dataPoints[u]
                        , o = v.legendMarkerType ? v.legendMarkerType : n.legendMarkerType ? n.legendMarkerType : J.getDefaultLegendMarker(n.type)
                        , p = v.legendText ? v.legendText : n.legendText ? n.legendText : this.itemTextFormatter ? this.itemTextFormatter({
                            chart: this.chart._publicChartReference
                            , legend: this._options
                            , dataSeries: n
                            , dataPoint: v
                        }) : v.name ? v.name : "DataPoint: " + (u + 1)
                        , q = v.legendMarkerColor ? v.legendMarkerColor : n.legendMarkerColor ? n.legendMarkerColor : v.color ? v.color : n.color ? n.color : n._colorSet[u % n._colorSet.length]
                        , r = .75 * this.lineHeight
                        , s = v.legendMarkerBorderColor ? v.legendMarkerBorderColor : n.legendMarkerBorderColor ? n.legendMarkerBorderColor : v.markerBorderColor ? v.markerBorderColor : n.markerBorderColor
                        , t = v.legendMarkerBorderThickness ? v.legendMarkerBorderThickness : n.legendMarkerBorderThickness ? n.legendMarkerBorderThickness : v.markerBorderThickness || n.markerBorderThickness ? Math.max(1, Math.round(.2 * r)) : 0
                        , p = this.chart.replaceKeywordsWithValue(p, v, n, u)
                        , o = {
                            markerType: o
                            , markerColor: q
                            , text: p
                            , textBlock: null
                            , chartType: n.type
                            , markerSize: r
                            , dataSeriesIndex: l
                            , dataPointIndex: u
                            , markerBorderColor: s
                            , markerBorderThickness: t
                        };
                    (v.showInLegend || n.showInLegend && !1 !== v.showInLegend) && i.push(o)
                }
        }
        if (!0 === this.reversed && i.reverse(), 0 < i.length) {
            for (n = null, u = p = v = 0, p = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, f) : Math.min(this.itemWidth, f) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, f) : f, r = 0 === r ? .75 * this.lineHeight : r, p -= r + h, l = 0; l < i.length; l++) o = i[l], "line" !== o.chartType && "spline" !== o.chartType && "stepLine" !== o.chartType || (p -= .2 * this.lineHeight), 0 >= g || "undefined" == typeof g || 0 >= p || "undefined" == typeof p || ("horizontal" === this.orientation ? (o.textBlock = new E(this.ctx, {
                x: 0
                , y: 0
                , maxWidth: p
                , maxHeight: this.itemWrap ? g : this.lineHeight
                , angle: 0
                , text: o.text
                , horizontalAlign: "left"
                , fontSize: this.fontSize
                , fontFamily: this.fontFamily
                , fontWeight: this.fontWeight
                , fontColor: this.fontColor
                , fontStyle: this.fontStyle
                , textBaseline: "middle"
            }), o.textBlock.measureText(), null !== this.itemWidth && (o.textBlock.width = this.itemWidth - (r + h + ("line" === o.chartType || "spline" === o.chartType || "stepLine" === o.chartType ? .2 * this.lineHeight : 0))), (!n || n.width + Math.round(o.textBlock.width + r + h + (0 === n.width ? 0 : this.horizontalSpacing) + ("line" === o.chartType || "spline" === o.chartType || "stepLine" === o.chartType ? .2 * this.lineHeight : 0)) > f) && (n = {
                items: []
                , width: 0
            }, j.push(n), this.height += u, u = 0), u = Math.max(u, o.textBlock.height)) : (o.textBlock = new E(this.ctx, {
                x: 0
                , y: 0
                , maxWidth: p
                , maxHeight: !0 === this.itemWrap ? g : 1.5 * this.fontSize
                , angle: 0
                , text: o.text
                , horizontalAlign: "left"
                , fontSize: this.fontSize
                , fontFamily: this.fontFamily
                , fontWeight: this.fontWeight
                , fontColor: this.fontColor
                , fontStyle: this.fontStyle
                , textBaseline: "middle"
            }), o.textBlock.measureText(), null !== this.itemWidth && (o.textBlock.width = this.itemWidth - (r + h + ("line" === o.chartType || "spline" === o.chartType || "stepLine" === o.chartType ? .2 * this.lineHeight : 0))), this.height < g - this.lineHeight ? (n = {
                items: []
                , width: 0
            }, j.push(n)) : (n = j[v], v = (v + 1) % j.length), this.height += o.textBlock.height), o.textBlock.x = n.width, o.textBlock.y = 0, n.width += Math.round(o.textBlock.width + r + h + (0 === n.width ? 0 : this.horizontalSpacing) + ("line" === o.chartType || "spline" === o.chartType || "stepLine" === o.chartType ? .2 * this.lineHeight : 0)), n.items.push(o), this.width = Math.max(n.width, this.width));
            this.height = !1 === this.itemWrap ? j.length * this.lineHeight : this.height + u, this.height = Math.min(g, this.height), this.width = Math.min(f, this.width)
        }
        for ("top" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? b.x1 : "right" === this.horizontalAlign ? b.x2 - this.width : b.x1 + b.width / 2 - this.width / 2, d = b.y1) : "center" === this.verticalAlign ? (e = "left" === this.horizontalAlign ? b.x1 : "right" === this.horizontalAlign ? b.x2 - this.width : b.x1 + b.width / 2 - this.width / 2, d = b.y1 + b.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (e = "left" === this.horizontalAlign ? b.x1 : "right" === this.horizontalAlign ? b.x2 - this.width : b.x1 + b.width / 2 - this.width / 2, d = b.y2 - this.height), this.items = i, l = 0; l < this.items.length; l++) o = i[l], o.id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[o.id] = {
            id: o.id
            , objectType: "legendItem"
            , legendItemIndex: l
            , dataSeriesIndex: o.dataSeriesIndex
            , dataPointIndex: o.dataPointIndex
        };
        for (l = b = 0; l < j.length; l++) {
            for (n = j[l], v = u = 0; v < n.items.length; v++) o = n.items[v], q = o.textBlock.x + e + (0 === v ? .2 * r : this.horizontalSpacing), s = d + b, p = q, this.chart.data[o.dataSeriesIndex].visible || (this.ctx.globalAlpha = .5), this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(e, d, f, Math.max(g - g % this.lineHeight, 0)), this.ctx.clip(), "line" !== o.chartType && "stepLine" !== o.chartType && "spline" !== o.chartType || (this.ctx.strokeStyle = o.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(q - .1 * this.lineHeight, s + this.lineHeight / 2), this.ctx.lineTo(q + .85 * this.lineHeight, s + this.lineHeight / 2), this.ctx.stroke(), p -= .1 * this.lineHeight), ja.drawMarker(q + r / 2, s + this.lineHeight / 2, this.ctx, o.markerType, o.markerSize, o.markerColor, o.markerBorderColor, o.markerBorderThickness), o.textBlock.x = q + h + r, "line" !== o.chartType && "stepLine" !== o.chartType && "spline" !== o.chartType || (o.textBlock.x += .1 * this.lineHeight), o.textBlock.y = Math.round(s + this.lineHeight / 2), o.textBlock.render(!0), this.ctx.restore(), u = 0 < v ? Math.max(u, o.textBlock.height) : o.textBlock.height, this.chart.data[o.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1), q = k(o.id), this.ghostCtx.fillStyle = q, this.ghostCtx.beginPath(), this.ghostCtx.fillRect(p, o.textBlock.y - this.lineHeight / 2, o.textBlock.x + o.textBlock.width - p, o.textBlock.height), o.x1 = this.chart._eventManager.objectMap[o.id].x1 = p, o.y1 = this.chart._eventManager.objectMap[o.id].y1 = o.textBlock.y - this.lineHeight / 2, o.x2 = this.chart._eventManager.objectMap[o.id].x2 = o.textBlock.x + o.textBlock.width, o.y2 = this.chart._eventManager.objectMap[o.id].y2 = o.textBlock.y + o.textBlock.height - this.lineHeight / 2;
            b += u
        }
        0 < i.length && a.layoutManager.registerSpace(c, {
            width: this.width + 2 + 2
            , height: this.height + 5 + 5
        }), this.bounds = {
            x1: e
            , y1: d
            , x2: e + this.width
            , y2: d + this.height
        }
    }, a(I, z), I.prototype.render = function () {
        var a = this.chart.layoutManager.getFreeSpace();
        this.ctx.fillStyle = "red", this.ctx.fillRect(a.x1, a.y1, a.x2, a.y2)
    }, a(J, z), J.prototype.getDefaultAxisPlacement = function () {
        var a = this.type;
        return "column" === a || "line" === a || "stepLine" === a || "spline" === a || "area" === a || "stepArea" === a || "splineArea" === a || "stackedColumn" === a || "stackedLine" === a || "bubble" === a || "scatter" === a || "stackedArea" === a || "stackedColumn100" === a || "stackedLine100" === a || "stackedArea100" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeArea" === a || "rangeSplineArea" === a ? "normal" : "bar" === a || "stackedBar" === a || "stackedBar100" === a || "rangeBar" === a ? "xySwapped" : "pie" === a || "doughnut" === a || "funnel" === a ? "none" : (window.console.log("Unknown Chart Type: " + a), null)
    }, J.getDefaultLegendMarker = function (a) {
        return "column" === a || "stackedColumn" === a || "stackedLine" === a || "bar" === a || "stackedBar" === a || "stackedBar100" === a || "bubble" === a || "scatter" === a || "stackedColumn100" === a || "stackedLine100" === a || "stepArea" === a || "candlestick" === a || "ohlc" === a || "rangeColumn" === a || "rangeBar" === a || "rangeArea" === a || "rangeSplineArea" === a ? "square" : "line" === a || "stepLine" === a || "spline" === a || "pie" === a || "doughnut" === a || "funnel" === a ? "circle" : "area" === a || "splineArea" === a || "stackedArea" === a || "stackedArea100" === a ? "triangle" : (window.console.log("Unknown Chart Type: " + a), null)
    }, J.prototype.getDataPointAtX = function (a, b) {
        if (!this.dataPoints || 0 === this.dataPoints.length) return null;
        var c = {
                dataPoint: null
                , distance: 1 / 0
                , index: NaN
            }
            , d = null
            , e = 0
            , f = 0
            , g = 1
            , h = 1 / 0
            , i = 0
            , j = 0
            , k = 0;
        for ("none" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? (k = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), k = 1 < k ? Math.min(Math.max((this.dataPoints.length - 1) / k * Math.log(a / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (k = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, k = 0 < k ? Math.min(Math.max((this.dataPoints.length - 1) / k * (a - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));;) {
            if (f = 0 < g ? k + e : k - e, 0 <= f && f < this.dataPoints.length) {
                var d = this.dataPoints[f]
                    , l = this.axisX.logarithmic ? d.x > a ? d.x / a : a / d.x : Math.abs(d.x - a);
                if (l < c.distance && (c.dataPoint = d, c.distance = l, c.index = f), d = l, d <= h ? h = d : 0 < g ? i++ : j++, 1e3 < i && 1e3 < j) break
            }
            else if (0 > k - e && k + e >= this.dataPoints.length) break; - 1 === g ? (e++, g = 1) : g = -1
        }
        return b || c.dataPoint.x !== a ? b && null !== c.dataPoint ? c : null : c
    }, J.prototype.getDataPointAtXY = function (a, b, c) {
        if (!this.dataPoints || 0 === this.dataPoints.length || a < this.chart.plotArea.x1 || a > this.chart.plotArea.x2 || b < this.chart.plotArea.y1 || b > this.chart.plotArea.y2) return null;
        c = c || !1;
        var d = []
            , e = 0
            , f = 0
            , g = 1
            , h = !1
            , i = 1 / 0
            , j = 0
            , k = 0
            , l = 0;
        for ("none" !== this.chart.plotInfo.axisPlacement && (l = this.chart.axisX.getXValueAt({
                x: a
                , y: b
            }), this.axisX.logarithmic ? (f = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x), l = 1 < f ? Math.min(Math.max((this.dataPoints.length - 1) / f * Math.log(l / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0) : (f = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x, l = 0 < f ? Math.min(Math.max((this.dataPoints.length - 1) / f * (l - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0));;) {
            if (f = 0 < g ? l + e : l - e, 0 <= f && f < this.dataPoints.length) {
                var m = this.chart._eventManager.objectMap[this.dataPointIds[f]]
                    , n = this.dataPoints[f]
                    , o = null;
                if (m) {
                    switch (this.type) {
                    case "column":
                    case "stackedColumn":
                    case "stackedColumn100":
                    case "bar":
                    case "stackedBar":
                    case "stackedBar100":
                    case "rangeColumn":
                    case "rangeBar":
                        a >= m.x1 && a <= m.x2 && b >= m.y1 && b <= m.y2 && (d.push({
                            dataPoint: n
                            , dataPointIndex: f
                            , dataSeries: this
                            , distance: Math.min(Math.abs(m.x1 - a), Math.abs(m.x2 - a), Math.abs(m.y1 - b), Math.abs(m.y2 - b))
                        }), h = !0);
                        break;
                    case "line":
                    case "stepLine":
                    case "spline":
                    case "area":
                    case "stepArea":
                    case "stackedArea":
                    case "stackedArea100":
                    case "splineArea":
                    case "scatter":
                        var p = r("markerSize", n, this) || 4
                            , q = c ? 20 : p
                            , o = Math.sqrt(Math.pow(m.x1 - a, 2) + Math.pow(m.y1 - b, 2));
                        o <= q && d.push({
                            dataPoint: n
                            , dataPointIndex: f
                            , dataSeries: this
                            , distance: o
                        }), f = Math.abs(m.x1 - a), f <= i ? i = f : 0 < g ? j++ : k++, o <= p / 2 && (h = !0);
                        break;
                    case "rangeArea":
                    case "rangeSplineArea":
                        p = r("markerSize", n, this) || 4, q = c ? 20 : p, o = Math.min(Math.sqrt(Math.pow(m.x1 - a, 2) + Math.pow(m.y1 - b, 2)), Math.sqrt(Math.pow(m.x1 - a, 2) + Math.pow(m.y2 - b, 2))), o <= q && d.push({
                            dataPoint: n
                            , dataPointIndex: f
                            , dataSeries: this
                            , distance: o
                        }), f = Math.abs(m.x1 - a), f <= i ? i = f : 0 < g ? j++ : k++, o <= p / 2 && (h = !0);
                        break;
                    case "bubble":
                        p = m.size, o = Math.sqrt(Math.pow(m.x1 - a, 2) + Math.pow(m.y1 - b, 2)), o <= p / 2 && (d.push({
                            dataPoint: n
                            , dataPointIndex: f
                            , dataSeries: this
                            , distance: o
                        }), h = !0);
                        break;
                    case "pie":
                    case "doughnut":
                        p = m.center, q = "doughnut" === this.type ? m.percentInnerRadius * m.radius : 0, o = Math.sqrt(Math.pow(p.x - a, 2) + Math.pow(p.y - b, 2)), o < m.radius && o > q && (o = Math.atan2(b - p.y, a - p.x), 0 > o && (o += 2 * Math.PI), o = Number(((180 * (o / Math.PI) % 360 + 360) % 360).toFixed(12)), p = Number(((180 * (m.startAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), q = Number(((180 * (m.endAngle / Math.PI) % 360 + 360) % 360).toFixed(12)), 0 === q && 1 < m.endAngle && (q = 360), p >= q && 0 !== n.y && (q += 360, o < p && (o += 360)), o > p && o < q && (d.push({
                            dataPoint: n
                            , dataPointIndex: f
                            , dataSeries: this
                            , distance: 0
                        }), h = !0));
                        break;
                    case "candlestick":
                        (a >= m.x1 - m.borderThickness / 2 && a <= m.x2 + m.borderThickness / 2 && b >= m.y2 - m.borderThickness / 2 && b <= m.y3 + m.borderThickness / 2 || Math.abs(m.x2 - a + m.x1 - a) < m.borderThickness && b >= m.y1 && b <= m.y4) && (d.push({
                            dataPoint: n
                            , dataPointIndex: f
                            , dataSeries: this
                            , distance: Math.min(Math.abs(m.x1 - a), Math.abs(m.x2 - a), Math.abs(m.y2 - b), Math.abs(m.y3 - b))
                        }), h = !0);
                        break;
                    case "ohlc":
                        (Math.abs(m.x2 - a + m.x1 - a) < m.borderThickness && b >= m.y2 && b <= m.y3 || a >= m.x1 && a <= (m.x2 + m.x1) / 2 && b >= m.y1 - m.borderThickness / 2 && b <= m.y1 + m.borderThickness / 2 || a >= (m.x1 + m.x2) / 2 && a <= m.x2 && b >= m.y4 - m.borderThickness / 2 && b <= m.y4 + m.borderThickness / 2) && (d.push({
                            dataPoint: n
                            , dataPointIndex: f
                            , dataSeries: this
                            , distance: Math.min(Math.abs(m.x1 - a), Math.abs(m.x2 - a), Math.abs(m.y2 - b), Math.abs(m.y3 - b))
                        }), h = !0)
                    }
                    if (h || 1e3 < j && 1e3 < k) break
                }
            }
            else if (0 > l - e && l + e >= this.dataPoints.length) break; - 1 === g ? (e++, g = 1) : g = -1
        }
        for (a = null, b = 0; b < d.length; b++) a ? d[b].distance <= a.distance && (a = d[b]) : a = d[b];
        return a
    }, J.prototype.getMarkerProperties = function (a, b, c, d) {
        var e = this.dataPoints;
        return {
            x: b
            , y: c
            , ctx: d
            , type: e[a].markerType ? e[a].markerType : this.markerType
            , size: e[a].markerSize ? e[a].markerSize : this.markerSize
            , color: e[a].markerColor ? e[a].markerColor : this.markerColor ? this.markerColor : e[a].color ? e[a].color : this.color ? this.color : this._colorSet[a % this._colorSet.length]
            , borderColor: e[a].markerBorderColor ? e[a].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null
            , borderThickness: e[a].markerBorderThickness ? e[a].markerBorderThickness : this.markerBorderThickness ? this.markerBorderThickness : null
        }
    }, a(K, z), K.prototype.createExtraLabelsForLog = function (a) {
        if (a = (a || 0) + 1, !(5 < a)) {
            var b = this.logLabelValues[0] || this.intervalStartPosition;
            if (Math.log(this.range) / Math.log(b / this.viewportMinimum) < this.noTicks - 1) {
                for (var c = K.getNiceNumber((b - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), !0), d = Math.ceil(this.viewportMinimum / c) * c; d < b; d += c) d < this.viewportMinimum || this.logLabelValues.push(d);
                this.logLabelValues.sort(g), this.createExtraLabelsForLog(a)
            }
        }
    }, K.prototype.createLabels = function () {
        var a, b, f, k, d = 0
            , e = 0
            , g = 0
            , h = 0
            , e = 0
            , i = this.interval
            , j = 0
            , l = .6 * this.chart.height;
        if ("axisX" !== this.type || "dateTime" !== this.chart.plotInfo.axisXValueType || this.logarithmic) {
            if (f = this.viewportMaximum, this.labels) {
                a = Math.ceil(i);
                for (var i = Math.ceil(this.intervalStartPosition), n = !1, d = i; d < this.viewportMaximum; d += a) {
                    if (!this.labels[d]) {
                        n = !1;
                        break
                    }
                    n = !0
                }
                n && (this.interval = a, this.intervalStartPosition = i)
            }
            if (this.logarithmic && !this.equidistantInterval) {
                this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog());
                for (var o = 0; o < this.logLabelValues.length; o++) d = this.logLabelValues[o], d < this.viewportMinimum || (a = this.labelFormatter ? this.labelFormatter({
                    chart: this.chart._publicChartReference
                    , axis: this._options
                    , value: d
                    , label: this.labels[d] ? this.labels[d] : null
                }) : "axisX" === this.type && this.labels[d] ? this.labels[d] : $(d, this.valueFormatString, this.chart._cultureInfo), a = new E(this.ctx, {
                    x: 0
                    , y: 0
                    , maxWidth: g
                    , maxHeight: h
                    , angle: this.labelAngle
                    , text: this.prefix + a + this.suffix
                    , horizontalAlign: "left"
                    , fontSize: this.labelFontSize
                    , fontFamily: this.labelFontFamily
                    , fontWeight: this.labelFontWeight
                    , fontColor: this.labelFontColor
                    , fontStyle: this.labelFontStyle
                    , textBaseline: "middle"
                    , borderThickness: 0
                }), this._labels.push({
                    position: d
                    , textBlock: a
                    , effectiveHeight: null
                }))
            }
            for (d = this.intervalStartPosition; d <= f; d = parseFloat((this.logarithmic && this.equidistantInterval ? d * Math.pow(this.logarithmBase, this.interval) : d + this.interval).toFixed(14))) a = this.labelFormatter ? this.labelFormatter({
                chart: this.chart._publicChartReference
                , axis: this._options
                , value: d
                , label: this.labels[d] ? this.labels[d] : null
            }) : "axisX" === this.type && this.labels[d] ? this.labels[d] : $(d, this.valueFormatString, this.chart._cultureInfo), a = new E(this.ctx, {
                x: 0
                , y: 0
                , maxWidth: g
                , maxHeight: h
                , angle: this.labelAngle
                , text: this.prefix + a + this.suffix
                , horizontalAlign: "left"
                , fontSize: this.labelFontSize
                , fontFamily: this.labelFontFamily
                , fontWeight: this.labelFontWeight
                , fontColor: this.labelFontColor
                , fontStyle: this.labelFontStyle
                , textBaseline: "middle"
                , borderThickness: 0
            }), this._labels.push({
                position: d
                , textBlock: a
                , effectiveHeight: null
            })
        }
        else
            for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), f = c(new Date(this.viewportMaximum), this.interval, this.intervalType), d = this.intervalStartPosition; d < f; c(d, i, this.intervalType)) a = d.getTime(), a = this.labelFormatter ? this.labelFormatter({
                chart: this.chart._publicChartReference
                , axis: this._options
                , value: d
                , label: this.labels[d] ? this.labels[d] : null
            }) : "axisX" === this.type && this.labels[a] ? this.labels[a] : Z(d, this.valueFormatString, this.chart._cultureInfo), a = new E(this.ctx, {
                x: 0
                , y: 0
                , maxWidth: g
                , maxHeight: h
                , angle: this.labelAngle
                , text: this.prefix + a + this.suffix
                , horizontalAlign: "left"
                , fontSize: this.labelFontSize
                , fontFamily: this.labelFontFamily
                , fontWeight: this.labelFontWeight
                , fontColor: this.labelFontColor
                , fontStyle: this.labelFontStyle
                , textBaseline: "middle"
            }), this._labels.push({
                position: d.getTime()
                , textBlock: a
                , effectiveHeight: null
            });
        for ("bottom" === this._position || "top" === this._position ? (j = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * W[this.intervalType + "Duration"] * this.interval, g = "undefined" == typeof this._options.labelMaxWidth ? .5 * this.chart.width >> 0 : this._options.labelMaxWidth, this.chart.panEnabled || (h = "undefined" == typeof this._options.labelWrap || this.labelWrap ? .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize)) : "left" !== this._position && "right" !== this._position || (j = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * W[this.intervalType + "Duration"] * this.interval, this.chart.panEnabled || (g = "undefined" == typeof this._options.labelMaxWidth ? .3 * this.chart.width >> 0 : this._options.labelMaxWidth), h = "undefined" == typeof this._options.labelWrap || this.labelWrap ? .3 * this.chart.height >> 0 : 1.5 * this.labelFontSize), e = 0; e < this._labels.length; e++) {
            a = this._labels[e].textBlock, a.maxWidth = g, a.maxHeight = h;
            var p = a.measureText();
            k = p.height
        }
        if (f = [], n = i = 0, this.labelAutoFit || this._options.labelAutoFit)
            if (m(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), "bottom" === this._position || "top" === this._position)
                if (g = .9 * j >> 0, n = 0, !this.chart.panEnabled && 1 <= this._labels.length) {
                    for (this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelWrap = this.labelWrap, d = 0; d < this._labels.length; d++) {
                        a = this._labels[d].textBlock;
                        for (var q, r = a.text.split(" "), e = 0; e < r.length; e++) o = r[e], this.ctx.font = a.fontStyle + " " + a.fontWeight + " " + a.fontSize + "px " + a.fontFamily, o = this.ctx.measureText(o), o.width > n && (q = d, n = o.width)
                    }
                    for (d = 0, d = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; d < this._labels.length; d++)
                        if (a = this._labels[d].textBlock, p = a.measureText(), d < this._labels.length - 1 && (o = d + 1, b = this._labels[o].textBlock, b = b.measureText()), f.push(a.height), this.sessionVariables.labelMaxHeight = Math.max.apply(Math, f), Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), e = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (h - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), m(this._options.labelAngle) && isNaN(this._options.labelAngle) && 0 !== this._options.labelAngle)
                            if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : Math.min((e - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), e), r = (l - (k + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), m(this._options.labelWrap)) {
                                if (m(this._options.labelWrap))
                                    if (m(this._options.labelMaxWidth)) {
                                        if (!m(b))
                                            if (e = p.width + b.width >> 0, o = this.labelFontSize, n < g) e - 2 * g > i && (i = e - 2 * g, e >= 2 * g && e < 2.2 * g ? (this.sessionVariables.labelMaxWidth = g, m(this._options.labelFontSize) && 12 < o && (o = Math.floor(12 / 13 * o), a.measureText()), this.sessionVariables.labelFontSize = m(this._options.labelFontSize) ? o : this._options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : e >= 2.2 * g && e < 2.8 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r, this.sessionVariables.labelFontSize = o) : e >= 2.8 * g && e < 3.2 * g ? (this.sessionVariables.labelMaxWidth = Math.max(g, n), this.sessionVariables.labelWrap = !0, m(this._options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = m(this._options.labelFontSize) ? o : this._options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : e >= 3.2 * g && e < 3.6 * g ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = r, this.sessionVariables.labelFontSize = this.labelFontSize) : e > 3.6 * g && e < 5 * g ? (m(this._options.labelFontSize) && 12 < o && (o = Math.floor(12 / 13 * o), a.measureText()), this.sessionVariables.labelFontSize = m(this._options.labelFontSize) ? o : this._options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r) : e > 5 * g && (this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelFontSize = o, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelAngle = this.labelAngle));
                                            else if (q === d && (0 === q && n + this._labels[q + 1].textBlock.measureText().width - 2 * g > i || q === this._labels.length - 1 && n + this._labels[q - 1].textBlock.measureText().width - 2 * g > i || 0 < q && q < this._labels.length - 1 && n + this._labels[q + 1].textBlock.measureText().width - 2 * g > i && n + this._labels[q - 1].textBlock.measureText().width - 2 * g > i)) i = 0 === q ? n + this._labels[q + 1].textBlock.measureText().width - 2 * g : n + this._labels[q - 1].textBlock.measureText().width - 2 * g, this.sessionVariables.labelFontSize = m(this._options.labelFontSize) ? o : this._options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r;
                                        else if (0 === i)
                                            for (this.sessionVariables.labelFontSize = m(this._options.labelFontSize) ? o : this._options.labelFontSize, this.sessionVariables.labelWrap = !0, e = 0; e < this._labels.length; e++) a = this._labels[e].textBlock, a.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), r), p = a.measureText(), e < this._labels.length - 1 && (o = e + 1, b = this._labels[o].textBlock, b.maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), r), b = b.measureText(), p.width + b.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25))
                                    }
                                    else this._options.labelMaxWidth < g ? (this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth, this.sessionVariables.labelMaxHeight = e) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth, this.sessionVariables.labelMaxHeight = h)
                            }
                            else this.labelWrap ? m(this._options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(g, n), r), this.sessionVariables.labelWrap = this.labelWrap, p.width + b.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle) : m(this._options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = g, p.width + b.width >> 0 > 2 * g && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = r)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > g ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelWrap = this.labelWrap);
                    else this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : Math.min((e - g * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), e), r = 0 != this.labelAngle ? (l - (k + a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : g, this.sessionVariables.labelMaxHeight = h = this.labelWrap ? (l - r * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, m(this._options.labelWrap) ? m(this._options.labelWrap) && (this.labelWrap && !m(this._options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : r, this.sessionVariables.labelMaxHeight = h) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = r, this.sessionVariables.labelMaxHeight = e < .9 * j ? .9 * j : e, this.sessionVariables.labelWrap = this.labelWrap)) : (this._options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : r) : (m(this._options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : r, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = h);
                    for (e = 0; e < this._labels.length; e++) a = this._labels[e].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText()
                }
                else
                    for (d = 0; d < this._labels.length; d++) a = this._labels[d].textBlock, a.maxWidth = this.labelMaxWidth = m(this._options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this._options.labelMaxWidth, a.fontSize = this.labelFontSize = m(this._options.labelFontSize) ? this.sessionVariables.labelFontSize : this._options.labelFontSize, a.angle = this.labelAngle = m(this._options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = m(this._options.labelWrap) ? this.sessionVariables.labelWrap : this._options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
        else if ("left" === this._position || "right" === this._position)
            if (g = m(this._options.labelMaxWidth) ? .3 * this.chart.width >> 0 : this._options.labelMaxWidth, h = "undefined" == typeof this._options.labelWrap || this.labelWrap ? .3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {
                for (this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelAngle = m(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle, this.sessionVariables.labelWrap = this.labelWrap, d = 0; d < this._labels.length; d++) a = this._labels[d].textBlock, p = a.measureText(), d < this._labels.length - 1 && (o = d + 1, b = this._labels[o].textBlock, b = b.measureText()), f.push(a.height), this.sessionVariables.labelMaxHeight = Math.max.apply(Math, f), e = g * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (h - a.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), m(this._options.labelAngle) && isNaN(this._options.labelAngle) && 0 !== this._options.labelAngle ? m(this._options.labelWrap) ? m(this._options.labelWrap) && (m(this._options.labelMaxWidth) ? m(b) || (j = p.height + b.height >> 0, j - 2 * h > n && (n = j - 2 * h, j >= 2 * h && j < 2.4 * h ? (m(this._options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelFontSize = m(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize) : j >= 2.4 * h && j < 2.8 * h ? (this.sessionVariables.labelMaxHeight = e, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : j >= 2.8 * h && j < 3.2 * h ? (this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelWrap = !0, m(this._options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = m(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize, this.sessionVariables.labelAngle = m(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : j >= 3.2 * h && j < 3.6 * h ? (this.sessionVariables.labelMaxHeight = e, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : j > 3.6 * h && j < 10 * h ? (m(this._options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = m(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelAngle = m(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : j > 10 * h && j < 50 * h && (m(this._options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), a.measureText()), this.sessionVariables.labelFontSize = m(this._options.labelFontSize) ? this.labelFontSize : this._options.labelFontSize, this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = g, this.sessionVariables.labelAngle = m(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle))) : (this.sessionVariables.labelMaxHeight = h, this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this._options.labelMaxWidth ? this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this._options.labelMaxWidth ? this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = h) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? g : Math.min((e - h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), h), m(this._options.labelWrap) ? m(this._options.labelWrap) && (this.labelWrap && !m(this._options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth > this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = e) : (this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : g, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : e, m(this._options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this._options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? h : e, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = g) : (this.sessionVariables.labelMaxHeight = h, m(this._options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this._options.labelMaxWidth ? this._options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap));
                for (e = 0; e < this._labels.length; e++) a = this._labels[e].textBlock, a.maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, a.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, a.angle = this.labelAngle = this.sessionVariables.labelAngle, a.wrap = this.labelWrap = this.sessionVariables.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText()
            }
            else
                for (d = 0; d < this._labels.length; d++) a = this._labels[d].textBlock, a.maxWidth = this.labelMaxWidth = m(this._options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this._options.labelMaxWidth, a.fontSize = this.labelFontSize = m(this._options.labelFontSize) ? this.sessionVariables.labelFontSize : this._options.labelFontSize, a.angle = this.labelAngle = m(this._options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, a.wrap = this.labelWrap = m(this._options.labelWrap) ? this.sessionVariables.labelWrap : this._options.labelWrap, a.maxHeight = this.sessionVariables.labelMaxHeight, a.measureText();
        for (d = 0; d < this.stripLines.length; d++) {
            var s, g = this.stripLines[d];
            "outside" === g.labelPlacement ? (h = this.sessionVariables.labelMaxWidth, "bottom" !== this._position && "top" !== this._position || (s = "undefined" == typeof g._options.labelWrap ? this.sessionVariables.labelMaxHeight : g.labelWrap ? .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize), "left" !== this._position && "right" !== this._position || (s = "undefined" == typeof g._options.labelWrap ? this.sessionVariables.labelMaxHeight : g.labelWrap ? .8 * this.chart.width >> 0 : 1.5 * this.labelFontSize), b = m(g._options.labelBackgroundColor) ? "#EEEEEE" : g._options.labelBackgroundColor) : (h = "bottom" === this._position || "top" === this._position ? .9 * this.chart.width >> 0 : .9 * this.chart.height >> 0, s = "undefined" == typeof g._options.labelWrap || g.labelWrap ? "bottom" === this._position || "top" === this._position ? .8 * this.chart.width >> 0 : .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, b = m(g._options.labelBackgroundColor) ? m(g.startValue) && 0 !== g.startValue ? "transparent" : "#EEEEEE" : g._options.labelBackgroundColor), a = new E(this.ctx, {
                x: 0
                , y: 0
                , backgroundColor: b
                , maxWidth: g._options.labelMaxWidth ? g._options.labelMaxWidth : h
                , maxHeight: s
                , angle: this.labelAngle
                , text: g.labelFormatter ? g.labelFormatter({
                    chart: this.chart._publicChartReference
                    , axis: this
                    , stripLine: g
                }) : g.label
                , horizontalAlign: "left"
                , fontSize: "outside" === g.labelPlacement ? g._options.labelFontSize ? g._options.labelFontSize : this.labelFontSize : g.labelFontSize
                , fontFamily: "outside" === g.labelPlacement ? g._options.labelFontFamily ? g._options.labelFontFamily : this.labelFontFamily : g.labelFontFamily
                , fontWeight: "outside" === g.labelPlacement ? g._options.fontWeight ? g._options.fontWeight : this.fontWeight : g.fontWeight
                , fontColor: g._options.labelFontColor || g.color
                , fontStyle: "outside" === g.labelPlacement ? g._options.fontStyle ? g._options.fontStyle : this.fontWeight : g.fontStyle
                , textBaseline: "middle"
                , borderThickness: 0
            }), this._stripLineLabels.push({
                position: g.value
                , textBlock: a
                , effectiveHeight: null
                , stripLine: g
            })
        }
    }, K.prototype.createLabelsAndCalculateWidth = function () {
        var a = 0
            , b = 0;
        if (this._labels = [], this._stripLineLabels = [], "left" === this._position || "right" === this._position) {
            for (this.createLabels(), b = 0; b < this._labels.length; b++) {
                var c = this._labels[b].textBlock
                    , d = c.measureText()
                    , e = 0
                    , e = 0 === this.labelAngle ? d.width : d.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (d.height - c.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle));
                a < e && (a = e), this._labels[b].effectiveWidth = e
            }
            for (b = 0; b < this._stripLineLabels.length; b++) "outside" === this._stripLineLabels[b].stripLine.labelPlacement && this._stripLineLabels[b].stripLine.value > this.viewportMinimum && this._stripLineLabels[b].stripLine.value < this.viewportMaximum && (c = this._stripLineLabels[b].textBlock, d = c.measureText(), e = 0 === this.labelAngle ? d.width : d.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (d.height - c.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), a < e && (a = e), this._stripLineLabels[b].effectiveWidth = e)
        }
        return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + this.tickLength + 5
    }, K.prototype.createLabelsAndCalculateHeight = function () {
        var a = 0;
        this._labels = [], this._stripLineLabels = [];
        var b, c = 0;
        if (this.createLabels(), "bottom" === this._position || "top" === this._position) {
            for (c = 0; c < this._labels.length; c++) {
                b = this._labels[c].textBlock;
                var d = b.measureText()
                    , e = 0
                    , e = 0 === this.labelAngle ? d.height : d.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d.height - b.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle));
                a < e && (a = e), this._labels[c].effectiveHeight = e
            }
            for (c = 0; c < this._stripLineLabels.length; c++) "outside" === this._stripLineLabels[c].stripLine.labelPlacement && (b = this._stripLineLabels[c].textBlock, d = b.measureText(), e = 0 === this.labelAngle ? d.height : d.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d.height - b.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), a < e && (a = e), this._stripLineLabels[c].effectiveHeight = e)
        }
        return (this.title ? this._titleTextBlock.measureText().height + 2 : 0) + a + this.tickLength + 5
    }, K.setLayoutAndRender = function (a, b, c, d, e) {
        var f, g, h, i = a.chart
            , k = i.ctx;
        a.calculateAxisParameters(), b && b.calculateAxisParameters(), c && c.calculateAxisParameters();
        var r, s, t, u, v, w, z, A, B, l = b ? b.margin : 0
            , n = c ? c.margin : 0
            , o = 0
            , p = 0
            , q = 0
            , x = 0
            , y = 0;
        if (z = A = B = !1, a && a.title && (a._titleTextBlock = new E(a.ctx, {
                text: a.title
                , horizontalAlign: "center"
                , fontSize: a.titleFontSize
                , fontFamily: a.titleFontFamily
                , fontWeight: a.titleFontWeight
                , fontColor: a.titleFontColor
                , fontStyle: a.titleFontStyle
                , textBaseline: "top"
            })), b && b.title && (b._titleTextBlock = new E(b.ctx, {
                text: b.title
                , horizontalAlign: "center"
                , fontSize: b.titleFontSize
                , fontFamily: b.titleFontFamily
                , fontWeight: b.titleFontWeight
                , fontColor: b.titleFontColor
                , fontStyle: b.titleFontStyle
                , textBaseline: "top"
            })), c && c.title && (c._titleTextBlock = new E(c.ctx, {
                text: c.title
                , horizontalAlign: "center"
                , fontSize: c.titleFontSize
                , fontFamily: c.titleFontFamily
                , fontWeight: c.titleFontWeight
                , fontColor: c.titleFontColor
                , fontStyle: c.titleFontStyle
                , textBaseline: "top"
            })), "normal" === d) {
            var C = []
                , D = []
                , F = [];
            for (a && a.title && (a._titleTextBlock.maxWidth = a.titleMaxWidth || e.width, a._titleTextBlock.maxHeight = a.titleWrap ? .8 * e.height : 1.5 * a.titleFontSize, a._titleTextBlock.angle = 0), b && b.title && (b._titleTextBlock.maxWidth = b.titleMaxWidth || e.height, b._titleTextBlock.maxHeight = b.titleWrap ? .8 * e.width : 1.5 * b.titleFontSize, b._titleTextBlock.angle = -90), c && c.title && (c._titleTextBlock.maxWidth = c.titleMaxWidth || e.height, c._titleTextBlock.maxHeight = c.titleWrap ? .8 * e.width : 1.5 * c.titleFontSize, c._titleTextBlock.angle = 90); 4 > o++;) {
                if (a.lineCoordinates = {}, s = Math.ceil(b ? b.createLabelsAndCalculateWidth() : 0), D.push(s), f = Math.round(e.x1 + s + l), r = Math.ceil(c ? c.createLabelsAndCalculateWidth() : 0), F.push(r), g = Math.round(e.x2 - r - n > a.chart.width - 10 ? a.chart.width - 10 : e.x2 - r - n), !a.labelAutoFit || m(v) || m(w) || (0 < a.labelAngle ? w + q > g && (x += 0 < a.labelAngle ? w + q - g - r : 0) : 0 > a.labelAngle ? v - p < f && v - p < a.viewportMinimum && (y = f - (l + a.tickLength + s + v - p + a.labelFontSize / 2)) : 0 === a.labelAngle && (w + q > g && (x = w + q / 2 - g - r), v - p < f && v - p < a.viewportMinimum && (y = f - l - a.tickLength - s - v + p / 2)), a.viewportMaximum === a.maximum && a.viewportMinimum === a.minimum && 0 < a.labelAngle && 0 < x ? g -= x : a.viewportMaximum === a.maximum && a.viewportMinimum === a.minimum && 0 > a.labelAngle && 0 < y ? f += y : a.viewportMaximum === a.maximum && a.viewportMinimum === a.minimum && 0 === a.labelAngle && (0 < y && (f += y), 0 < x && (g -= x))), a.lineCoordinates.x1 = f, a.lineCoordinates.x2 = g, a.lineCoordinates.width = Math.abs(g - f), a.title && (a._titleTextBlock.maxWidth = 0 < a.titleMaxWidth && a.titleMaxWidth < a.lineCoordinates.width ? a.titleMaxWidth : a.lineCoordinates.width), s = Math.ceil(a.createLabelsAndCalculateHeight()), C.push(s), a._labels && 1 < a._labels.length && (d = h = 0, h = a._labels[1], d = "dateTime" === a.chart.plotInfo.axisXValueType ? a._labels[a._labels.length - 2] : a._labels[a._labels.length - 1], p = h.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h.textBlock.angle)) + (h.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h.textBlock.angle)), q = d.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(d.textBlock.angle)) + (d.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(d.textBlock.angle))), i.panEnabled ? s = i.sessionVariables.axisX.height : i.sessionVariables.axisX.height = s, d = Math.round(e.y2 - s - a.margin), h = Math.round(e.y2 - a.margin), a.lineCoordinates.y1 = d, a.lineCoordinates.y2 = d, a.boundingRect = {
                        x1: f
                        , y1: d
                        , x2: g
                        , y2: h
                        , width: g - f
                        , height: h - d
                    }, b && (f = Math.round(e.x1 + b.margin), d = Math.round(10 > e.y1 ? 10 : e.y1), g = Math.round(a.lineCoordinates.x1), h = Math.round(e.y2 - s - a.margin), b.lineCoordinates = {
                        x1: g
                        , y1: d
                        , x2: g
                        , y2: h
                        , height: Math.abs(h - d)
                    }, b.boundingRect = {
                        x1: f
                        , y1: d
                        , x2: g
                        , y2: h
                        , width: g - f
                        , height: h - d
                    }, b.title && (b._titleTextBlock.maxWidth = 0 < b.titleMaxWidth && b.titleMaxWidth < b.lineCoordinates.height ? b.titleMaxWidth : b.lineCoordinates.height)), c && (f = Math.round(a.lineCoordinates.x2), d = Math.round(10 > e.y1 ? 10 : e.y1), g = Math.round(f + r), h = Math.round(e.y2 - s - a.margin), c.lineCoordinates = {
                        x1: f
                        , y1: d
                        , x2: f
                        , y2: h
                        , height: Math.abs(h - d)
                    }, c.boundingRect = {
                        x1: f
                        , y1: d
                        , x2: g
                        , y2: h
                        , width: g - f
                        , height: h - d
                    }, c.title && (c._titleTextBlock.maxWidth = 0 < c.titleMaxWidth && c.titleMaxWidth < c.lineCoordinates.height ? c.titleMaxWidth : c.lineCoordinates.height)), a.calculateValueToPixelConversionParameters(), a._labels && 1 < a._labels.length && (v = (a.logarithmic ? Math.log(a._labels[1].position / a.viewportMinimum) / a.conversionParameters.lnLogarithmBase : a._labels[1].position - a.viewportMinimum) * Math.abs(a.conversionParameters.pixelPerUnit) + a.lineCoordinates.x1, w = "dateTime" === a.chart.plotInfo.axisXValueType ? (a.logarithmic ? Math.log(a._labels[a._labels.length - 2].position / a.viewportMinimum) / a.conversionParameters.lnLogarithmBase : a._labels[a._labels.length - 2].position - a.viewportMinimum) * Math.abs(a.conversionParameters.pixelPerUnit) + a.lineCoordinates.x1 : (a.logarithmic ? Math.log(a._labels[a._labels.length - 1].position / a.viewportMinimum) / a.conversionParameters.lnLogarithmBase : a._labels[a._labels.length - 1].position - a.viewportMinimum) * Math.abs(a.conversionParameters.pixelPerUnit) + a.lineCoordinates.x1), b && b.calculateValueToPixelConversionParameters(), c && c.calculateValueToPixelConversionParameters(), a || b || c) {
                    if (!m(C))
                        for (o = 0; o < C.length; o++)
                            for (j = o + 1; j < C.length; j++) C[o] == C[j] && (z = !0);
                    if (!m(D))
                        for (o = 0; o < D.length; o++)
                            for (j = o + 1; j < D.length; j++) D[o] == D[j] && (A = !0);
                    if (!m(F))
                        for (o = 0; o < F.length; o++)
                            for (j = o + 1; j < F.length; j++) F[o] == F[j] && (B = !0)
                }
                if (z && A && B) break
            }
            k.save(), k.beginPath(), k.rect(5, a.boundingRect.y1, a.chart.width - 10, a.boundingRect.height), k.clip(), a.renderLabelsTicksAndTitle(), k.restore(), b && b.renderLabelsTicksAndTitle(), c && c.renderLabelsTicksAndTitle()
        }
        else {
            for (n = [], v = [], w = [], a && a.title && (a._titleTextBlock.maxWidth = a.titleMaxWidth || e.height, a._titleTextBlock.maxHeight = a.titleWrap ? .8 * e.width : 1.5 * a.titleFontSize, a._titleTextBlock.angle = -90), b && b.title && (b._titleTextBlock.maxWidth = b.titleMaxWidth || e.width, b._titleTextBlock.maxHeight = b.titleWrap ? .8 * e.height : 1.5 * b.titleFontSize, b._titleTextBlock.angle = 0), c && c.title && (c._titleTextBlock.maxWidth = b.titleMaxWidth || e.width, c._titleTextBlock.maxHeight = c.titleWrap ? .8 * e.height : 1.5 * c.titleFontSize, c._titleTextBlock.angle = 0); 4 > o++;) {
                if (x = Math.ceil(a.createLabelsAndCalculateWidth()), n.push(x), b && (b.lineCoordinates = {}, f = Math.round(e.x1 + x + a.margin), g = Math.round(e.x2 > b.chart.width - 10 ? b.chart.width - 10 : e.x2), b.labelAutoFit && !m(r) && (f = 0 > b.labelAngle ? Math.max(f, r) : 0 === b.labelAngle ? Math.max(f, r / 2) : f, g = 0 < b.labelAngle ? g - s : 0 === b.labelAngle ? g - s / 2 : g), b.lineCoordinates.x1 = f, b.lineCoordinates.x2 = g, b.lineCoordinates.width = Math.abs(g - f), b.title && (b._titleTextBlock.maxWidth = 0 < b.titleMaxWidth && b.titleMaxWidth < b.lineCoordinates.width ? b.titleMaxWidth : b.lineCoordinates.width)), c && (c.lineCoordinates = {}, f = Math.round(e.x1 + x + a.margin), g = Math.round(e.x2 > c.chart.width - 10 ? c.chart.width - 10 : e.x2), b && b.labelAutoFit && !m(t) && (f = 0 < c.labelAngle ? Math.max(f, t) : 0 === c.labelAngle ? Math.max(f, t / 2) : f, g -= u / 2), c.lineCoordinates.x1 = f, c.lineCoordinates.x2 = g, c.lineCoordinates.width = Math.abs(g - f), c.title && (c._titleTextBlock.maxWidth = 0 < c.titleMaxWidth && c.titleMaxWidth < c.lineCoordinates.width ? c.titleMaxWidth : c.lineCoordinates.width)), y = Math.ceil(b ? b.createLabelsAndCalculateHeight() : 0), p = Math.ceil(c ? c.createLabelsAndCalculateHeight() : 0), v.push(y), w.push(p), b && 0 < b._labels.length && (h = b._labels[0], d = b._labels[b._labels.length - 1], r = h.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h.textBlock.angle)) + (h.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h.textBlock.angle)), s = d.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(d.textBlock.angle)) + (d.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(d.textBlock.angle))), c && 0 < c._labels.length && (h = c._labels[0], d = c._labels[c._labels.length - 1], t = h.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(h.textBlock.angle)) + (h.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(h.textBlock.angle)), u = d.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(d.textBlock.angle)) + (d.textBlock.height - d.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(d.textBlock.angle))), i.panEnabled ? y = i.sessionVariables.axisY.height : i.sessionVariables.axisY.height = y, b && (d = Math.round(e.y2 - y - b.margin), h = Math.round(e.y2 - l > b.chart.height - 10 ? b.chart.height - 10 : e.y2 - l), b.lineCoordinates.y1 = d, b.lineCoordinates.y2 = d, b.boundingRect = {
                        x1: f
                        , y1: d
                        , x2: g
                        , y2: h
                        , width: g - f
                        , height: y
                    }, b.title && (b._titleTextBlock.maxWidth = 0 < b.titleMaxWidth && b.titleMaxWidth < b.lineCoordinates.width ? b.titleMaxWidth : b.lineCoordinates.width)), c && (d = Math.round(e.y1 + c.margin), h = e.y1 + c.margin + p, c.lineCoordinates.y1 = h, c.lineCoordinates.y2 = h, c.boundingRect = {
                        x1: f
                        , y1: d
                        , x2: g
                        , y2: h
                        , width: g - f
                        , height: p
                    }, c.title && (c._titleTextBlock.maxWidth = 0 < c.titleMaxWidth && c.titleMaxWidth < c.lineCoordinates.width ? c.titleMaxWidth : c.lineCoordinates.width)), f = Math.round(e.x1 + a.margin), d = Math.round(c ? c.lineCoordinates.y2 : 10 > e.y1 ? 10 : e.y1), g = Math.round(e.x1 + x + a.margin), h = Math.round(b ? b.lineCoordinates.y1 : e.y2 - l > a.chart.height - 10 ? a.chart.height - 10 : e.y2 - l), b && b.labelAutoFit && (g = 0 > b.labelAngle ? Math.max(g, r) : 0 === b.labelAngle ? Math.max(g, r / 2) : g, f = 0 > b.labelAngle || 0 === b.labelAngle ? g - x : f), c && c.labelAutoFit && (g = c.lineCoordinates.x1, f = g - x), a.lineCoordinates = {
                        x1: g
                        , y1: d
                        , x2: g
                        , y2: h
                        , height: Math.abs(h - d)
                    }, a.boundingRect = {
                        x1: f
                        , y1: d
                        , x2: g
                        , y2: h
                        , width: g - f
                        , height: h - d
                    }, a.title && (a._titleTextBlock.maxWidth = 0 < a.titleMaxWidth && a.titleMaxWidth < a.lineCoordinates.height ? a.titleMaxWidth : a.lineCoordinates.height), a.calculateValueToPixelConversionParameters(), b && b.calculateValueToPixelConversionParameters(), c && c.calculateValueToPixelConversionParameters(), a || b || c) {
                    if (!m(C))
                        for (o = 0; o < C.length; o++)
                            for (j = o + 1; j < C.length; j++) C[o] == C[j] && (z = !0);
                    if (!m(D))
                        for (o = 0; o < D.length; o++)
                            for (j = o + 1; j < D.length; j++) D[o] == D[j] && (A = !0);
                    if (!m(F))
                        for (o = 0; o < F.length; o++)
                            for (j = o + 1; j < F.length; j++) F[o] == F[j] && (B = !0)
                }
                if (z && A && B) break
            }
            b && b.renderLabelsTicksAndTitle(), c && c.renderLabelsTicksAndTitle(), a.renderLabelsTicksAndTitle()
        }
        i.preparePlotArea(), e = a.chart.plotArea, k.save(), k.beginPath(), k.rect(e.x1, e.y1, Math.abs(e.x2 - e.x1), Math.abs(e.y2 - e.y1)), k.clip(), a.renderStripLinesOfThicknessType("value"), b && b.renderStripLinesOfThicknessType("value"), c && c.renderStripLinesOfThicknessType("value"), a.renderInterlacedColors(), b && b.renderInterlacedColors(), c && c.renderInterlacedColors(), k.restore(), a.renderGrid(), b && b.renderGrid(), c && c.renderGrid(), a.renderAxisLine(), b && b.renderAxisLine(), c && c.renderAxisLine(), a.renderStripLinesOfThicknessType("pixel"), b && b.renderStripLinesOfThicknessType("pixel"), c && c.renderStripLinesOfThicknessType("pixel")
    }, K.prototype.renderLabelsTicksAndTitle = function () {
        var a = !1
            , b = 0
            , c = 0
            , d = 1
            , e = 0;
        if (0 !== this.labelAngle && 360 !== this.labelAngle && (d = 1.2), "undefined" == typeof this._options.interval) {
            if ("bottom" === this._position || "top" === this._position)
                if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                    for (var f, b = [], d = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2, g = this.viewportMaximum, h = this.lineCoordinates.width / Math.log(this.range), i = this._labels.length - 1; 0 <= i && (k = this._labels[i], !(k.position < this.viewportMinimum)); i--) k.position > this.viewportMaximum || !(i === this._labels.length - 1 || f < Math.log(g / k.position) * h / d) || (b.push(k), g = k.position, f = k.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + k.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                    this._labels = b
                }
                else {
                    for (i = 0; i < this._labels.length; i++) k = this._labels[i], k.position < this.viewportMinimum || (k = k.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + k.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), b += k);
                    b > this.lineCoordinates.width * d && this.labelAutoFit && (a = !0)
                }
            if ("left" === this._position || "right" === this._position)
                if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                    for (var j, b = [], g = this.viewportMaximum, h = this.lineCoordinates.height / Math.log(this.range), i = this._labels.length - 1; 0 <= i && (k = this._labels[i], !(k.position < this.viewportMinimum)); i--) k.position > this.viewportMaximum || !(i === this._labels.length - 1 || j < Math.log(g / k.position) * h) || (b.push(k), g = k.position, j = k.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + k.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                    this._labels = b
                }
                else {
                    for (i = 0; i < this._labels.length; i++) k = this._labels[i], k.position < this.viewportMinimum || (k = k.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + k.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)), c += k);
                    c > this.lineCoordinates.height * d && this.labelAutoFit && (a = !0)
                }
        }
        if ("bottom" === this._position) {
            for (var k, i = 0; i < this._labels.length; i++) k = this._labels[i], k.position < this.viewportMinimum || k.position > this.viewportMaximum || (c = this.getPixelCoordinatesOnAxis(k.position), a && 0 !== e++ % 2 && this.labelAutoFit || (this.tickThickness && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, d = 1 === this.ctx.lineWidth % 2 ? (c.x << 0) + .5 : c.x << 0, this.ctx.beginPath(), this.ctx.moveTo(d, c.y << 0), this.ctx.lineTo(d, c.y + this.tickLength << 0), this.ctx.stroke()), 0 === k.textBlock.angle ? (c.x -= k.textBlock.width / 2, c.y += this.tickLength + k.textBlock.fontSize / 2) : (c.x -= 0 > this.labelAngle ? k.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, c.y += this.tickLength + Math.abs(0 > this.labelAngle ? k.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), k.textBlock.x = c.x, k.textBlock.y = c.y, k.textBlock.render(!0)));
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.boundingRect.y2 - this._titleTextBlock.height - 3, this._titleTextBlock.render(!0))
        }
        else if ("top" === this._position) {
            for (i = 0; i < this._labels.length; i++) k = this._labels[i], k.position < this.viewportMinimum || k.position > this.viewportMaximum || (c = this.getPixelCoordinatesOnAxis(k.position), a && 0 !== e++ % 2 && this.labelAutoFit || (this.tickThickness && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, d = 1 === this.ctx.lineWidth % 2 ? (c.x << 0) + .5 : c.x << 0, this.ctx.beginPath(), this.ctx.moveTo(d, c.y << 0), this.ctx.lineTo(d, c.y - this.tickLength << 0), this.ctx.stroke()), 0 === k.textBlock.angle ? (c.x -= k.textBlock.width / 2, c.y -= this.tickLength + k.textBlock.height) : (c.x += (k.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? k.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), c.y -= this.tickLength + (k.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? k.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0))), k.textBlock.x = c.x, k.textBlock.y = c.y, k.textBlock.render(!0)));
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.boundingRect.y1 + 1, this._titleTextBlock.render(!0))
        }
        else if ("left" === this._position) {
            for (i = 0; i < this._labels.length; i++) k = this._labels[i], k.position < this.viewportMinimum || k.position > this.viewportMaximum || (c = this.getPixelCoordinatesOnAxis(k.position), a && 0 !== e++ % 2 && this.labelAutoFit || (this.tickThickness && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, d = 1 === this.ctx.lineWidth % 2 ? (c.y << 0) + .5 : c.y << 0, this.ctx.beginPath(), this.ctx.moveTo(c.x << 0, d), this.ctx.lineTo(c.x - this.tickLength << 0, d), this.ctx.stroke()), 0 === this.labelAngle ? (k.textBlock.y = c.y, k.textBlock.x = c.x - k.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5) : (k.textBlock.y = c.y - k.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), k.textBlock.x = 0 < this.labelAngle ? c.x - k.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : c.x - k.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (k.textBlock.height - k.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength), k.textBlock.render(!0)));
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.boundingRect.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this._titleTextBlock.render(!0))
        }
        else if ("right" === this._position) {
            for (i = 0; i < this._labels.length; i++) k = this._labels[i], k.position < this.viewportMinimum || k.position > this.viewportMaximum || (c = this.getPixelCoordinatesOnAxis(k.position), a && 0 !== e++ % 2 && this.labelAutoFit || (this.tickThickness && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, d = 1 === this.ctx.lineWidth % 2 ? (c.y << 0) + .5 : c.y << 0, this.ctx.beginPath(), this.ctx.moveTo(c.x << 0, d), this.ctx.lineTo(c.x + this.tickLength << 0, d), this.ctx.stroke()), 0 === this.labelAngle ? (k.textBlock.y = c.y, k.textBlock.x = c.x + this.tickLength + 5) : (k.textBlock.y = 0 > this.labelAngle ? c.y : c.y - (k.textBlock.height - k.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), k.textBlock.x = 0 < this.labelAngle ? c.x + (k.textBlock.height - k.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : c.x + this.tickLength + 5), k.textBlock.render(!0)));
            this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.boundingRect.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this._titleTextBlock.render(!0))
        }
    }, K.prototype.renderInterlacedColors = function () {
        var b, c, a = this.chart.plotArea.ctx
            , d = this.chart.plotArea
            , e = 0;
        if (b = !0, "bottom" !== this._position && "top" !== this._position || !this.interlacedColor) {
            if (("left" === this._position || "right" === this._position) && this.interlacedColor)
                for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++) b ? (c = this.getPixelCoordinatesOnAxis(this._labels[e].position), b = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(d.x1, Math.min(c.y, b.y), Math.abs(d.x1 - d.x2), Math.abs(b.y - c.y)), b = !1) : b = !0
        }
        else
            for (a.fillStyle = this.interlacedColor, e = 0; e < this._labels.length; e++) b ? (b = this.getPixelCoordinatesOnAxis(this._labels[e].position), c = e + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[e + 1].position), a.fillRect(Math.min(c.x, b.x), d.y1, Math.abs(c.x - b.x), Math.abs(d.y1 - d.y2)), b = !1) : b = !0;
        a.beginPath()
    }, K.prototype.renderStripLinesOfThicknessType = function (a) {
        if (this.stripLines && 0 < this.stripLines.length && a) {
            for (var c, b = this, d = 0, e = 0, f = !1, g = !1, h = [], i = [], g = !1, d = 0; d < this.stripLines.length; d++) {
                var j = this.stripLines[d];
                j._thicknessType === a && ("pixel" === a && (j.value < this.viewportMinimum || j.value > this.viewportMaximum) || h.push(j))
            }
            for (d = 0; d < this._stripLineLabels.length; d++)
                if (j = this.stripLines[d], c = this._stripLineLabels[d], !(c.position < this.viewportMinimum || c.position > this.viewportMaximum)) {
                    if (a = this.getPixelCoordinatesOnAxis(c.position), "outside" === c.stripLine.labelPlacement)
                        if (j && (this.ctx.strokeStyle = j.color, "pixel" === j._thicknessType && (this.ctx.lineWidth = j.thickness)), "bottom" === this._position) {
                            var k = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + .5 : a.x << 0;
                            this.ctx.beginPath(), this.ctx.moveTo(k, a.y << 0), this.ctx.lineTo(k, a.y + this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a.x -= c.textBlock.width / 2, a.y += this.tickLength + c.textBlock.fontSize / 2) : (a.x -= 0 > this.labelAngle ? c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, a.y += this.tickLength + Math.abs(0 > this.labelAngle ? c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5))
                        }
                        else "top" === this._position ? (k = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + .5 : a.x << 0, this.ctx.beginPath(), this.ctx.moveTo(k, a.y << 0), this.ctx.lineTo(k, a.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (a.x -= c.textBlock.width / 2, a.y -= this.tickLength + c.textBlock.height) : (a.x += (c.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), a.y -= this.tickLength + (c.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : "left" === this._position ? (k = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + .5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, k), this.ctx.lineTo(a.x - this.tickLength << 0, k), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x - c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (a.y -= c.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x - c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : a.x - c.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (c.textBlock.height - c.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : "right" === this._position && (k = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + .5 : a.y << 0, this.ctx.beginPath(), this.ctx.moveTo(a.x << 0, k), this.ctx.lineTo(a.x + this.tickLength << 0, k), this.ctx.stroke(), 0 === this.labelAngle ? a.x = a.x + this.tickLength + 5 : (a.y = 0 > this.labelAngle ? a.y : a.y - (c.textBlock.height - c.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), a.x = 0 < this.labelAngle ? a.x + (c.textBlock.height - c.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : a.x + this.tickLength + 5));
                    else c.textBlock.angle = -90, "bottom" === this._position ? (c.textBlock.maxWidth = this._options.stripLines[d].labelMaxWidth ? this._options.stripLines[d].labelMaxWidth : this.chart.plotArea.height - 3, c.textBlock.measureText(), a.x - c.textBlock.height > this.chart.plotArea.x1 ? m(j.startValue) ? a.x -= c.textBlock.height - c.textBlock.fontSize / 2 : a.x -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 + 3 : (c.textBlock.angle = 90, m(j.startValue) ? a.x += c.textBlock.height - c.textBlock.fontSize / 2 : a.x += c.textBlock.height / 2 - c.textBlock.fontSize / 2 + 3), a.y = -90 === c.textBlock.angle ? "near" === c.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c.textBlock.width) / 2 : this.chart.plotArea.y1 + c.textBlock.width + 3 : "near" === c.stripLine.labelAlign ? this.chart.plotArea.y2 - c.textBlock.width - 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (c.textBlock.maxWidth = this._options.stripLines[d].labelMaxWidth ? this._options.stripLines[d].labelMaxWidth : this.chart.plotArea.height - 3, c.textBlock.measureText(), a.x - c.textBlock.height > this.chart.plotArea.x1 ? m(j.startValue) ? a.x -= c.textBlock.height - c.textBlock.fontSize / 2 : a.x -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 + 3 : (c.textBlock.angle = 90, m(j.startValue) ? a.x += c.textBlock.height - c.textBlock.fontSize / 2 : a.x += c.textBlock.height / 2 - c.textBlock.fontSize / 2 + 3), a.y = -90 === c.textBlock.angle ? "near" === c.stripLine.labelAlign ? this.chart.plotArea.y1 + c.textBlock.width + 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + c.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === c.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - c.textBlock.width) / 2 : this.chart.plotArea.y2 - c.textBlock.width - 3) : "left" === this._position ? (c.textBlock.maxWidth = this._options.stripLines[d].labelMaxWidth ? this._options.stripLines[d].labelMaxWidth : this.chart.plotArea.width - 3, c.textBlock.angle = 0, c.textBlock.measureText(), a.y - c.textBlock.height > this.chart.plotArea.y1 ? m(j.startValue) ? a.y -= c.textBlock.height - c.textBlock.fontSize / 2 : a.y -= c.textBlock.height / 2 - c.textBlock.fontSize + 3 : a.y - c.textBlock.height < this.chart.plotArea.y2 ? a.y += c.textBlock.fontSize / 2 + 3 : m(j.startValue) ? a.y -= c.textBlock.height - c.textBlock.fontSize / 2 : a.y -= c.textBlock.height / 2 - c.textBlock.fontSize + 3, a.x = "near" === c.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c.textBlock.width / 2 : this.chart.plotArea.x2 - c.textBlock.width - 3) : "right" === this._position && (c.textBlock.maxWidth = this._options.stripLines[d].labelMaxWidth ? this._options.stripLines[d].labelMaxWidth : this.chart.plotArea.width - 3, c.textBlock.angle = 0, c.textBlock.measureText(), a.y - +c.textBlock.height > this.chart.plotArea.y1 ? m(j.startValue) ? a.y -= c.textBlock.height - c.textBlock.fontSize / 2 : a.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 - 3 : a.y - c.textBlock.height < this.chart.plotArea.y2 ? a.y += c.textBlock.fontSize / 2 + 3 : m(j.startValue) ? a.y -= c.textBlock.height - c.textBlock.fontSize / 2 : a.y -= c.textBlock.height / 2 - c.textBlock.fontSize / 2 + 3, a.x = "near" === c.stripLine.labelAlign ? this.chart.plotArea.x2 - c.textBlock.width - 3 : "center" === c.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - c.textBlock.width / 2 : this.chart.plotArea.x1 + 3);
                    c.textBlock.x = a.x, c.textBlock.y = a.y, i.push(c)
                }
            if (!g) {
                for (g = !1, this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.ctx.clip(), d = 0; d < h.length; d++) j = h[d], j.showOnTop ? f || (f = !0, this.chart.addEventListener("dataAnimationIterationEnd", function () {
                    for (this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.ctx.clip(), e = 0; e < h.length; e++) j = h[e], j.showOnTop && j.render();
                    this.ctx.restore()
                }, j)) : j.render();
                for (d = 0; d < i.length; d++) c = i[d], c.stripLine.showOnTop ? g || (g = !0, this.chart.addEventListener("dataAnimationIterationEnd", function () {
                    for (e = 0; e < i.length; e++) c = i[e], "inside" === c.stripLine.labelPlacement && c.stripLine.showOnTop && (b.ctx.save(), b.ctx.beginPath(), b.ctx.rect(b.chart.plotArea.x1, b.chart.plotArea.y1, b.chart.plotArea.width, b.chart.plotArea.height), b.ctx.clip(), c.textBlock.render(!0), b.ctx.restore())
                }, c.textBlock)) : "inside" === c.stripLine.labelPlacement && c.textBlock.render(!0);
                this.ctx.restore(), g = !0
            }
            if (g)
                for (g = !1, d = 0; d < i.length; d++) c = i[d], c.stripLine.showOnTop ? g || (g = !0, this.chart.addEventListener("dataAnimationIterationEnd", function () {
                    for (e = 0; e < i.length; e++) c = i[e], "outside" === c.stripLine.labelPlacement && c.stripLine.showOnTop && c.textBlock.render(!0)
                }, c.textBlock)) : "outside" === c.stripLine.labelPlacement && c.textBlock.render(!0)
        }
    }, K.prototype.renderGrid = function () {
        if (this.gridThickness && 0 < this.gridThickness) {
            var a = this.chart.ctx;
            a.save();
            var b, c = this.chart.plotArea;
            if (a.lineWidth = this.gridThickness, a.strokeStyle = this.gridColor, a.setLineDash && a.setLineDash(o(this.gridDashType, this.gridThickness)), "bottom" === this._position || "top" === this._position)
                for (d = 0; d < this._labels.length; d++) this._labels[d].position < this.viewportMinimum || this._labels[d].position > this.viewportMaximum || (a.beginPath(), b = this.getPixelCoordinatesOnAxis(this._labels[d].position), b = 1 === a.lineWidth % 2 ? (b.x << 0) + .5 : b.x << 0, a.moveTo(b, c.y1 << 0), a.lineTo(b, c.y2 << 0), a.stroke());
            else if ("left" === this._position || "right" === this._position)
                for (var d = 0; d < this._labels.length; d++) this._labels[d].position < this.viewportMinimum || this._labels[d].position > this.viewportMaximum || (a.beginPath(), b = this.getPixelCoordinatesOnAxis(this._labels[d].position), b = 1 === a.lineWidth % 2 ? (b.y << 0) + .5 : b.y << 0, a.moveTo(c.x1 << 0, b), a.lineTo(c.x2 << 0, b), a.stroke());
            a.restore()
        }
    }, K.prototype.renderAxisLine = function () {
        var a = this.chart.ctx;
        if (a.save(), "bottom" === this._position || "top" === this._position) {
            if (this.lineThickness) {
                a.lineWidth = this.lineThickness, a.strokeStyle = this.lineColor ? this.lineColor : "black", a.setLineDash && a.setLineDash(o(this.lineDashType, this.lineThickness));
                var b = 1 === this.lineThickness % 2 ? (this.lineCoordinates.y1 << 0) + .5 : this.lineCoordinates.y1 << 0;
                a.beginPath(), a.moveTo(this.lineCoordinates.x1, b), a.lineTo(this.lineCoordinates.x2, b), a.stroke()
            }
        }
        else "left" !== this._position && "right" !== this._position || !this.lineThickness || (a.lineWidth = this.lineThickness, a.strokeStyle = this.lineColor, a.setLineDash && a.setLineDash(o(this.lineDashType, this.lineThickness)), b = 1 === this.lineThickness % 2 ? (this.lineCoordinates.x1 << 0) + .5 : this.lineCoordinates.x1 << 0, a.beginPath(), a.moveTo(b, this.lineCoordinates.y1), a.lineTo(b, this.lineCoordinates.y2), a.stroke());
        a.restore()
    }, K.prototype.getPixelCoordinatesOnAxis = function (a) {
        var b = {};
        return "bottom" !== this._position && "top" !== this._position || (b.x = this.convertValueToPixel(a), b.y = this.lineCoordinates.y1), "left" !== this._position && "right" !== this._position || (b.y = this.convertValueToPixel(a), b.x = this.lineCoordinates.x2), b
    }, K.prototype.convertPixelToValue = function (a) {
        if ("undefined" == typeof a) return null;
        var b = 0
            , b = 0
            , b = "number" == typeof a ? a : "left" === this._position || "right" === this._position ? a.y : a.x;
        return b = this.logarithmic ? Math.pow(this.logarithmBase, (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit) * this.viewportMinimum : this.conversionParameters.minimum + (b - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit
    }, K.prototype.setViewPortRange = function (a, b) {
        this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(a, b), this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(a, b)
    }, K.prototype.getXValueAt = function (a) {
        if (!a) return null;
        var b = null;
        return "left" === this._position ? b = this.convertPixelToValue(a.y) : "bottom" === this._position && (b = this.convertPixelToValue(a.x)), b
    }, K.prototype.calculateValueToPixelConversionParameters = function (a) {
        a = {
            pixelPerUnit: null
            , minimum: null
            , reference: null
        };
        var b = this.lineCoordinates.width
            , c = this.lineCoordinates.height;
        a.minimum = this.viewportMinimum, "bottom" !== this._position && "top" !== this._position || (this.logarithmic ? (a.lnLogarithmBase = Math.log(this.logarithmBase), a.pixelPerUnit = (this.reversed ? -1 : 1) * b * a.lnLogarithmBase / Math.log(Math.abs(this.range))) : a.pixelPerUnit = (this.reversed ? -1 : 1) * b / Math.abs(this.range), a.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1), "left" !== this._position && "right" !== this._position || (this.logarithmic ? (a.lnLogarithmBase = Math.log(this.logarithmBase), a.pixelPerUnit = (this.reversed ? 1 : -1) * c * a.lnLogarithmBase / Math.log(Math.abs(this.range))) : a.pixelPerUnit = (this.reversed ? 1 : -1) * c / Math.abs(this.range), a.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2), this.conversionParameters = a
    }, K.prototype.convertValueToPixel = function (a) {
        return this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(a / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + .5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (a - this.conversionParameters.minimum) + .5 << 0
    }, K.prototype.calculateAxisParameters = function () {
        if (this.logarithmic) this.calculateLogarithamicAxisParameters();
        else {
            var a = this.chart.layoutManager.getFreeSpace()
                , b = !1;
            "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
            var a = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40
                , c = 4;
            "axisX" === this.type && (c = 100 > this.maxWidth ? 3 : 300 > this.maxWidth ? 6 : 600 > this.maxWidth ? 8 : 6);
            var d, e, f, a = Math.max(c, Math.floor(this.maxWidth / a))
                , c = 0;
            if ((null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = this.minimum), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = this.maximum), "axisX" === this.type ? (d = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 === e - d && (c = "undefined" == typeof this._options.interval ? .4 : this._options.interval, e += c, d -= c), 1 / 0 !== this.dataInfo.minDiff ? f = this.dataInfo.minDiff : 1 < e - d ? f = .5 * Math.abs(e - d) : (f = 1, "dateTime" === this.chart.plotInfo.axisXValueType && (b = !0))) : "axisY" === this.type && (d = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(d) || isFinite(e) ? isFinite(d) ? isFinite(e) || (e = d) : d = e : (e = "undefined" == typeof this._options.interval ? -(1 / 0) : this._options.interval, d = 0), 0 === d && 0 === e ? (e += 9, d = 0) : 0 === e - d ? (c = Math.min(Math.abs(.01 * Math.abs(e)), 5), e += c, d -= c) : d > e ? (c = Math.min(Math.abs(.01 * Math.abs(e - d)), 5), 0 <= e ? d = e - c : e = d + c) : (c = Math.min(Math.abs(.01 * Math.abs(e - d)), .05), 0 !== e && (e += c), 0 !== d && (d -= c)), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < e - d ? .5 * Math.abs(e - d) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < d && (d = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > e && (e = 0)), c = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? d : this.viewportMinimum), "axisX" === this.type && "dateTime" === this.chart.plotInfo.axisXValueType ? (this.intervalType || (c / 1 <= a ? (this.interval = 1, this.intervalType = "millisecond") : c / 2 <= a ? (this.interval = 2, this.intervalType = "millisecond") : c / 5 <= a ? (this.interval = 5, this.intervalType = "millisecond") : c / 10 <= a ? (this.interval = 10, this.intervalType = "millisecond") : c / 20 <= a ? (this.interval = 20, this.intervalType = "millisecond") : c / 50 <= a ? (this.interval = 50, this.intervalType = "millisecond") : c / 100 <= a ? (this.interval = 100, this.intervalType = "millisecond") : c / 200 <= a ? (this.interval = 200, this.intervalType = "millisecond") : c / 250 <= a ? (this.interval = 250, this.intervalType = "millisecond") : c / 300 <= a ? (this.interval = 300, this.intervalType = "millisecond") : c / 400 <= a ? (this.interval = 400, this.intervalType = "millisecond") : c / 500 <= a ? (this.interval = 500, this.intervalType = "millisecond") : c / (1 * W.secondDuration) <= a ? (this.interval = 1, this.intervalType = "second") : c / (2 * W.secondDuration) <= a ? (this.interval = 2, this.intervalType = "second") : c / (5 * W.secondDuration) <= a ? (this.interval = 5, this.intervalType = "second") : c / (10 * W.secondDuration) <= a ? (this.interval = 10, this.intervalType = "second") : c / (15 * W.secondDuration) <= a ? (this.interval = 15, this.intervalType = "second") : c / (20 * W.secondDuration) <= a ? (this.interval = 20, this.intervalType = "second") : c / (30 * W.secondDuration) <= a ? (this.interval = 30, this.intervalType = "second") : c / (1 * W.minuteDuration) <= a ? (this.interval = 1, this.intervalType = "minute") : c / (2 * W.minuteDuration) <= a ? (this.interval = 2, this.intervalType = "minute") : c / (5 * W.minuteDuration) <= a ? (this.interval = 5, this.intervalType = "minute") : c / (10 * W.minuteDuration) <= a ? (this.interval = 10, this.intervalType = "minute") : c / (15 * W.minuteDuration) <= a ? (this.interval = 15, this.intervalType = "minute") : c / (20 * W.minuteDuration) <= a ? (this.interval = 20, this.intervalType = "minute") : c / (30 * W.minuteDuration) <= a ? (this.interval = 30, this.intervalType = "minute") : c / (1 * W.hourDuration) <= a ? (this.interval = 1, this.intervalType = "hour") : c / (2 * W.hourDuration) <= a ? (this.interval = 2, this.intervalType = "hour") : c / (3 * W.hourDuration) <= a ? (this.interval = 3, this.intervalType = "hour") : c / (6 * W.hourDuration) <= a ? (this.interval = 6, this.intervalType = "hour") : c / (1 * W.dayDuration) <= a ? (this.interval = 1, this.intervalType = "day") : c / (2 * W.dayDuration) <= a ? (this.interval = 2, this.intervalType = "day") : c / (4 * W.dayDuration) <= a ? (this.interval = 4, this.intervalType = "day") : c / (1 * W.weekDuration) <= a ? (this.interval = 1, this.intervalType = "week") : c / (2 * W.weekDuration) <= a ? (this.interval = 2, this.intervalType = "week") : c / (3 * W.weekDuration) <= a ? (this.interval = 3, this.intervalType = "week") : c / (1 * W.monthDuration) <= a ? (this.interval = 1, this.intervalType = "month") : c / (2 * W.monthDuration) <= a ? (this.interval = 2, this.intervalType = "month") : c / (3 * W.monthDuration) <= a ? (this.interval = 3, this.intervalType = "month") : c / (6 * W.monthDuration) <= a ? (this.interval = 6, this.intervalType = "month") : (this.interval = c / (1 * W.yearDuration) <= a ? 1 : c / (2 * W.yearDuration) <= a ? 2 : c / (4 * W.yearDuration) <= a ? 4 : Math.floor(K.getNiceNumber(c / (a - 1), !0) / W.yearDuration), this.intervalType = "year")), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = d - f / 2), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = e + f / 2), b ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ? this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'"), this.valueFormatString || (this.valueFormatString = this.autoValueFormatString)) : (this.intervalType = "number", c = K.getNiceNumber(c, !1), this.interval = this._options && 0 < this._options.interval ? this._options.interval : K.getNiceNumber(c / (a - 1), !0), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = "axisX" === this.type ? d - f / 2 : Math.floor(d / this.interval) * this.interval), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = "axisX" === this.type ? e + f / 2 : Math.ceil(e / this.interval) * this.interval), 0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this._options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this._options.viewportMaximum && (this.viewportMinimum -= 10), this._options && "undefined" == typeof this._options.interval && (this.interval = K.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0)))), null !== this.minimum && null !== this.maximum || ("axisX" === this.type ? (d = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 0 === e - d && (c = "undefined" == typeof this._options.interval ? .4 : this._options.interval, e += c, d -= c), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < e - d ? .5 * Math.abs(e - d) : 1) : "axisY" === this.type && (d = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(d) || isFinite(e) ? 0 === d && 0 === e ? (e += 9, d = 0) : 0 === e - d ? (c = Math.min(Math.abs(.01 * Math.abs(e)), 5), e += c, d -= c) : d > e ? (c = Math.min(Math.abs(.01 * Math.abs(e - d)), 5), 0 <= e ? d = e - c : e = d + c) : (c = Math.min(Math.abs(.01 * Math.abs(e - d)), .05), 0 !== e && (e += c), 0 !== d && (d -= c)) : (e = "undefined" == typeof this._options.interval ? -(1 / 0) : this._options.interval, d = 0), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < e - d ? .5 * Math.abs(e - d) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < d && (d = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > e && (e = 0)), "axisX" === this.type && "dateTime" === this.chart.plotInfo.axisXValueType ? ((null === this.minimum || isNaN(this.minimum)) && (this.minimum = d - f / 2), (null === this.maximum || isNaN(this.maximum)) && (this.maximum = e + f / 2)) : (this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? d - f / 2 : Math.floor(d / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? 1 / 0 : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? e + f / 2 : Math.ceil(e / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -(1 / 0) : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this._options.minimum ? this.maximum += 10 : 0 === this._options.maximum && (this.minimum -= 10)))), this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum), this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum), this.range = this.viewportMaximum - this.viewportMinimum, this.intervalStartPosition = "axisX" === this.type && "dateTime" === this.chart.plotInfo.axisXValueType ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + .2 * this.interval) / this.interval) * this.interval, !this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.range) && (b = Math.floor(Math.abs(Math.log(this.range) / Math.LN10)) + 2, !isNaN(b) && isFinite(b) || (b = 2), 2 < b))
                for (d = 0; d < b - 2; d++) this.valueFormatString += "#"
        }
    }, K.prototype.calculateLogarithamicAxisParameters = function () {
        var c, a = this.chart.layoutManager.getFreeSpace()
            , b = Math.log(this.logarithmBase);
        "bottom" === this._position || "top" === this._position ? (this.maxWidth = a.width, this.maxHeight = a.height) : (this.maxWidth = a.height, this.maxHeight = a.width);
        var d, e, f, g, a = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3);
        if (g = 1, (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = this.minimum), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = this.maximum), "axisX" === this.type ? (d = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 1 === e / d && (g = Math.pow(this.logarithmBase, "undefined" == typeof this._options.interval ? .4 : this._options.interval), e *= g, d /= g), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / d > this.logarithmBase ? e / d * Math.pow(this.logarithmBase, .5) : this.logarithmBase) : "axisY" === this.type && (d = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, e = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= d && !isFinite(e) ? (e = "undefined" == typeof this._options.interval ? 0 : this._options.interval, d = 1) : 0 >= d ? d = e : isFinite(e) || (e = d), 1 === d && 1 === e ? (e *= this.logarithmBase - 1 / this.logarithmBase, d = 1) : 1 === e / d ? (g = Math.min(e * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5)), e *= g, d /= g) : d > e ? (g = Math.min(d / e * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5)), 1 <= e ? d = e / g : e = d * g) : (g = Math.min(e / d * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04)), 1 !== e && (e *= g), 1 !== d && (d /= g)), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / d > this.logarithmBase ? e / d * Math.pow(this.logarithmBase, .5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < d && (d = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > e && (e = 1)), g = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? d : this.viewportMinimum), linearRange = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? e : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? d : this.viewportMinimum), this.intervalType = "number", g = Math.pow(this.logarithmBase, K.getNiceNumber(Math.abs(Math.log(g) / b), !1)), this._options && 0 < this._options.interval ? this.interval = this._options.interval : (this.interval = K.getNiceExponent(Math.log(g) / b / (a - 1), !0), c = K.getNiceNumber(linearRange / (a - 1), !0)), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = "axisX" === this.type ? d / Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(d) / b / this.interval))), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = "axisX" === this.type ? e * Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / b / this.interval))), 1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this._options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this._options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this._options && "undefined" == typeof this._options.interval && (this.interval = K.getNiceExponent(Math.ceil(Math.log(g) / b) / (a - 1)), c = K.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (a - 1), !0))), null !== this.minimum && null !== this.maximum || ("axisX" === this.type ? (d = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, 1 === e / d && (g = Math.pow(this.logarithmBase, "undefined" == typeof this._options.interval ? .4 : this._options.interval), e *= g, d /= g), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / d > this.logarithmBase ? e / d * Math.pow(this.logarithmBase, .5) : this.logarithmBase) : "axisY" === this.type && (d = null !== this.minimum ? this.minimum : this.dataInfo.min, e = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(d) || isFinite(e) ? 1 === d && 1 === e ? (e *= this.logarithmBase, d /= this.logarithmBase) : 1 === e / d ? (g = Math.pow(this.logarithmBase, this.interval), e *= g, d /= g) : d > e ? (g = Math.min(.01 * (d / e), 5), 1 <= e ? d = e / g : e = d * g) : (g = Math.min(e / d * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04)), 1 !== e && (e *= g), 1 !== d && (d /= g)) : (e = "undefined" == typeof this._options.interval ? 0 : this._options.interval, d = 1), f = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : e / d > this.logarithmBase ? e / d * Math.pow(this.logarithmBase, .5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < d && (d = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > e && (e = 1)), this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? d / Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(d) / b / this.interval)), this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? "undefined" == typeof this.sessionVariables.newViewportMinimum ? 1 / 0 : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? e * Math.sqrt(f) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(e) / b / this.interval)), this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? "undefined" == typeof this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum)), 1 === this.maximum && 1 === this.minimum && (1 === this._options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this._options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase))), this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum), this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum), this.viewportMinimum > this.viewportMaximum && (!this._options.viewportMinimum && !this._options.minimum || this._options.viewportMaximum || this._options.maximum ? this._options.viewportMinimum || this._options.minimum || !this._options.viewportMaximum && !this._options.maximum || (this.viewportMinimum = this.minimum = (this._options.viewportMaximum || this._options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this._options.viewportMinimum || this._options.minimum), d = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (b * this.interval) + .2) * this.interval), this.range = this.viewportMaximum / this.viewportMinimum, this.noTicks = a, !this._options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > a ? 2 : 3)) {
            for (b = Math.floor(this.viewportMinimum / c + .5) * c; b < this.viewportMinimum;) b += c;
            this.equidistantInterval = !1, this.intervalStartPosition = b, this.interval = c
        }
        else this._options.interval || (c = Math.ceil(this.interval), this.range > this.interval && (this.interval = c, d = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (b * this.interval) + .2) * this.interval))), this.equidistantInterval = !0, this.intervalStartPosition = d;
        if (!this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum) && (b = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2, !isNaN(b) && isFinite(b) || (b = 2), 2 < b))
            for (c = 0; c < b - 2; c++) this.valueFormatString += "#"
    }, K.getNiceExponent = function (a, b) {
        var c = Math.floor(Math.log(a) / Math.LN10)
            , d = a / Math.pow(10, c)
            , d = 0 > c ? 1 >= d ? 1 : 5 >= d ? 5 : 10 : Math.max(Math.floor(d), 1);
        return Number((d * Math.pow(10, c)).toFixed(20))
    }, K.getNiceNumber = function (a, b) {
        var c = Math.floor(Math.log(a) / Math.LN10)
            , d = a / Math.pow(10, c);
        return Number(((b ? 1.5 > d ? 1 : 3 > d ? 2 : 7 > d ? 5 : 10 : 1 >= d ? 1 : 2 >= d ? 2 : 5 >= d ? 5 : 10) * Math.pow(10, c)).toFixed(20))
    }, K.prototype.getLabelStartPoint = function () {
        var a = W[this.intervalType + "Duration"] * this.interval
            , a = new Date(Math.floor(this.viewportMinimum / a) * a);
        return "millisecond" !== this.intervalType && ("second" === this.intervalType ? 0 < a.getMilliseconds() && (a.setSeconds(a.getSeconds() + 1), a.setMilliseconds(0)) : "minute" === this.intervalType ? (0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setMinutes(a.getMinutes() + 1), a.setSeconds(0), a.setMilliseconds(0)) : "hour" === this.intervalType ? (0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setHours(a.getHours() + 1), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)) : "day" === this.intervalType ? (0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setDate(a.getDate() + 1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)) : "week" === this.intervalType ? (0 < a.getDay() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setDate(a.getDate() + (7 - a.getDay())), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)) : "month" === this.intervalType ? (1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setMonth(a.getMonth() + 1), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0)) : "year" === this.intervalType && (0 < a.getMonth() || 1 < a.getDate() || 0 < a.getHours() || 0 < a.getMinutes() || 0 < a.getSeconds() || 0 < a.getMilliseconds()) && (a.setFullYear(a.getFullYear() + 1), a.setMonth(0), a.setDate(1), a.setHours(0), a.setMinutes(0), a.setSeconds(0), a.setMilliseconds(0))), a
    }, a(L, z), L.prototype.render = function () {
        this.ctx.save();
        var a = this.parent.getPixelCoordinatesOnAxis(this.value)
            , b = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness);
        if (0 < b) {
            var c = null === this.opacity ? 1 : this.opacity;
            this.ctx.strokeStyle = this.color, this.ctx.beginPath();
            var d = this.ctx.globalAlpha;
            this.ctx.globalAlpha = c, k(this.id);
            var e, f, g, h;
            this.ctx.lineWidth = b, this.ctx.setLineDash && this.ctx.setLineDash(o(this.lineDashType, b)), "bottom" === this.parent._position || "top" === this.parent._position ? (e = f = 1 === this.ctx.lineWidth % 2 ? (a.x << 0) + .5 : a.x << 0, g = this.chart.plotArea.y1, h = this.chart.plotArea.y2) : "left" !== this.parent._position && "right" !== this.parent._position || (g = h = 1 === this.ctx.lineWidth % 2 ? (a.y << 0) + .5 : a.y << 0, e = this.chart.plotArea.x1, f = this.chart.plotArea.x2), this.ctx.moveTo(e, g), this.ctx.lineTo(f, h), this.ctx.stroke(), this.ctx.globalAlpha = d
        }
        this.ctx.restore()
    }, a(M, z), M.prototype._initialize = function () {
        if (this.enabled) {
            this.container = document.createElement("div"), this.container.setAttribute("class", "canvasjs-chart-tooltip"), this.container.style.position = "absolute", this.container.style.height = "auto", this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)", this.container.style.zIndex = "1000", this.container.style.display = "none";
            var a;
            a = '<div style=" width: auto;height: auto;min-width: 50px;', a += "line-height: auto;", a += "margin: 0px 0px 0px 0px;", a += "padding: 5px;", a += "font-family: Calibri, Arial, Georgia, serif;", a += "font-weight: normal;", a += "font-style: " + (R ? "italic;" : "normal;"), a += "font-size: 14px;", a += "color: #000000;", a += "text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);", a += "text-align: left;", a += "border: 2px solid gray;", a += R ? "background: rgba(255,255,255,.9);" : "background: rgb(255,255,255);", a += "text-indent: 0px;", a += "white-space: nowrap;", a += "border-radius: 5px;", a += "-moz-user-select:none;", a += "-khtml-user-select: none;", a += "-webkit-user-select: none;", a += "-ms-user-select: none;", a += "user-select: none;", R || (a += "filter: alpha(opacity = 90);", a += "filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');"), a += '} "> Sample Tooltip</div>', this.container.innerHTML = a, this.contentDiv = this.container.firstChild, this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.chart._canvasJSContainer.appendChild(this.container)
        }
    }, M.prototype.mouseMoveHandler = function (a, b) {
        this._lastUpdated && 40 > (new Date).getTime() - this._lastUpdated || (this._lastUpdated = (new Date).getTime(), this._updateToolTip(a, b))
    }, M.prototype._updateToolTip = function (a, b) {
        if (!this.chart.disableToolTip) {
            if ("undefined" == typeof a || "undefined" == typeof b) {
                if (isNaN(this._prevX) || isNaN(this._prevY)) return;
                a = this._prevX, b = this._prevY
            }
            else this._prevX = a, this._prevY = b;
            var c = null
                , d = null
                , e = []
                , f = 0;
            if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) {
                for (f = "xySwapped" === this.chart.plotInfo.axisPlacement ? this.chart.axisX.convertPixelToValue({
                        y: b
                    }) : this.chart.axisX.convertPixelToValue({
                        x: a
                    }), d = [], c = 0; c < this.chart.data.length; c++) {
                    var g = this.chart.data[c].getDataPointAtX(f, !0);
                    g && 0 <= g.index && (g.dataSeries = this.chart.data[c], null !== g.dataPoint.y && d.push(g))
                }
                if (0 === d.length) return;
                for (d.sort(function (a, b) {
                        return a.distance - b.distance
                    }), f = d[0], c = 0; c < d.length; c++) d[c].dataPoint.x.valueOf() === f.dataPoint.x.valueOf() && e.push(d[c]);
                d = null
            }
            else {
                if (g = this.chart.getDataPointAtXY(a, b, !0)) this.currentDataPointIndex = g.dataPointIndex, this.currentSeriesIndex = g.dataSeries.index;
                else if (R)
                    if (g = q(a, b, this.chart._eventManager.ghostCtx), 0 < g && "undefined" != typeof this.chart._eventManager.objectMap[g]) {
                        if (g = this.chart._eventManager.objectMap[g], "legendItem" === g.objectType) return;
                        this.currentSeriesIndex = g.dataSeriesIndex, this.currentDataPointIndex = 0 <= g.dataPointIndex ? g.dataPointIndex : -1
                    }
                    else this.currentDataPointIndex = -1;
                else this.currentDataPointIndex = -1;
                if (0 <= this.currentSeriesIndex) {
                    if (d = this.chart.data[this.currentSeriesIndex], g = {}, 0 <= this.currentDataPointIndex) c = d.dataPoints[this.currentDataPointIndex], g.dataSeries = d, g.dataPoint = c, g.index = this.currentDataPointIndex, g.distance = Math.abs(c.x - f);
                    else {
                        if (!this.enabled || "line" !== d.type && "stepLine" !== d.type && "spline" !== d.type && "area" !== d.type && "stepArea" !== d.type && "splineArea" !== d.type && "stackedArea" !== d.type && "stackedArea100" !== d.type && "rangeArea" !== d.type && "rangeSplineArea" !== d.type && "candlestick" !== d.type && "ohlc" !== d.type) return;
                        f = d.axisX.convertPixelToValue({
                            x: a
                        }), g = d.getDataPointAtX(f, !0), g.dataSeries = d, this.currentDataPointIndex = g.index, c = g.dataPoint
                    }
                    if (!m(g.dataPoint.y))
                        if (g.dataSeries.axisY)
                            if (0 < g.dataPoint.y.length) {
                                for (c = f = 0; c < g.dataPoint.y.length; c++) g.dataPoint.y[c] < g.dataSeries.axisY.viewportMinimum ? f-- : g.dataPoint.y[c] > g.dataSeries.axisY.viewportMaximum && f++;
                                f < g.dataPoint.y.length && f > -g.dataPoint.y.length && e.push(g)
                            }
                            else "column" === d.type || "bar" === d.type ? 0 > g.dataPoint.y ? 0 > g.dataSeries.axisY.viewportMinimum && g.dataSeries.axisY.viewportMaximum >= g.dataPoint.y && e.push(g) : g.dataSeries.axisY.viewportMinimum <= g.dataPoint.y && 0 <= g.dataSeries.axisY.viewportMaximum && e.push(g) : "bubble" === d.type ? (f = this.chart._eventManager.objectMap[d.dataPointIds[g.index]].size / 2, g.dataPoint.y >= g.dataSeries.axisY.viewportMinimum - f && g.dataPoint.y <= g.dataSeries.axisY.viewportMaximum + f && e.push(g)) : (0 <= g.dataSeries.type.indexOf("100") || "stackedColumn" === d.type || "stackedBar" === d.type || g.dataPoint.y >= g.dataSeries.axisY.viewportMinimum && g.dataPoint.y <= g.dataSeries.axisY.viewportMaximum) && e.push(g);
                    else e.push(g)
                }
            }
            if (0 < e.length && (this.highlightObjects(e), this.enabled))
                if (f = "", f = this.getToolTipInnerHTML({
                        entries: e
                    }), null !== f) {
                    this.contentDiv.innerHTML = f, this.contentDiv.innerHTML = f, f = !1, "none" === this.container.style.display && (f = !0, this.container.style.display = "block");
                    try {
                        this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : R ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.borderColor ? this.borderColor : e[0].dataPoint.color ? e[0].dataPoint.color : e[0].dataSeries.color ? e[0].dataSeries.color : e[0].dataSeries._colorSet[e[0].index % e[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : R ? "italic" : "normal"
                    }
                    catch (a) {}
                    "pie" === e[0].dataSeries.type || "doughnut" === e[0].dataSeries.type || "funnel" === e[0].dataSeries.type || "bar" === e[0].dataSeries.type || "rangeBar" === e[0].dataSeries.type || "stackedBar" === e[0].dataSeries.type || "stackedBar100" === e[0].dataSeries.type ? g = a - 10 - this.container.clientWidth : (g = e[0].dataSeries.axisX.convertValueToPixel(e[0].dataPoint.x) - this.container.clientWidth << 0, g -= 10), 0 > g && (g += this.container.clientWidth + 20), g + this.container.clientWidth > Math.max(this.chart._container.clientWidth, this.chart.width) && (g = Math.max(0, Math.max(this.chart._container.clientWidth, this.chart.width) - this.container.clientWidth)), g += "px", e = 1 !== e.length || this.shared || "line" !== e[0].dataSeries.type && "stepLine" !== e[0].dataSeries.type && "spline" !== e[0].dataSeries.type && "area" !== e[0].dataSeries.type && "stepArea" !== e[0].dataSeries.type && "splineArea" !== e[0].dataSeries.type ? "bar" === e[0].dataSeries.type || "rangeBar" === e[0].dataSeries.type || "stackedBar" === e[0].dataSeries.type || "stackedBar100" === e[0].dataSeries.type ? e[0].dataSeries.axisX.convertValueToPixel(e[0].dataPoint.x) : b : e[0].dataSeries.axisY.convertValueToPixel(e[0].dataPoint.y), e = -e + 10, 0 < e + this.container.clientHeight + 5 && (e -= e + this.container.clientHeight + 5 - 0), this.container.style.left = g, this.container.style.bottom = e + "px", !this.animationEnabled || f ? this.disableAnimation() : this.enableAnimation()
                }
                else this.hide(!1)
        }
    }, M.prototype.highlightObjects = function (a) {
        var b = this.chart.overlaidCanvasCtx;
        this.chart.resetOverlayedCanvas(), b.clearRect(0, 0, this.chart.width, this.chart.height), b.save();
        var c = this.chart.plotArea
            , d = 0;
        for (b.beginPath(), b.rect(c.x1, c.y1, c.x2 - c.x1, c.y2 - c.y1), b.clip(), c = 0; c < a.length; c++) {
            var e = a[c];
            if ((e = this.chart._eventManager.objectMap[e.dataSeries.dataPointIds[e.index]]) && e.objectType && "dataPoint" === e.objectType) {
                var d = this.chart.data[e.dataSeriesIndex]
                    , f = d.dataPoints[e.dataPointIndex]
                    , g = e.dataPointIndex;
                !1 === f.highlightEnabled || !0 !== d.highlightEnabled && !0 !== f.highlightEnabled || ("line" === d.type || "stepLine" === d.type || "spline" === d.type || "scatter" === d.type || "area" === d.type || "stepArea" === d.type || "splineArea" === d.type || "stackedArea" === d.type || "stackedArea100" === d.type || "rangeArea" === d.type || "rangeSplineArea" === d.type ? (f = d.getMarkerProperties(g, e.x1, e.y1, this.chart.overlaidCanvasCtx), f.size = Math.max(1.5 * f.size << 0, 10), f.borderColor = f.borderColor || "#FFFFFF", f.borderThickness = f.borderThickness || Math.ceil(.1 * f.size), ja.drawMarkers([f]), "undefined" != typeof e.y2 && (f = d.getMarkerProperties(g, e.x1, e.y2, this.chart.overlaidCanvasCtx), f.size = Math.max(1.5 * f.size << 0, 10), f.borderColor = f.borderColor || "#FFFFFF", f.borderThickness = f.borderThickness || Math.ceil(.1 * f.size), ja.drawMarkers([f]))) : "bubble" === d.type ? (f = d.getMarkerProperties(g, e.x1, e.y1, this.chart.overlaidCanvasCtx), f.size = e.size, f.color = "white", f.borderColor = "white", b.globalAlpha = .3, ja.drawMarkers([f]), b.globalAlpha = 1) : "column" === d.type || "stackedColumn" === d.type || "stackedColumn100" === d.type || "bar" === d.type || "rangeBar" === d.type || "stackedBar" === d.type || "stackedBar100" === d.type || "rangeColumn" === d.type ? ga(b, e.x1, e.y1, e.x2, e.y2, "white", 0, null, !1, !1, !1, !1, .3) : "pie" === d.type || "doughnut" === d.type ? ha(b, e.center, e.radius, "white", d.type, e.startAngle, e.endAngle, .3, e.percentInnerRadius) : "candlestick" === d.type ? (b.globalAlpha = 1, b.strokeStyle = e.color, b.lineWidth = 2 * e.borderThickness, d = 0 === b.lineWidth % 2 ? 0 : .5, b.beginPath(), b.moveTo(e.x3 - d, Math.min(e.y2, e.y3)), b.lineTo(e.x3 - d, Math.min(e.y1, e.y4)), b.stroke(), b.beginPath(), b.moveTo(e.x3 - d, Math.max(e.y1, e.y4)), b.lineTo(e.x3 - d, Math.max(e.y2, e.y3)), b.stroke(), ga(b, e.x1, Math.min(e.y1, e.y4), e.x2, Math.max(e.y1, e.y4), "transparent", 2 * e.borderThickness, e.color, !1, !1, !1, !1), b.globalAlpha = 1) : "ohlc" === d.type && (b.globalAlpha = 1, b.strokeStyle = e.color, b.lineWidth = 2 * e.borderThickness, d = 0 === b.lineWidth % 2 ? 0 : .5, b.beginPath(), b.moveTo(e.x3 - d, e.y2), b.lineTo(e.x3 - d, e.y3), b.stroke(), b.beginPath(), b.moveTo(e.x3, e.y1), b.lineTo(e.x1, e.y1), b.stroke(), b.beginPath(), b.moveTo(e.x3, e.y4), b.lineTo(e.x2, e.y4), b.stroke(), b.globalAlpha = 1))
            }
        }
        b.restore(), b.globalAlpha = 1, b.beginPath()
    }, M.prototype.getToolTipInnerHTML = function (a) {
        a = a.entries;
        for (var b = null, c = null, d = null, e = 0, f = "", g = !0, h = 0; h < a.length; h++)
            if (a[h].dataSeries.toolTipContent || a[h].dataPoint.toolTipContent) {
                g = !1;
                break
            }
        if (g && (this.content && "function" == typeof this.content || this.contentFormatter)) a = {
            chart: this.chart._publicChartReference
            , toolTip: this._options
            , entries: a
        }, b = this.contentFormatter ? this.contentFormatter(a) : this.content(a);
        else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) {
            for (var i = "", h = 0; h < a.length; h++) c = a[h].dataSeries, d = a[h].dataPoint, e = a[h].index, f = "", 0 === h && g && !this.content && (i += "undefined" != typeof this.chart.axisX.labels[d.x] ? this.chart.axisX.labels[d.x] : "{x}", i += "</br>", i = this.chart.replaceKeywordsWithValue(i, d, c, e)), null === d.toolTipContent || "undefined" == typeof d.toolTipContent && null === c._options.toolTipContent || ("line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "column" === c.type || "bar" === c.type || "scatter" === c.type || "stackedColumn" === c.type || "stackedColumn100" === c.type || "stackedBar" === c.type || "stackedBar100" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type ? f += d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}" : "bubble" === c.type ? f += d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type ? f += d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}" : "candlestick" !== c.type && "ohlc" !== c.type || (f += d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}"), null === b && (b = ""), !0 === this.reversed ? (b = this.chart.replaceKeywordsWithValue(f, d, c, e) + b, h < a.length - 1 && (b = "</br>" + b)) : (b += this.chart.replaceKeywordsWithValue(f, d, c, e), h < a.length - 1 && (b += "</br>")));
            null !== b && (b = i + b)
        }
        else {
            if (c = a[0].dataSeries, d = a[0].dataPoint, e = a[0].index, null === d.toolTipContent || "undefined" == typeof d.toolTipContent && null === c._options.toolTipContent) return null;
            "line" === c.type || "stepLine" === c.type || "spline" === c.type || "area" === c.type || "stepArea" === c.type || "splineArea" === c.type || "column" === c.type || "bar" === c.type || "scatter" === c.type || "stackedColumn" === c.type || "stackedColumn100" === c.type || "stackedBar" === c.type || "stackedBar100" === c.type || "stackedArea" === c.type || "stackedArea100" === c.type ? f = d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>" + (d.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === c.type ? f = d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>" + (d.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === c.type || "doughnut" === c.type || "funnel" === c.type ? f = d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>" + (d.name ? "{name}:</span>&nbsp;&nbsp;" : d.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === c.type || "rangeBar" === c.type || "rangeArea" === c.type || "rangeSplineArea" === c.type ? f = d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>" + (d.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" : "candlestick" !== c.type && "ohlc" !== c.type || (f = d.toolTipContent ? d.toolTipContent : c.toolTipContent ? c.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.fontColor ? "" : "'color:{color};'") + "\"'>" + (d.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}"), null === b && (b = ""), b += this.chart.replaceKeywordsWithValue(f, d, c, e)
        }
        return b
    }, M.prototype.enableAnimation = function () {
        this.container.style.WebkitTransition || (this.container.style.WebkitTransition = "left .2s ease-out, bottom .2s ease-out", this.container.style.MozTransition = "left .2s ease-out, bottom .2s ease-out", this.container.style.MsTransition = "left .2s ease-out, bottom .2s ease-out", this.container.style.transition = "left .2s ease-out, bottom .2s ease-out")
    }, M.prototype.disableAnimation = function () {
        this.container.style.WebkitTransition && (this.container.style.WebkitTransition = "", this.container.style.MozTransition = "", this.container.style.MsTransition = "", this.container.style.transition = "")
    }, M.prototype.hide = function (a) {
        this.enabled && (this.container.style.display = "none", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, ("undefined" == typeof a || a) && this.chart.resetOverlayedCanvas())
    }, A.prototype.getPercentAndTotal = function (a, b) {
        var c = null
            , d = null
            , e = null;
        if (0 <= a.type.indexOf("stacked")) d = 0, c = b.x.getTime ? b.x.getTime() : b.x, c in a.plotUnit.yTotals && (d = a.plotUnit.yTotals[c], e = isNaN(b.y) ? 0 : 0 === d ? 0 : 100 * (b.y / d));
        else if ("pie" === a.type || "doughnut" === a.type) {
            for (i = d = 0; i < a.dataPoints.length; i++) isNaN(a.dataPoints[i].y) || (d += a.dataPoints[i].y);
            e = isNaN(b.y) ? 0 : 100 * (b.y / d)
        }
        return {
            percent: e
            , total: d
        }
    }, A.prototype.replaceKeywordsWithValue = function (a, b, c, d, f) {
        var g = this;
        if (f = "undefined" == typeof f ? 0 : f, (0 <= c.type.indexOf("stacked") || "pie" === c.type || "doughnut" === c.type) && (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))) {
            var h = "#percent"
                , i = "#total"
                , j = this.getPercentAndTotal(c, b)
                , i = isNaN(j.total) ? i : j.total
                , h = isNaN(j.percent) ? h : j.percent;
            do {
                if (j = "", c.percentFormatString) j = c.percentFormatString;
                else {
                    var j = "#,##0."
                        , k = Math.max(Math.ceil(Math.log(1 / Math.abs(h)) / Math.LN10), 2);
                    !isNaN(k) && isFinite(k) || (k = 2);
                    for (var l = 0; l < k; l++) j += "#"
                }
                a = a.replace("#percent", $(h, j, g._cultureInfo)), a = a.replace("#total", $(i, c.yValueFormatString ? c.yValueFormatString : "#,##0.########"))
            } while (0 <= a.indexOf("#percent") || 0 <= a.indexOf("#total"))
        }
        return a.replace(/\{.*?\}|"[^"]*"|'[^']*'/g, function (a) {
            if ('"' === a[0] && '"' === a[a.length - 1] || "'" === a[0] && "'" === a[a.length - 1]) return a.slice(1, a.length - 1);
            a = e(a.slice(1, a.length - 1)), a = a.replace("#index", f);
            var h = null;
            try {
                var i = a.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
                i && 0 < i.length && (h = e(i[2]), a = e(i[1]))
            }
            catch (a) {}
            if (i = null, "color" === a) return b.color ? b.color : c.color ? c.color : c._colorSet[d % c._colorSet.length];
            if (b.hasOwnProperty(a)) i = b;
            else {
                if (!c.hasOwnProperty(a)) return "";
                i = c
            }
            return i = i[a], null !== h && (i = i[h]), "x" !== a ? "y" === a ? $(i, b.yValueFormatString ? b.yValueFormatString : c.yValueFormatString ? c.yValueFormatString : "#,##0.########", g._cultureInfo) : "z" === a ? $(i, b.zValueFormatString ? b.zValueFormatString : c.zValueFormatString ? c.zValueFormatString : "#,##0.########", g._cultureInfo) : i : "dateTime" === g.plotInfo.axisXValueType || "dateTime" === c.xValueType || b.x && b.x.getTime ? g.plotInfo.plotTypes[0].plotUnits[0].axisX && !g.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic ? Z(i, b.xValueFormatString ? b.xValueFormatString : c.xValueFormatString ? c.xValueFormatString : g.axisX && g.axisX.autoValueFormatString ? g.axisX.autoValueFormatString : "DD MMM YY", g._cultureInfo) : void 0 : $(i, b.xValueFormatString ? b.xValueFormatString : c.xValueFormatString ? c.xValueFormatString : "#,##0.########", g._cultureInfo)
        })
    }, N.prototype.reset = function () {
        this.lastObjectId = 0, this.objectMap = [], this.rectangularRegionEventSubscriptions = [], this.previousDataPointEventObject = null, this.eventObjects = [], R && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath())
    }, N.prototype.getNewObjectTrackingId = function () {
        return ++this.lastObjectId
    }, N.prototype.mouseEventHandler = function (a) {
        if ("mousemove" === a.type || "click" === a.type) {
            var b = []
                , c = _(a)
                , d = null;
            if ((d = this.chart.getObjectAtXY(c.x, c.y, !1)) && "undefined" != typeof this.objectMap[d])
                if (d = this.objectMap[d], "dataPoint" === d.objectType) {
                    var e = this.chart.data[d.dataSeriesIndex]
                        , f = e.dataPoints[d.dataPointIndex]
                        , g = d.dataPointIndex;
                    d.eventParameter = {
                        x: c.x
                        , y: c.y
                        , dataPoint: f
                        , dataSeries: e._options
                        , dataPointIndex: g
                        , dataSeriesIndex: e.index
                        , chart: this.chart._publicChartReference
                    }, d.eventContext = {
                        context: f
                        , userContext: f
                        , mouseover: "mouseover"
                        , mousemove: "mousemove"
                        , mouseout: "mouseout"
                        , click: "click"
                    }, b.push(d), d = this.objectMap[e.id], d.eventParameter = {
                        x: c.x
                        , y: c.y
                        , dataPoint: f
                        , dataSeries: e._options
                        , dataPointIndex: g
                        , dataSeriesIndex: e.index
                        , chart: this.chart._publicChartReference
                    }, d.eventContext = {
                        context: e
                        , userContext: e._options
                        , mouseover: "mouseover"
                        , mousemove: "mousemove"
                        , mouseout: "mouseout"
                        , click: "click"
                    }, b.push(this.objectMap[e.id])
                }
                else "legendItem" === d.objectType && (e = this.chart.data[d.dataSeriesIndex], f = null !== d.dataPointIndex ? e.dataPoints[d.dataPointIndex] : null, d.eventParameter = {
                    x: c.x
                    , y: c.y
                    , dataSeries: e._options
                    , dataPoint: f
                    , dataPointIndex: d.dataPointIndex
                    , dataSeriesIndex: d.dataSeriesIndex
                    , chart: this.chart._publicChartReference
                }, d.eventContext = {
                    context: this.chart.legend
                    , userContext: this.chart.legend._options
                    , mouseover: "itemmouseover"
                    , mousemove: "itemmousemove"
                    , mouseout: "itemmouseout"
                    , click: "itemclick"
                }, b.push(d));
            for (e = [], c = 0; c < this.mouseoveredObjectMaps.length; c++) {
                for (f = !0, d = 0; d < b.length; d++)
                    if (b[d].id === this.mouseoveredObjectMaps[c].id) {
                        f = !1;
                        break
                    }
                f ? this.fireEvent(this.mouseoveredObjectMaps[c], "mouseout", a) : e.push(this.mouseoveredObjectMaps[c])
            }
            for (this.mouseoveredObjectMaps = e, c = 0; c < b.length; c++) {
                for (e = !1, d = 0; d < this.mouseoveredObjectMaps.length; d++)
                    if (b[c].id === this.mouseoveredObjectMaps[d].id) {
                        e = !0;
                        break
                    }
                e || (this.fireEvent(b[c], "mouseover", a), this.mouseoveredObjectMaps.push(b[c])), "click" === a.type ? this.fireEvent(b[c], "click", a) : "mousemove" === a.type && this.fireEvent(b[c], "mousemove", a)
            }
        }
    }, N.prototype.fireEvent = function (a, b, c) {
        if (a && b) {
            var d = a.eventParameter
                , e = a.eventContext
                , f = a.eventContext.userContext;
            f && e && f[e[b]] && f[e[b]].call(f, d), "mouseout" !== b ? f.cursor && f.cursor !== c.target.style.cursor && (c.target.style.cursor = f.cursor) : (c.target.style.cursor = this.chart._defaultCursor, delete a.eventParameter, delete a.eventContext), "click" === b && "dataPoint" === a.objectType && this.chart.pieDoughnutClickHandler && this.chart.pieDoughnutClickHandler.call(this.chart.data[a.dataSeriesIndex], d)
        }
    }, a(O, z), P.prototype.animate = function (a, b, c, d, e) {
        var f = this;
        for (this.chart.isAnimating = !0, e = e || ia.easing.linear, c && this.animations.push({
                startTime: (new Date).getTime() + (a ? a : 0)
                , duration: b
                , animationCallback: c
                , onComplete: d
            }), a = []; 0 < this.animations.length;) b = this.animations.shift(), c = (new Date).getTime(), d = 0, b.startTime <= c && (d = e(Math.min(c - b.startTime, b.duration), 0, 1, b.duration), d = Math.min(d, 1), isNaN(d) || !isFinite(d)) && (d = 1), 1 > d && a.push(b), b.animationCallback(d), 1 <= d && b.onComplete && b.onComplete();
        this.animations = a, 0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function () {
            f.animate.call(f)
        }) : this.chart.isAnimating = !1
    }, P.prototype.cancelAllAnimations = function () {
        this.animations = [], this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId), this.animationRequestId = null, this.chart.isAnimating = !1
    };
    var ia = {
            yScaleAnimation: function (a, b) {
                if (0 !== a) {
                    var c = b.dest
                        , d = b.source.canvas
                        , e = b.animationBase;
                    c.drawImage(d, 0, 0, d.width, d.height, 0, e - e * a, c.canvas.width / da, a * c.canvas.height / da)
                }
            }
            , xScaleAnimation: function (a, b) {
                if (0 !== a) {
                    var c = b.dest
                        , d = b.source.canvas
                        , e = b.animationBase;
                    c.drawImage(d, 0, 0, d.width, d.height, e - e * a, 0, a * c.canvas.width / da, c.canvas.height / da)
                }
            }
            , xClipAnimation: function (a, b) {
                if (0 !== a) {
                    var c = b.dest
                        , d = b.source.canvas;
                    c.save(), 0 < a && c.drawImage(d, 0, 0, d.width * a, d.height, 0, 0, d.width * a / da, d.height / da), c.restore()
                }
            }
            , fadeInAnimation: function (a, b) {
                if (0 !== a) {
                    var c = b.dest
                        , d = b.source.canvas;
                    c.save(), c.globalAlpha = a, c.drawImage(d, 0, 0, d.width, d.height, 0, 0, c.canvas.width / da, c.canvas.height / da), c.restore()
                }
            }
            , easing: {
                linear: function (a, b, c, d) {
                    return c * a / d + b
                }
                , easeOutQuad: function (a, b, c, d) {
                    return -c * (a /= d) * (a - 2) + b
                }
                , easeOutQuart: function (a, b, c, d) {
                    return -c * ((a = a / d - 1) * a * a * a - 1) + b
                }
                , easeInQuad: function (a, b, c, d) {
                    return c * (a /= d) * a + b
                }
                , easeInQuart: function (a, b, c, d) {
                    return c * (a /= d) * a * a * a + b
                }
            }
        }
        , ja = {
            drawMarker: function (a, b, c, d, e, f, g, h) {
                if (c) {
                    var i = 1;
                    c.fillStyle = f ? f : "#000000", c.strokeStyle = g ? g : "#000000", c.lineWidth = h ? h : 0, "circle" === d ? (c.moveTo(a, b), c.beginPath(), c.arc(a, b, e / 2, 0, 2 * Math.PI, !1), f && c.fill(), h && (g ? c.stroke() : (i = c.globalAlpha, c.globalAlpha = .15, c.strokeStyle = "black", c.stroke(), c.globalAlpha = i))) : "square" === d ? (c.beginPath(), c.rect(a - e / 2, b - e / 2, e, e), f && c.fill(), h && (g ? c.stroke() : (i = c.globalAlpha, c.globalAlpha = .15, c.strokeStyle = "black", c.stroke(), c.globalAlpha = i))) : "triangle" === d ? (c.beginPath(), c.moveTo(a - e / 2, b + e / 2), c.lineTo(a + e / 2, b + e / 2), c.lineTo(a, b - e / 2), c.closePath(), f && c.fill(), h && (g ? c.stroke() : (i = c.globalAlpha, c.globalAlpha = .15, c.strokeStyle = "black", c.stroke(), c.globalAlpha = i)), c.beginPath()) : "cross" === d && (c.strokeStyle = f, c.lineWidth = e / 4, c.beginPath(), c.moveTo(a - e / 2, b - e / 2), c.lineTo(a + e / 2, b + e / 2), c.stroke(), c.moveTo(a + e / 2, b - e / 2), c.lineTo(a - e / 2, b + e / 2), c.stroke())
                }
            }
            , drawMarkers: function (a) {
                for (var b = 0; b < a.length; b++) {
                    var c = a[b];
                    ja.drawMarker(c.x, c.y, c.ctx, c.type, c.size, c.color, c.borderColor, c.borderThickness)
                }
            }
        }
        , ka = {
            Chart: function (a, b) {
                var c = new A(a, b, this);
                this.render = function () {
                    c.render(this.options)
                }, this.options = c._options
            }
            , addColorSet: function (a, b) {
                U[a] = b
            }
            , addCultureInfo: function (a, b) {
                T[a] = b
            }
            , formatNumber: function (a, b, c) {
                if (c = c || "en", T[c]) return $(a, b || "#,##0.##", new O(c));
                throw "Unknown Culture Name"
            }
            , formatDate: function (a, b, c) {
                if (c = c || "en", T[c]) return Z(a, b || "DD MMM YYYY", new O(c));
                throw "Unknown Culture Name"
            }
        };
    ka.Chart.version = "v1.9.2 GA", window.CanvasJS = ka
}(), document.createElement("canvas").getContext || function () {
    function a() {
        return this.context_ || (this.context_ = new n(this))
    }

    function b(a, b, c) {
        var d = E.call(arguments, 2);
        return function () {
            return a.apply(b, d.concat(E.call(arguments)))
        }
    }

    function c(a) {
        return String(a).replace(/&/g, "&amp;").replace(/"/g, "&quot;")
    }

    function d(a) {
        a.namespaces.g_vml_ || a.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML"), a.namespaces.g_o_ || a.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML"), a.styleSheets.ex_canvas_ || (a = a.createStyleSheet(), a.owningElement.id = "ex_canvas_", a.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}")
    }

    function e(a) {
        var b = a.srcElement;
        switch (a.propertyName) {
        case "width":
            b.getContext().clearRect(), b.style.width = b.attributes.width.nodeValue + "px", b.firstChild.style.width = b.clientWidth + "px";
            break;
        case "height":
            b.getContext().clearRect(), b.style.height = b.attributes.height.nodeValue + "px", b.firstChild.style.height = b.clientHeight + "px"
        }
    }

    function f(a) {
        a = a.srcElement, a.firstChild && (a.firstChild.style.width = a.clientWidth + "px", a.firstChild.style.height = a.clientHeight + "px")
    }

    function g() {
        return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    }

    function h(a, b) {
        for (var c = g(), d = 0; 3 > d; d++)
            for (var e = 0; 3 > e; e++) {
                for (var f = 0, h = 0; 3 > h; h++) f += a[d][h] * b[h][e];
                c[d][e] = f
            }
        return c
    }

    function i(a, b) {
        b.fillStyle = a.fillStyle, b.lineCap = a.lineCap, b.lineJoin = a.lineJoin, b.lineWidth = a.lineWidth, b.miterLimit = a.miterLimit, b.shadowBlur = a.shadowBlur, b.shadowColor = a.shadowColor, b.shadowOffsetX = a.shadowOffsetX, b.shadowOffsetY = a.shadowOffsetY, b.strokeStyle = a.strokeStyle, b.globalAlpha = a.globalAlpha, b.font = a.font, b.textAlign = a.textAlign, b.textBaseline = a.textBaseline, b.arcScaleX_ = a.arcScaleX_, b.arcScaleY_ = a.arcScaleY_, b.lineScale_ = a.lineScale_
    }

    function j(a) {
        var b = a.indexOf("(", 3)
            , c = a.indexOf(")", b + 1)
            , b = a.substring(b + 1, c).split(",");
        return 4 == b.length && "a" == a.charAt(3) || (b[3] = 1), b
    }

    function k(a, b, c) {
        return Math.min(c, Math.max(b, a))
    }

    function l(a, b, c) {
        return 0 > c && c++, 1 < c && c--, 1 > 6 * c ? a + 6 * (b - a) * c : 1 > 2 * c ? b : 2 > 3 * c ? a + 6 * (b - a) * (2 / 3 - c) : a
    }

    function m(a) {
        if (a in K) return K[a];
        var b, c = 1;
        if (a = String(a), "#" == a.charAt(0)) b = a;
        else if (/^rgb/.test(a)) {
            c = j(a), b = "#";
            for (var d, e = 0; 3 > e; e++) d = -1 != c[e].indexOf("%") ? Math.floor(255 * (parseFloat(c[e]) / 100)) : +c[e], b += G[k(d, 0, 255)];
            c = +c[3]
        }
        else if (/^hsl/.test(a)) {
            if (e = c = j(a), b = parseFloat(e[0]) / 360 % 360, 0 > b && b++, d = k(parseFloat(e[1]) / 100, 0, 1), e = k(parseFloat(e[2]) / 100, 0, 1), 0 == d) d = e = b = e;
            else {
                var f = .5 > e ? e * (1 + d) : e + d - e * d
                    , g = 2 * e - f;
                d = l(g, f, b + 1 / 3), e = l(g, f, b), b = l(g, f, b - 1 / 3)
            }
            b = "#" + G[Math.floor(255 * d)] + G[Math.floor(255 * e)] + G[Math.floor(255 * b)], c = c[3]
        }
        else b = J[a] || a;
        return K[a] = {
            color: b
            , alpha: c
        }
    }

    function n(a) {
        this.m_ = g(), this.mStack_ = [], this.aStack_ = [], this.currentPath_ = [], this.fillStyle = this.strokeStyle = "#000", this.lineWidth = 1, this.lineJoin = "miter", this.lineCap = "butt", this.miterLimit = 1 * C, this.globalAlpha = 1, this.font = "10px sans-serif", this.textAlign = "left", this.textBaseline = "alphabetic", this.canvas = a;
        var b = "width:" + a.clientWidth + "px;height:" + a.clientHeight + "px;overflow:hidden;position:absolute"
            , c = a.ownerDocument.createElement("div");
        c.style.cssText = b, a.appendChild(c), b = c.cloneNode(!1), b.style.backgroundColor = "red", b.style.filter = "alpha(opacity=0)", a.appendChild(b), this.element_ = c, this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1
    }

    function o(a, b, c, d) {
        a.currentPath_.push({
            type: "bezierCurveTo"
            , cp1x: b.x
            , cp1y: b.y
            , cp2x: c.x
            , cp2y: c.y
            , x: d.x
            , y: d.y
        }), a.currentX_ = d.x, a.currentY_ = d.y
    }

    function p(a, b) {
        var c = m(a.strokeStyle)
            , d = c.color
            , c = c.alpha * a.globalAlpha
            , e = a.lineScale_ * a.lineWidth;
        1 > e && (c *= e), b.push("<g_vml_:stroke", ' opacity="', c, '"', ' joinstyle="', a.lineJoin, '"', ' miterlimit="', a.miterLimit, '"', ' endcap="', M[a.lineCap] || "square", '"', ' weight="', e, 'px"', ' color="', d, '" />')
    }

    function q(a, b, c, d) {
        var e = a.fillStyle
            , f = a.arcScaleX_
            , g = a.arcScaleY_
            , h = d.x - c.x
            , i = d.y - c.y;
        if (e instanceof t) {
            var j = 0
                , k = d = 0
                , l = 0
                , n = 1;
            if ("gradient" == e.type_) {
                j = e.x1_ / f, c = e.y1_ / g;
                var o = r(a, e.x0_ / f, e.y0_ / g)
                    , j = r(a, j, c)
                    , j = 180 * Math.atan2(j.x - o.x, j.y - o.y) / Math.PI;
                0 > j && (j += 360), 1e-6 > j && (j = 0)
            }
            else o = r(a, e.x0_, e.y0_), d = (o.x - c.x) / h, k = (o.y - c.y) / i, h /= f * C, i /= g * C, n = w.max(h, i), l = 2 * e.r0_ / n, n = 2 * e.r1_ / n - l;
            f = e.colors_, f.sort(function (a, b) {
                return a.offset - b.offset
            }), g = f.length, o = f[0].color, c = f[g - 1].color, h = f[0].alpha * a.globalAlpha, a = f[g - 1].alpha * a.globalAlpha;
            for (var i = [], p = 0; p < g; p++) {
                var q = f[p];
                i.push(q.offset * n + l + " " + q.color)
            }
            b.push('<g_vml_:fill type="', e.type_, '"', ' method="none" focus="100%"', ' color="', o, '"', ' color2="', c, '"', ' colors="', i.join(","), '"', ' opacity="', a, '"', ' g_o_:opacity2="', h, '"', ' angle="', j, '"', ' focusposition="', d, ",", k, '" />')
        }
        else e instanceof u ? h && i && b.push("<g_vml_:fill", ' position="', -c.x / h * f * f, ",", -c.y / i * g * g, '"', ' type="tile"', ' src="', e.src_, '" />') : (e = m(a.fillStyle), b.push('<g_vml_:fill color="', e.color, '" opacity="', e.alpha * a.globalAlpha, '" />'))
    }

    function r(a, b, c) {
        return a = a.m_, {
            x: C * (b * a[0][0] + c * a[1][0] + a[2][0]) - D
            , y: C * (b * a[0][1] + c * a[1][1] + a[2][1]) - D
        }
    }

    function s(a, b, c) {
        isFinite(b[0][0]) && isFinite(b[0][1]) && isFinite(b[1][0]) && isFinite(b[1][1]) && isFinite(b[2][0]) && isFinite(b[2][1]) && (a.m_ = b, c && (a.lineScale_ = B(A(b[0][0] * b[1][1] - b[0][1] * b[1][0]))))
    }

    function t(a) {
        this.type_ = a, this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0, this.colors_ = []
    }

    function u(a, b) {
        if (!a || 1 != a.nodeType || "IMG" != a.tagName) throw new v("TYPE_MISMATCH_ERR");
        if ("complete" != a.readyState) throw new v("INVALID_STATE_ERR");
        switch (b) {
        case "repeat":
        case null:
        case "":
            this.repetition_ = "repeat";
            break;
        case "repeat-x":
        case "repeat-y":
        case "no-repeat":
            this.repetition_ = b;
            break;
        default:
            throw new v("SYNTAX_ERR")
        }
        this.src_ = a.src, this.width_ = a.width, this.height_ = a.height
    }

    function v(a) {
        this.code = this[a], this.message = a + ": DOM Exception " + this.code
    }
    var w = Math
        , x = w.round
        , y = w.sin
        , z = w.cos
        , A = w.abs
        , B = w.sqrt
        , C = 10
        , D = C / 2;
    navigator.userAgent.match(/MSIE ([\d.]+)?/);
    var E = Array.prototype.slice;
    d(document);
    var F = {
        init: function (a) {
            a = a || document, a.createElement("canvas"), a.attachEvent("onreadystatechange", b(this.init_, this, a))
        }
        , init_: function (a) {
            a = a.getElementsByTagName("canvas");
            for (var b = 0; b < a.length; b++) this.initElement(a[b])
        }
        , initElement: function (b) {
            if (!b.getContext) {
                b.getContext = a, d(b.ownerDocument), b.innerHTML = "", b.attachEvent("onpropertychange", e), b.attachEvent("onresize", f);
                var c = b.attributes;
                c.width && c.width.specified ? b.style.width = c.width.nodeValue + "px" : b.width = b.clientWidth, c.height && c.height.specified ? b.style.height = c.height.nodeValue + "px" : b.height = b.clientHeight
            }
            return b
        }
    };
    F.init();
    for (var G = [], H = 0; 16 > H; H++)
        for (var I = 0; 16 > I; I++) G[16 * H + I] = H.toString(16) + I.toString(16);
    var J = {
            aliceblue: "#F0F8FF"
            , antiquewhite: "#FAEBD7"
            , aquamarine: "#7FFFD4"
            , azure: "#F0FFFF"
            , beige: "#F5F5DC"
            , bisque: "#FFE4C4"
            , black: "#000000"
            , blanchedalmond: "#FFEBCD"
            , blueviolet: "#8A2BE2"
            , brown: "#A52A2A"
            , burlywood: "#DEB887"
            , cadetblue: "#5F9EA0"
            , chartreuse: "#7FFF00"
            , chocolate: "#D2691E"
            , coral: "#FF7F50"
            , cornflowerblue: "#6495ED"
            , cornsilk: "#FFF8DC"
            , crimson: "#DC143C"
            , cyan: "#00FFFF"
            , darkblue: "#00008B"
            , darkcyan: "#008B8B"
            , darkgoldenrod: "#B8860B"
            , darkgray: "#A9A9A9"
            , darkgreen: "#006400"
            , darkgrey: "#A9A9A9"
            , darkkhaki: "#BDB76B"
            , darkmagenta: "#8B008B"
            , darkolivegreen: "#556B2F"
            , darkorange: "#FF8C00"
            , darkorchid: "#9932CC"
            , darkred: "#8B0000"
            , darksalmon: "#E9967A"
            , darkseagreen: "#8FBC8F"
            , darkslateblue: "#483D8B"
            , darkslategray: "#2F4F4F"
            , darkslategrey: "#2F4F4F"
            , darkturquoise: "#00CED1"
            , darkviolet: "#9400D3"
            , deeppink: "#FF1493"
            , deepskyblue: "#00BFFF"
            , dimgray: "#696969"
            , dimgrey: "#696969"
            , dodgerblue: "#1E90FF"
            , firebrick: "#B22222"
            , floralwhite: "#FFFAF0"
            , forestgreen: "#228B22"
            , gainsboro: "#DCDCDC"
            , ghostwhite: "#F8F8FF"
            , gold: "#FFD700"
            , goldenrod: "#DAA520"
            , grey: "#808080"
            , greenyellow: "#ADFF2F"
            , honeydew: "#F0FFF0"
            , hotpink: "#FF69B4"
            , indianred: "#CD5C5C"
            , indigo: "#4B0082"
            , ivory: "#FFFFF0"
            , khaki: "#F0E68C"
            , lavender: "#E6E6FA"
            , lavenderblush: "#FFF0F5"
            , lawngreen: "#7CFC00"
            , lemonchiffon: "#FFFACD"
            , lightblue: "#ADD8E6"
            , lightcoral: "#F08080"
            , lightcyan: "#E0FFFF"
            , lightgoldenrodyellow: "#FAFAD2"
            , lightgreen: "#90EE90"
            , lightgrey: "#D3D3D3"
            , lightpink: "#FFB6C1"
            , lightsalmon: "#FFA07A"
            , lightseagreen: "#20B2AA"
            , lightskyblue: "#87CEFA"
            , lightslategray: "#778899"
            , lightslategrey: "#778899"
            , lightsteelblue: "#B0C4DE"
            , lightyellow: "#FFFFE0"
            , limegreen: "#32CD32"
            , linen: "#FAF0E6"
            , magenta: "#FF00FF"
            , mediumaquamarine: "#66CDAA"
            , mediumblue: "#0000CD"
            , mediumorchid: "#BA55D3"
            , mediumpurple: "#9370DB"
            , mediumseagreen: "#3CB371"
            , mediumslateblue: "#7B68EE"
            , mediumspringgreen: "#00FA9A"
            , mediumturquoise: "#48D1CC"
            , mediumvioletred: "#C71585"
            , midnightblue: "#191970"
            , mintcream: "#F5FFFA"
            , mistyrose: "#FFE4E1"
            , moccasin: "#FFE4B5"
            , navajowhite: "#FFDEAD"
            , oldlace: "#FDF5E6"
            , olivedrab: "#6B8E23"
            , orange: "#FFA500"
            , orangered: "#FF4500"
            , orchid: "#DA70D6"
            , palegoldenrod: "#EEE8AA"
            , palegreen: "#98FB98"
            , paleturquoise: "#AFEEEE"
            , palevioletred: "#DB7093"
            , papayawhip: "#FFEFD5"
            , peachpuff: "#FFDAB9"
            , peru: "#CD853F"
            , pink: "#FFC0CB"
            , plum: "#DDA0DD"
            , powderblue: "#B0E0E6"
            , rosybrown: "#BC8F8F"
            , royalblue: "#4169E1"
            , saddlebrown: "#8B4513"
            , salmon: "#FA8072"
            , sandybrown: "#F4A460"
            , seagreen: "#2E8B57"
            , seashell: "#FFF5EE"
            , sienna: "#A0522D"
            , skyblue: "#87CEEB"
            , slateblue: "#6A5ACD"
            , slategray: "#708090"
            , slategrey: "#708090"
            , snow: "#FFFAFA"
            , springgreen: "#00FF7F"
            , steelblue: "#4682B4"
            , tan: "#D2B48C"
            , thistle: "#D8BFD8"
            , tomato: "#FF6347"
            , turquoise: "#40E0D0"
            , violet: "#EE82EE"
            , wheat: "#F5DEB3"
            , whitesmoke: "#F5F5F5"
            , yellowgreen: "#9ACD32"
        }
        , K = {}
        , L = {}
        , M = {
            butt: "flat"
            , round: "round"
        }
        , H = n.prototype;
    H.clearRect = function () {
        this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null), this.element_.innerHTML = ""
    }, H.beginPath = function () {
        this.currentPath_ = []
    }, H.moveTo = function (a, b) {
        var c = r(this, a, b);
        this.currentPath_.push({
            type: "moveTo"
            , x: c.x
            , y: c.y
        }), this.currentX_ = c.x, this.currentY_ = c.y
    }, H.lineTo = function (a, b) {
        var c = r(this, a, b);
        this.currentPath_.push({
            type: "lineTo"
            , x: c.x
            , y: c.y
        }), this.currentX_ = c.x, this.currentY_ = c.y
    }, H.bezierCurveTo = function (a, b, c, d, e, f) {
        e = r(this, e, f), a = r(this, a, b), c = r(this, c, d), o(this, a, c, e)
    }, H.quadraticCurveTo = function (a, b, c, d) {
        a = r(this, a, b), c = r(this, c, d), d = {
            x: this.currentX_ + 2 / 3 * (a.x - this.currentX_)
            , y: this.currentY_ + 2 / 3 * (a.y - this.currentY_)
        }, o(this, d, {
            x: d.x + (c.x - this.currentX_) / 3
            , y: d.y + (c.y - this.currentY_) / 3
        }, c)
    }, H.arc = function (a, b, c, d, e, f) {
        c *= C;
        var g = f ? "at" : "wa"
            , h = a + z(d) * c - D
            , i = b + y(d) * c - D;
        d = a + z(e) * c - D, e = b + y(e) * c - D, h != d || f || (h += .125), a = r(this, a, b), h = r(this, h, i), d = r(this, d, e), this.currentPath_.push({
            type: g
            , x: a.x
            , y: a.y
            , radius: c
            , xStart: h.x
            , yStart: h.y
            , xEnd: d.x
            , yEnd: d.y
        })
    }, H.rect = function (a, b, c, d) {
        this.moveTo(a, b), this.lineTo(a + c, b), this.lineTo(a + c, b + d), this.lineTo(a, b + d), this.closePath()
    }, H.strokeRect = function (a, b, c, d) {
        var e = this.currentPath_;
        this.beginPath(), this.moveTo(a, b), this.lineTo(a + c, b), this.lineTo(a + c, b + d), this.lineTo(a, b + d), this.closePath(), this.stroke(), this.currentPath_ = e
    }, H.fillRect = function (a, b, c, d) {
        var e = this.currentPath_;
        this.beginPath(), this.moveTo(a, b), this.lineTo(a + c, b), this.lineTo(a + c, b + d), this.lineTo(a, b + d), this.closePath(), this.fill(), this.currentPath_ = e
    }, H.createLinearGradient = function (a, b, c, d) {
        var e = new t("gradient");
        return e.x0_ = a, e.y0_ = b, e.x1_ = c, e.y1_ = d, e
    }, H.createRadialGradient = function (a, b, c, d, e, f) {
        var g = new t("gradientradial");
        return g.x0_ = a, g.y0_ = b, g.r0_ = c, g.x1_ = d, g.y1_ = e, g.r1_ = f, g
    }, H.drawImage = function (a, b) {
        var c, d, e, f, g, h, i, j;
        e = a.runtimeStyle.width, f = a.runtimeStyle.height, a.runtimeStyle.width = "auto", a.runtimeStyle.height = "auto";
        var k = a.width
            , l = a.height;
        if (a.runtimeStyle.width = e, a.runtimeStyle.height = f, 3 == arguments.length) c = arguments[1], d = arguments[2], g = h = 0, i = e = k, j = f = l;
        else if (5 == arguments.length) c = arguments[1], d = arguments[2], e = arguments[3], f = arguments[4], g = h = 0, i = k, j = l;
        else {
            if (9 != arguments.length) throw Error("Invalid number of arguments");
            g = arguments[1], h = arguments[2], i = arguments[3], j = arguments[4], c = arguments[5], d = arguments[6], e = arguments[7], f = arguments[8]
        }
        var m = r(this, c, d)
            , n = [];
        if (n.push(" <g_vml_:group", ' coordsize="', 10 * C, ",", 10 * C, '"', ' coordorigin="0,0"', ' style="width:', 10, "px;height:", 10, "px;position:absolute;"), 1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {
            var o = [];
            o.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", x(m.x / C), ",", "Dy=", x(m.y / C), "");
            var p = r(this, c + e, d)
                , q = r(this, c, d + f);
            c = r(this, c + e, d + f), m.x = w.max(m.x, p.x, q.x, c.x), m.y = w.max(m.y, p.y, q.y, c.y), n.push("padding:0 ", x(m.x / C), "px ", x(m.y / C), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", o.join(""), ", sizingmethod='clip');")
        }
        else n.push("top:", x(m.y / C), "px;left:", x(m.x / C), "px;");
        n.push(' ">', '<g_vml_:image src="', a.src, '"', ' style="width:', C * e, "px;", " height:", C * f, 'px"', ' cropleft="', g / k, '"', ' croptop="', h / l, '"', ' cropright="', (k - g - i) / k, '"', ' cropbottom="', (l - h - j) / l, '"', " />", "</g_vml_:group>"), this.element_.insertAdjacentHTML("BeforeEnd", n.join(""))
    }, H.stroke = function (a) {
        var b = [];
        b.push("<g_vml_:shape", ' filled="', !!a, '"', ' style="position:absolute;width:', 10, "px;height:", 10, 'px;"', ' coordorigin="0,0"', ' coordsize="', 10 * C, ",", 10 * C, '"', ' stroked="', !a, '"', ' path="');
        for (var c = {
                x: null
                , y: null
            }, d = {
                x: null
                , y: null
            }, e = 0; e < this.currentPath_.length; e++) {
            var f = this.currentPath_[e];
            switch (f.type) {
            case "moveTo":
                b.push(" m ", x(f.x), ",", x(f.y));
                break;
            case "lineTo":
                b.push(" l ", x(f.x), ",", x(f.y));
                break;
            case "close":
                b.push(" x "), f = null;
                break;
            case "bezierCurveTo":
                b.push(" c ", x(f.cp1x), ",", x(f.cp1y), ",", x(f.cp2x), ",", x(f.cp2y), ",", x(f.x), ",", x(f.y));
                break;
            case "at":
            case "wa":
                b.push(" ", f.type, " ", x(f.x - this.arcScaleX_ * f.radius), ",", x(f.y - this.arcScaleY_ * f.radius), " ", x(f.x + this.arcScaleX_ * f.radius), ",", x(f.y + this.arcScaleY_ * f.radius), " ", x(f.xStart), ",", x(f.yStart), " ", x(f.xEnd), ",", x(f.yEnd))
            }
            f && ((null == c.x || f.x < c.x) && (c.x = f.x), (null == d.x || f.x > d.x) && (d.x = f.x), (null == c.y || f.y < c.y) && (c.y = f.y), (null == d.y || f.y > d.y) && (d.y = f.y))
        }
        b.push(' ">'), a ? q(this, b, c, d) : p(this, b), b.push("</g_vml_:shape>"), this.element_.insertAdjacentHTML("beforeEnd", b.join(""))
    }, H.fill = function () {
        this.stroke(!0)
    }, H.closePath = function () {
        this.currentPath_.push({
            type: "close"
        })
    }, H.save = function () {
        var a = {};
        i(this, a), this.aStack_.push(a), this.mStack_.push(this.m_), this.m_ = h(g(), this.m_)
    }, H.restore = function () {
        this.aStack_.length && (i(this.aStack_.pop(), this), this.m_ = this.mStack_.pop())
    }, H.translate = function (a, b) {
        s(this, h([[1, 0, 0], [0, 1, 0], [a, b, 1]], this.m_), !1)
    }, H.rotate = function (a) {
        var b = z(a);
        a = y(a), s(this, h([[b, a, 0], [-a, b, 0], [0, 0, 1]], this.m_), !1)
    }, H.scale = function (a, b) {
        this.arcScaleX_ *= a, this.arcScaleY_ *= b, s(this, h([[a, 0, 0], [0, b, 0], [0, 0, 1]], this.m_), !0)
    }, H.transform = function (a, b, c, d, e, f) {
        s(this, h([[a, b, 0], [c, d, 0], [e, f, 1]], this.m_), !0)
    }, H.setTransform = function (a, b, c, d, e, f) {
        s(this, [[a, b, 0], [c, d, 0], [e, f, 1]], !0)
    }, H.drawText_ = function (a, b, d, e, f) {
        var g = this.m_;
        e = 0;
        var k, h = 1e3
            , i = 0
            , j = [];
        if (k = this.font, L[k]) k = L[k];
        else {
            var l = document.createElement("div").style;
            try {
                l.font = k
            }
            catch (a) {}
            k = L[k] = {
                style: l.fontStyle || "normal"
                , variant: l.fontVariant || "normal"
                , weight: l.fontWeight || "normal"
                , size: l.fontSize || 10
                , family: l.fontFamily || "sans-serif"
            }
        }
        var l = k
            , m = this.element_;
        k = {};
        for (var n in l) k[n] = l[n];
        switch (n = parseFloat(m.currentStyle.fontSize), m = parseFloat(l.size), "number" == typeof l.size ? k.size = l.size : -1 != l.size.indexOf("px") ? k.size = m : -1 != l.size.indexOf("em") ? k.size = n * m : -1 != l.size.indexOf("%") ? k.size = n / 100 * m : -1 != l.size.indexOf("pt") ? k.size = m / .75 : k.size = n, k.size *= .981, n = k.style + " " + k.variant + " " + k.weight + " " + k.size + "px " + k.family, m = this.element_.currentStyle, l = this.textAlign.toLowerCase()) {
        case "left":
        case "center":
        case "right":
            break;
        case "end":
            l = "ltr" == m.direction ? "right" : "left";
            break;
        case "start":
            l = "rtl" == m.direction ? "right" : "left";
            break;
        default:
            l = "left"
        }
        switch (this.textBaseline) {
        case "hanging":
        case "top":
            i = k.size / 1.75;
            break;
        case "middle":
            break;
        default:
        case null:
        case "alphabetic":
        case "ideographic":
        case "bottom":
            i = -k.size / 2.25
        }
        switch (l) {
        case "right":
            e = 1e3, h = .05;
            break;
        case "center":
            e = h = 500
        }
        b = r(this, b + 0, d + i), j.push('<g_vml_:line from="', -e, ' 0" to="', h, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !f, '" stroked="', !!f, '" style="position:absolute;width:1px;height:1px;">'), f ? p(this, j) : q(this, j, {
            x: -e
            , y: 0
        }, {
            x: h
            , y: k.size
        }), f = g[0][0].toFixed(3) + "," + g[1][0].toFixed(3) + "," + g[0][1].toFixed(3) + "," + g[1][1].toFixed(3) + ",0,0", b = x(b.x / C) + "," + x(b.y / C), j.push('<g_vml_:skew on="t" matrix="', f, '" ', ' offset="', b, '" origin="', e, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', c(a), '" style="v-text-align:', l, ";font:", c(n), '" /></g_vml_:line>'), this.element_.insertAdjacentHTML("beforeEnd", j.join(""))
    }, H.fillText = function (a, b, c, d) {
        this.drawText_(a, b, c, d, !1)
    }, H.strokeText = function (a, b, c, d) {
        this.drawText_(a, b, c, d, !0)
    }, H.measureText = function (a) {
        this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), this.textMeasureEl_ = this.element_.lastChild);
        var b = this.element_.ownerDocument;
        return this.textMeasureEl_.innerHTML = "", this.textMeasureEl_.style.font = this.font, this.textMeasureEl_.appendChild(b.createTextNode(a)), {
            width: this.textMeasureEl_.offsetWidth
        }
    }, H.clip = function () {}, H.arcTo = function () {}, H.createPattern = function (a, b) {
        return new u(a, b)
    }, t.prototype.addColorStop = function (a, b) {
        b = m(b), this.colors_.push({
            offset: a
            , color: b.color
            , alpha: b.alpha
        })
    }, H = v.prototype = Error(), H.INDEX_SIZE_ERR = 1, H.DOMSTRING_SIZE_ERR = 2, H.HIERARCHY_REQUEST_ERR = 3, H.WRONG_DOCUMENT_ERR = 4, H.INVALID_CHARACTER_ERR = 5, H.NO_DATA_ALLOWED_ERR = 6, H.NO_MODIFICATION_ALLOWED_ERR = 7, H.NOT_FOUND_ERR = 8, H.NOT_SUPPORTED_ERR = 9, H.INUSE_ATTRIBUTE_ERR = 10, H.INVALID_STATE_ERR = 11, H.SYNTAX_ERR = 12, H.INVALID_MODIFICATION_ERR = 13, H.NAMESPACE_ERR = 14, H.INVALID_ACCESS_ERR = 15, H.VALIDATION_ERR = 16, H.TYPE_MISMATCH_ERR = 17, G_vmlCanvasManager = F, CanvasRenderingContext2D = n, CanvasGradient = t, CanvasPattern = u, DOMException = v
}();